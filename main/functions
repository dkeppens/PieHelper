# PieHelper module declarations not required by the update process (By Davy Keppens on 06/10/18)
# Toggle debugstate of a specific module between Enable/Disable by running 'confpieh_ph.sh -p debug -m module_name'

function ph_check_password_validity {

declare PH_PASSWD="$1"

[[ "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -z "$PH_PASSWD" ]]
then
	ph_set_result -m "Passwords cannot be empty"
else
	if echo "$PH_PASSWD" 2>/dev/null | grep -E "'|[[:space:]]" >/dev/null
	then
		ph_set_result -m "Passwords may not contain single quote (') or space characters"
	else
		return 0
	fi
fi
return 1
}

function ph_create_oos_app_code {

declare PH_APP="$1"
declare -l PH_APPL=""

[[ "$#" -ne "1" || -z "$PH_APP" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPL="${PH_APP:0:3}"
printf "%8s%s\n" "" "--> Adding configure function for application '${PH_APP}' to codebase file '${PH_MAIN_DIR}/functions.user'"
if ph_check_app_state_validity -a "$PH_APP" -q -d
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Nothing to do since ${PH_APP} is not an out-of-scope application"
	ph_set_result -r 0
else
	if ! cat >>"${PH_MAIN_DIR}/functions.user" 2>/dev/null <<EOF

function ph_configure_${PH_APPL} {

## add your code here
return 0
}
EOF
	then
		ph_set_result -m "An error occurred trying to add function 'ph_configure_${PH_APPL}' to codebase file '${PH_MAIN_DIR}/functions.user'"
		ph_run_with_rollback -c false -c "Could not add" || \
			return 1
	else
		ph_add_value_to_param -p PH_REMOVE_OOS_APPS_CODE -v "$PH_APP"
		ph_run_with_rollback -c true -m "Configuration code for ${PH_APP} can now be added to '${PH_MAIN_DIR}/functions.user'"
	fi
fi
return 0
}

function ph_get_app_executable {

declare PH_APP
declare PH_APP_EXEC
declare PH_APP_GRAPH
declare PH_APP_CMD
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:c: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP="$OPTARG" ;;
			     c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_CMD="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_CMD" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_GRAPH="$(ph_get_app_graphical_prop -a "$PH_APP" -c "$PH_APP_CMD")"
PH_APP_EXEC="$(echo -n "$PH_APP_CMD" | nawk -v app="$PH_APP" -v appgraph="$PH_APP_GRAPH" '{ \
		if (appgraph == "yes") { \
			if (app == "X11") { \
				printf $1 \
			} else { \
				printf $2 \
			} \
		} else { \
			printf $1 \
		} \
	}')"
echo -n "$PH_APP_EXEC"
return 0
}

function ph_get_app_graphical_prop {

declare PH_APP
declare PH_APP_GRAPH
declare PH_APP_CMD
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:c: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP="$OPTARG" ;;
			     c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_CMD="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_CMD" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_GRAPH="$(echo -n "$PH_APP_CMD" | nawk -v app="$PH_APP" 'BEGIN { \
		graph = "no" \
	} { \
		if (app == "X11") { \
			graph = "yes" \
		} else { \
			if ($1 ~ /^\/usr\/bin\/xinit$/ || $1 ~ /^\/usr\/bin\/startx$/) { \
				graph = "yes" \
			} \
		} \
	} END { \
		printf "%s", graph \
	}')"
echo -n "$PH_APP_GRAPH"
return 0
}

function ph_remove_oos_app_code {

declare PH_APP="$1"
declare -l PH_APPL=""

[[ "$#" -ne "1" || -z "$PH_APP" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPL="${PH_APP:0:3}"
printf "%8s%s\n" "" "--> Removing configure function for application '${PH_APP}' from codebase file '${PH_MAIN_DIR}/functions.user'"
if ph_check_app_state_validity -a "$PH_APP" -q -d
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Nothing to do since ${PH_APP} is not an out-of-scope application"
	ph_set_result -r 0
else
	if nawk -v app="_${PH_APPL}$" 'BEGIN {
			flag = "0" 
		}
		$1 ~ /^function$/ && $2 ~ app {
			flag = "1" ;
			while ($1 !~ /^}$/) {
				getline
			} ;
			getline ;
			flag = "0" ;
			next
		} {
			if (flag == 0) {
				print $0
			}
		}' "${PH_MAIN_DIR}/functions.user" >"${PH_TMP_DIR}/functions_user_tmp" 2>/dev/null
	then
		if mv "${PH_TMP_DIR}/functions_user_tmp" "${PH_MAIN_DIR}/functions.user" 2>/dev/null
		then
			ph_add_value_to_param -p PH_CREATE_OOS_APPS_CODE -v "$PH_APP"
			ph_run_with_rollback -c true && \
				return "$?"
		fi
	fi
fi
"$PH_SUDO" rm "${PH_TMP_DIR}/functions_user_tmp" 2>/dev/null
ph_set_result -m "An error occurred trying to remove function 'ph_configure_${PH_APPL}' from codebase file '${PH_MAIN_DIR}/functions.user'"
ph_run_with_rollback -c false -m "Could not remove" || \
	return 1
}

function ph_add_line_to_file {

declare PH_LINE=""
declare PH_PARAMS=""
declare PH_FILE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_ADD_AS_ROOT="1"

OPTIND="1"

while getopts l:f:r PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in l)
		[[ -n "$PH_LINE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_LINE="$OPTARG" ;;
			     f)
		[[ -n "$PH_FILE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG" ;;
			     r)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-r"
		PH_ADD_AS_ROOT="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || "$#" -lt "4" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_ADD_AS_ROOT" -eq "0" ]]
then
	if echo -e "$PH_LINE" 2>/dev/null | "$PH_SUDO" tee -a "$PH_FILE" >/dev/null 2>&1
	then
		ph_add_value_to_param -p PH_REMOVE_LINES -v "${PH_FILE}'${PH_PARAMS}'$(echo -e "$PH_LINE")"
		return 0
	fi
else
	if echo -e "$PH_LINE" >>"$PH_FILE" 2>/dev/null
	then
		ph_add_value_to_param -p PH_REMOVE_LINES -v "${PH_FILE}'${PH_PARAMS}'$(echo -e "$PH_LINE")"
		return 0
	fi
fi
ph_set_result -m "An error occurred trying to add line '${PH_LINE}' to file '${PH_FILE}'"
return 1
}

function ph_remove_line_from_file {

declare PH_LINE_REGEX=""
declare PH_LINE=""
declare PH_PARAMS=""
declare PH_FILE=""
declare PH_LINK_TARGET=""
declare PH_TMP_FILE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -i PH_REMOVE_AS_ROOT="1"

OPTIND="1"

while getopts l:f:r PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in l)
		[[ -n "$PH_LINE_REGEX" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_LINE_REGEX="$OPTARG" ;;
		     f)
		[[ -n "$PH_FILE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG"
		PH_TMP_FILE="${PH_TMP_DIR}/$(echo -n "${PH_FILE##*/}" | sed 's/\./_/g')_tmp.$(date +'%s%N')" ;;
		     r)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-r"
		PH_REMOVE_AS_ROOT="0" ;;
		     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || -z "$PH_LINE_REGEX" || "$#" -lt "2" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_COUNT="$("$PH_SUDO" grep -P "^${PH_LINE_REGEX}$" "$PH_FILE" 2>/dev/null | wc -l)"
then
	if PH_LINE="$("$PH_SUDO" nawk -v comp="$PH_COUNT" -v line="^${PH_LINE_REGEX}$" 'BEGIN { \
			count = "0" \
		} \
		$0 ~ line { \
			count++ ; \
			if (count != comp) { \
				next \
			} else { \
				print ; \
				exit \
			} \
		}' "$PH_FILE" 2>/dev/null)"
	then
		if "$PH_SUDO" nawk -v comp="$PH_COUNT" -v line="^${PH_LINE_REGEX}$" 'BEGIN { \
				count = "0" \
			} \
			$0 ~ line { \
				count++ ; \
				if (count != comp) { \
					print ; \
					next \
				} else { \
					next \
				} \
			} { \
				print \
			}' "$PH_FILE" >"$PH_TMP_FILE" 2>/dev/null
		then
			if [[ "$PH_REMOVE_AS_ROOT" -eq "0" ]]
			then
				if [[ -f "$PH_FILE" ]]
				then
					if "$PH_SUDO" cp --no-preserve=mode,ownership "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
					then
						if "$PH_SUDO" rm "$PH_TMP_FILE" 2>/dev/null
						then
							ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"$PH_LINE")"
							return 0
						fi
					fi
				else
					if PH_LINK_TARGET="$(ph_get_link_target "$PH_FILE")"
					then
						if "$PH_SUDO" cp --no-preserve=mode,ownership "$PH_TMP_FILE" "$PH_LINK_TARGET" 2>/dev/null
						then
							if "$PH_SUDO" rm "$PH_TMP_FILE" 2>/dev/null
							then
								ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"$PH_LINE")"
								return 0
							fi
						fi
					else
						return 1
					fi
				fi
			else
				if [[ -f "$PH_FILE" ]]
				then
					if mv "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
					then
						ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"$PH_LINE")"
						return 0
					fi
				else
					if PH_LINK_TARGET="$(ph_get_link_target "$PH_FILE")"
					then
						if mv "$PH_TMP_FILE" "$PH_LINK_TARGET" 2>/dev/null
						then
							ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"$PH_LINE")"
							return 0
						fi
					else
						return 1
					fi
				fi
			fi
		fi
	fi
fi
ph_set_result -m "An error occurred trying to remove line '${PH_LINE}' from file '${PH_FILE}'"
"$PH_SUDO" rm "$PH_TMP_FILE" 2>/dev/null
return 1
}

function ph_git_add_local {

declare PH_GIT_COMMIT_MSG=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts m: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in m)
		[[ -n "$PH_GIT_COMMIT_MSG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_GIT_COMMIT_MSG="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_GIT_COMMIT_MSG" || "$#" -ne "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Adding modified files to local git"
if [[ -z "$PH_GIT_COMMIT_MSG" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Empty commit message -> Skipping"
else
	if git add . >/dev/null 2>&1
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		ph_add_value_to_param -p PH_GIT_ADD_LOCAL -v "yes"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not add files"
	fi
fi
ph_set_result -r 0
cd - >/dev/null 2>&1
return 0
}

function ph_undo_git_add_local {

declare -i PH_RET_CODE="0"

cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Removing modified files from local git"
if git reset >/dev/null 2>&1
then
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not remove files"
	PH_RET_CODE="1"
fi
ph_set_result -r 0
cd - >/dev/null 2>&1
return "$PH_RET_CODE"
}

function ph_git_tag_local {

declare PH_OPTION=""
declare PH_NEW_VERSION=""
declare PH_GIT_COMMIT_MSG=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts v:m: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in v)
			PH_NEW_VERSION="$OPTARG" ;;
			     m)
			PH_GIT_COMMIT_MSG="$OPTARG" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_NEW_VERSION" ]] && return 1
cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Tagging local git build as '$PH_NEW_VERSION'"
if [[ -z "$PH_GIT_COMMIT_MSG" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Empty commit message -> Skipping"
else
	git tag -a "$PH_NEW_VERSION" -m "$PH_GIT_COMMIT_SG" >/dev/null 2>&1
	if [[ "$?" -eq "0" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		ph_add_value_to_param -p PH_GIT_TAG_LOCAL -v "yes"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not tag build"
	fi
fi
ph_set_result -r 0
cd - >/dev/null 2>&1
return 0
}
 
function ph_undo_git_commit_local {

declare -i PH_RET_CODE="0"

cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Undoing latest commit to local git"
if git reset --soft HEAD~1 >/dev/null 2>&1
then
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not undo commit"
	PH_RET_CODE="1"
fi
ph_set_result -r 0
cd - >/dev/null 2>&1
return "$PH_RET_CODE"
}

function ph_git_commit_local {

declare PH_OPTION=""
declare PH_NEW_VERSION=""
declare PH_GIT_COMMIT_MSG=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts m:v: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in m)
			PH_GIT_COMMIT_MSG="$OPTARG" ;;
			     v)
			PH_NEW_VERSION="$OPTARG" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_NEW_VERSION" ]] && return 1
cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Committing build '$PH_NEW_VERSION' to local git"
if [[ -z "$PH_GIT_COMMIT_MSG" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Empty commit message -> Skipping"
else
	if git commit -a --message="$PH_GIT_COMMSG" >/dev/null 2>&1
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		ph_add_value_to_param -p PH_GIT_COMMIT_LOCAL -v "yes"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not commit to local"
	fi
fi
cd - >/dev/null 2>&1
ph_set_result -r 0
return 0
}

function ph_git_local {

declare PH_OPTION=""
declare PH_NEW_VERSION=""
declare PH_GIT_COMMIT_MSG=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

PH_OLD_VERSION="$(git tag -l --points-at HEAD 2>/dev/null)"
PH_OLD_GIT_COMMIT_MSG="$(git log -1 --pretty=%B 2>/dev/null)"

OPTIND="1"

while getopts m:v: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in m)
			PH_GIT_COMMIT_MSG="$OPTARG" ;;
			     v)
			PH_NEW_VERSION="$OPTARG" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_NEW_VERSION" ]] && return 1
ph_run_with_rollback -c "ph_git_add_local -m \"$PH_GIT_COMMIT_MSG\"" || return 1
ph_run_with_rollback -c "ph_git_commit_local -v \"$PH_NEW_VERSION\" -m \"$PH_GIT_COMMIT_MSG\"" || return 1
ph_run_with_rollback -c "ph_git_tag_local -v \"$PH_NEW_VERSION\" -m \"$PH_GIT_COMMIT_MSG\"" || return 1
return 0
}

function ph_git_commit_master {

declare PH_OPTION=""
declare PH_NEW_VERSION=""
declare PH_GIT_COMMIT_MSG=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts v:m: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in v)
			PH_NEW_VERSION="$OPTARG" ;;
			     m)
			PH_GIT_COMMIT_MSG="$OPTARG" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_NEW_VERSION" ]] && return 1
cd "$PH_BASE_DIR" >/dev/null 2>&1
printf "%8s%s\n" "" "--> Committing build '$PH_NEW_VERSION' to git master"
if [[ -z "$PH_GIT_COMMIT_MSG" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Empty commit message -> Skipping"
else
	if git push --mirror >/dev/null 2>&1
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		ph_add_value_to_param -p PH_GIT_COMMIT_MASTER -v "yes"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not commit to master"
	fi
fi
ph_set_result -r 0
cd - >/dev/null 2>&1
return 0
}

function ph_git_master {

declare PH_OPTION=""
declare PH_NEW_VERSION=""
declare PH_GIT_COMMIT_MSG=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts v:m: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in v)
			PH_NEW_VERSION="$OPTARG" ;;
			     m)
			PH_GIT_COMMIT_MSG="$OPTARG" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_NEW_VERSION" ]] && return 1
ph_run_with_rollback -c "ph_git_commit_master -v \"$PH_NEW_VERSION\" -m \"$PH_GIT_COMMIT_MSG\"" || return 1
return 0
}

function ph_get_app_state_from_app_name {

declare PH_APP
declare PH_APP_STATE

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_STATE="$(ph_check_app_state_validity -a "$PH_APP" -q -f -u)"
echo -n "$PH_APP_STATE"
return 0
}

function ph_check_pieh_shared_config {

declare PH_i=""

for PH_i in Bash_conf Ctrls_conf Emulationstation_conf Kodi_conf Moonlight_conf MovefromPieHScript LoginScript MoveScript MovetoPieHScript OOSapp_conf PieHelper_conf RestartScriptPieH RestartScript StartScriptPieH StartScript StopScriptPieH StopScript X11_conf
do
	if ! ph_check_object_existence -q -o "${PH_TEMPLATES_DIR}/${PH_i}.template"
	then
		ph_show_result
		exit "$?"
        fi
done
for PH_i in GL X
do
	if ! ph_check_object_existence -q -o "${PH_FILES_DIR}/default_apps_${PH_i}"
	then
		ph_show_result
		exit "$?"
	fi
done
for PH_i in Advanced Controllers Main OS OSdefaults PS3 PS4 XBOX360 Settings
do
	if ! ph_check_object_existence -q -o "${PH_MENUS_DIR}/${PH_i}.lst"
        then
		ph_show_result
		exit "$?"
        fi
done
return 0
}

function ph_check_pieh_configured_config {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_GROUP=""
declare PH_APPU_CIFS_MPT=""
declare -u PH_APPU=""
declare -l PH_APPL=""
declare -i PH_RET_CODE="0"
declare -i PH_APP_TTY="0"

printf "%2s%s\n\n" "" "While PieHelper is configured :" >>"${PH_TMP_DIR}/reported_issues"
for PH_i in sup int cont os defaults alloweds
do
	ph_check_base_conf_file_validity "$PH_i" || \
		PH_RET_CODE="1"
done
if [[ ! -f /etc/profile.d/PieHelper-path.sh ]]
then
        printf "%4s%s\n" "" "- The PATH and LD_LIBRARY_PATH extension is missing" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
else
	PH_APP_USER="$(ph_get_app_user_from_app_name PieHelper)"
	if [[ -n "$PH_APP_USER" ]]
	then
		if [[ "$("$PH_SUDO" find /etc/profile.d/PieHelper-path.sh -exec ls -l {} \; 2>/dev/null | nawk '{ \
				print $3 \
			}')" != "root" ]]
		then
			printf "%4s%s\n" "" "- The PATH and LD_LIBRARY_PATH extension has a 'Corrupted' value for ownership -> Fix by running '${PH_SUDO} chown root:root /etc/profile.d/PieHelper-path.sh'" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		fi
	fi
fi
if [[ ! -L "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" && "$PH_DISTRO" == "Debian" ]]
then
        printf "%4s%s\n" "" "- ${PH_DISTRO} release symbolic link is 'Missing'" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
if [[ -f "$PH_FILES_DIR/auto_update_denied" ]]
then
        printf "%4s%s\n" "" "- Temporary file 'auto_update_denied' is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
if ! ph_check_object_existence -q -o "${PH_CONF_DIR}/Ctrls.conf"
then
        printf "%4s%s\n" "" "- Configuration file 'Ctrls.conf' is missing" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
for PH_APP in $(ph_get_app_list_by_state -s Supported -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	if ! ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_APP}.conf"
	then
       		printf "%4s%s\n" "" "- Supported application ${PH_APP} configuration file '${PH_APP}.conf' is missing" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
	for PH_i in "AppManagement_${PH_APP}" "OptsManagement_${PH_APP}" "TTYManagement_${PH_APP}" "$PH_APP"
	do
		if [[ ! -f "${PH_MENUS_DIR}/${PH_i}.lst" ]]
		then
       		 	printf "%4s%s\n" "" "- Integrated application ${PH_APP} menu item '${PH_i}.lst' is missing" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		fi
	done
	for PH_i in alloweds defaults
	do
		if ph_check_object_existence -q -o "${PH_CONF_DIR}/options.${PH_i}"
		then
			if ! grep -E "^PH_${PH_APPU}_" "${PH_CONF_DIR}/options.${PH_i}" >/dev/null 2>&1
			then
       				printf "%4s%s\n" "" "- Supported application ${PH_APP} ${PH_i%?} option values are missing" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
		fi
	done
done
for PH_i in $("$PH_SUDO" find "${PH_MNT_DIR}/*" -type d 2>/dev/null | nawk 'BEGIN { \
		ORS = " " \
	} { \
		print \
	}')
do
	PH_APP="${PH_i##*/}"
	if ! cut -f1 "${PH_CONF_DIR}/integrated_apps" 2>&1 | grep -E "^${PH_APP}$" >/dev/null
	then
        	printf "%4s%s\n" "" "- Default CIFS mountpoint '${PH_MNT_DIR}/${PH_APP}' is present while ${PH_APP} application state is not 'Integrated'" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
done
for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	PH_APPU_CIFS_MPT="$(eval "echo -n \"\$PH_${PH_APPU}_CIFS_MPT\"")"
	if ! cut -f1 "${PH_CONF_DIR}/supported_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
	then
        	printf "%4s%s\n" "" "- Integrated application ${PH_APP} is missing in configuration file '${PH_CONF_DIR}/supported_apps'" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
	if [[ ! -d "$(eval "echo -n \"${PH_APPU_CIFS_MPT}\"")" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application ${PH_APP} CIFS mountpoint '$(eval "echo -n \"${PH_APPU_CIFS_MPT}\"")' is missing" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
done
for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
do
	PH_APPL="${PH_APP:0:4}"
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
	if [[ ! -f "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application ${PH_APP} on 'tty${PH_APP_TTY}' LoginScript is missing" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
	if [[ ! -f "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application ${PH_APP} on 'tty${PH_APP_TTY}' autologin is missing" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
	for PH_i in $(nawk -v app="^${PH_APP}$" -v appl="${PH_APPL}" -v scriptsdir="${PH_SCRIPTS_DIR}" 'BEGIN { \
			ORS = " " \
		} \
		$1 !~ app { \
			appl2 = tolower(substr($1,1,4)) ; \
			print scriptsdir "/" appl "to" appl2 ".sh " scriptsdir "/" appl2 "to" appl ".sh " \
		} END { \
			print scriptsdir "/start" appl ".sh " scriptsdir "/stop" appl ".sh " scriptsdir "/restart" appl ".sh" \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
	do
		if [[ ! -f "${PH_i}" ]]
		then
        		printf "%4s%s\n" "" "- Integrated application ${PH_APP} management script '${PH_i}' is missing" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		else
			if [[ ! -x "${PH_i}" ]]
			then
        			printf "%4s%s\n" "" "- Integrated application ${PH_APP} management script '${PH_i}' is not executable -> Should be '0770'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
		fi
	done
done
for ((PH_APP_TTY=2;PH_APP_TTY<="${PH_PIEH_MAX_TTYS}";PH_APP_TTY++))
do
	PH_APP="$(ph_get_app_name_from_app_tty "$PH_APP_TTY")"
	PH_APPL="${PH_APP:0:4}"
	PH_APP_USER="$(ph_get_app_user_from_app_tty "$PH_APP_TTY")"
	if [[ -f "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" ]]
	then
		if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_TTY}$" >/dev/null
		then
			if [[ "$(ph_get_app_user_from_autologin "$PH_APP_TTY")" != "$PH_APP_USER" ]]
			then
        			printf "%4s%s\n" "" "- Autologin for 'tty${PH_APP_TTY}' has a corrupted value for PH_APP_USER -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
			if [[ "$PH_APP_TTY" -ne "$(ph_get_app_tty_from_autologin "$PH_APP_TTY")" ]]
			then
        			printf "%4s%s\n" "" "- Autologin for 'tty${PH_APP_TTY}' has a corrupted value for PH_APP_TTY -> Should be '${PH_APP_TTY}'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
		else
        		printf "%4s%s\n" "" "- Autologin configuration for 'tty${PH_APP_TTY}' is present while tty${PH_APP_TTY} is unallocated" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		fi
	fi
	if [[ -f "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" ]]
	then
		if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_TTY}$" >/dev/null
		then
			if [[ "$(ph_get_app_user_from_login_script_owner "$PH_APP_TTY")" != "$PH_APP_USER" ]]
			then
        			printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' has a corrupted value for ownership -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
			if [[ "$(ph_get_app_user_from_login_script "$PH_APP_TTY")" != "$PH_APP_USER" ]]
			then
        			printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' has a corrupted value for PH_APP_USER -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
			if [[ "$(ph_get_app_tty_from_login_script "$PH_APP_TTY")" -ne "$PH_APP_TTY" ]]
			then
        			printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' has a corrupted value for PH_APP_TTY -> Should be 'tty${PH_APP_TTY}'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
			if [[ "$(ph_get_app_name_from_login_script "$PH_APP_TTY")" != "$PH_APP" ]]
			then
        			printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' has a corrupted value for PH_APP_CMD -> Should be '${PH_SCRIPTS_DIR}/start${PH_APPL}.sh'" >>"${PH_TMP_DIR}/reported_issues"
				PH_RET_CODE="1"
			fi
		else
        		printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' is present while tty${PH_APP_TTY} is unallocated" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		fi
	fi
done
if [[ -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
	PH_APP_TTY="$(nawk '$0 ~ /^ExecStartPost=\+\/bin\/chvt/ { \
			printf $2 \
		}' /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null)"
	PH_APP="$(ph_get_app_name_from_app_tty "$PH_APP_TTY")"
	if [[ "$PH_PIEH_STARTAPP" == "none" ]]
	then
        	printf "%4s%s\n" "" "- 'tty1' StartApp configuration is present while PH_PIEH_STARTAPP is set to 'none'" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	else
		if [[ "$PH_PIEH_STARTAPP" != "$PH_APP" ]]
		then
        		printf "%4s%s\n" "" "- 'tty1' StartApp configuration is for ${PH_APP} while PH_PIEH_STARTAPP is set to '${PH_PIEH_STARTAPP}'" >>"${PH_TMP_DIR}/reported_issues"
			PH_RET_CODE="1"
		fi
	fi
else
	if [[ "$PH_PIEH_STARTAPP" != "none" ]]
	then
        	printf "%4s%s\n" "" "- PH_PIEH_STARTAPP is set to '${PH_PIEH_STARTAPP}' while 'tty1' StartApp configuration is missing" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
fi
if [[ "$PH_RET_CODE" -ne "0" ]]
then
	if [[ -f "${PH_TMP_DIR}/.first_run" ]]
	then
		printf "%4s%s\n" "" "- File '${PH_TMP_DIR}/.first_run' is present" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
else
	"$PH_SUDO" rm "${PH_TMP_DIR}/reported_issues" 2>/dev/null
fi
return "$PH_RET_CODE"
}

function ph_check_base_conf_file_validity {

declare PH_i="$1"
declare PH_APP=""
declare PH_FILE=""

PH_FILE="$(ph_get_filename_from_shortname "$PH_i")"
if ! ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_FILE}"
then
	printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is missing" >>"${PH_TMP_DIR}/reported_issues"
	return 1
fi
if [[ "$PH_i" == @(sup|int) ]]
then
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if [[ "$(nawk -v app="^${PH_APP}$"$ 'BEGIN { \
				count = "0" \
			} \
			$1 ~ app { \
				count++ \
			} END { \
				printf count \
			}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)" -gt "1" ]]
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is corrupted -> Multiple instances of '${PH_APP}'" >>"${PH_TMP_DIR}/reported_issues"
			return 1
		fi
	done
fi
case "$PH_i" in cont)
	: ;;
		os)
	: ;;
		defaults)
	: ;;
		alloweds)
	: ;;
		sup)
	if ! ph_check_app_state_validity -a PieHelper -q -s
	then
        	printf "%4s%s\n" "" "- PieHelper is not a supported application" >>"${PH_TMP_DIR}/reported_issues"
		return 1
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if ! ph_check_app_support_data_validity "$PH_APP"
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' has corrupted data for ${PH_APP}" >>"${PH_TMP_DIR}/reported_issues"
			return 1
		fi
	done ;;
		int)
	if ! ph_check_app_state_validity -a PieHelper -q -i
	then
        	printf "%4s%s\n" "" "- PieHelper is not an integrated application" >>"${PH_TMP_DIR}/reported_issues"
		return 1
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if ! ph_check_app_integration_data_validity "$PH_APP"
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' has corrupted data for ${PH_APP}" >>"${PH_TMP_DIR}/reported_issues"
			return 1
		fi
	done ;;
esac
## add syntax check for OS.defaults, controller_cli_ids and both option files
return 0
}

function ph_check_pieh_unconfigured_config {

declare PH_i=""
declare PH_APP=""
declare PH_FILE=""
declare -i PH_RET_CODE="0"
declare -i PH_APP_TTY="0"

printf "%2s%s\n\n" "" "While PieHelper is unconfigured :" >>"${PH_TMP_DIR}/reported_issues"
for PH_i in sup int cont os defaults alloweds
do
	ph_check_default_base_conf_file_validity "$PH_i" || \
		PH_RET_CODE="1"
done
if [[ -f /etc/profile.d/PieHelper-path.sh ]]
then
        printf "%4s%s\n" "" "- The PATH and LD_LIBRARY_PATH extension is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
if [[ "$PH_DISTRO" == "Debian" ]]
then
	if ph_check_object_existence -q -o "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf"
	then
		printf "%4s%s\n" "" "- ${PH_DISTRO} release symbolic link is present" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
fi
for PH_i in Ctrls $(ph_get_app_list_by_state -s Default -t minimum)
do
	if ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_i}.conf"
	then
		printf "%4s%s\n" "" "- Configuration file '${PH_CONF_DIR}/${PH_i}.conf' is present" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
	fi
done
for PH_i in $(ls "${PH_MENUS_DIR}/"!(@(Advanced|XBOX360|PS@(3|4)|OS|OSdefaults|Settings|Controllers|Main).lst) 2>/dev/null | \
	nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print $1 \
	}')
do
       	printf "%4s%s\n" "" "- Menu item '${PH_i##*/}' is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
done
for PH_i in $("$PH_SUDO" find "${PH_MNT_DIR}/*" -type d -mount 2>/dev/null | nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print \
	}')
do
	PH_APP="${PH_i##*/}"
       	printf "%4s%s\n" "" "- Default CIFS mountpoint '${PH_MNT_DIR}/${PH_APP}' is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
done
for PH_i in $(find "${PH_SCRIPTS_DIR}" -maxdepth 1 -type f -regextype egrep ! -regex ".*/(start|stop|restart|.*_ph).*\.sh" -print 2>/dev/null | nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print $1 \
	}')
do
       	printf "%4s%s\n" "" "- Management script '${PH_i##*/}' is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
done
for ((PH_APP_TTY=2;PH_APP_TTY<="${PH_PIEH_MAX_TTYS}";PH_APP_TTY++))
do
        if [[ -f "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" ]]
        then
                printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' is present" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
        fi
        if [[ -f "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" ]]
        then
                printf "%4s%s\n" "" "- Autologin configuration for 'tty${PH_APP_TTY}' is present" >>"${PH_TMP_DIR}/reported_issues"
		PH_RET_CODE="1"
        fi
done
if [[ -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
        printf "%4s%s\n" "" "- StartApp configuration for 'tty1' is present" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
if [[ ! -f "${PH_TMP_DIR}/.first_run" ]]
then
	printf "%4s%s\n" "" "- Temporary file '${PH_TMP_DIR}/.first_run' is missing" >>"${PH_TMP_DIR}/reported_issues"
	PH_RET_CODE="1"
fi
[[ "$PH_RET_CODE" -eq "0" ]] && \
	"$PH_SUDO" rm "${PH_TMP_DIR}/reported_issues" 2>/dev/null
return "$PH_RET_CODE"
}

function ph_show_app_info {

declare PH_APP="$1"
declare PH_APP_USER=""
declare PH_APP_CMD=""
declare PH_APP_PKG=""
declare PH_APP_STATE=""
declare PH_APP_INST_STATE=""
declare -i PH_APP_TTY="0"
declare -u PH_APPU="${PH_APP:0:4}"
declare -n PH_APP_PERSISTENCE="PH_${PH_APPU}_PERSISTENT"

PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
[[ -z "$PH_APP_USER" ]] && \
	PH_APP_USER="-"
PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
[[ -z "$PH_APP_PKG" ]] && \
	PH_APP_PKG="-"
PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
printf "\n%10s%-20s%s\n" "" "App name" ": ${PH_APP}"
if [[ "$PH_APP_TTY" -eq "0" ]]
then
	printf "%10s%-20s%s\n" "" "App TTY" ": -"
else
	printf "%10s%-20s%s\n" "" "App TTY" ": ${PH_APP_TTY}"
fi
printf "%10s%-20s%s\n" "" "App run account" ": ${PH_APP_USER}"
printf "%10s%-20s%s\n" "" "App start command" ": ${PH_APP_CMD}"
printf "%10s%-20s%s\n" "" "App state" ": ${PH_APP_STATE}"
printf "%10s%-20s%s\n" "" "App package name" ": ${PH_APP_PKG}"
printf "%10s%-20s%s\n" "" "App install state" ": ${PH_APP_INST_STATE}"
printf "%10s%-20s%s\n" "" "App persistence" ": $(echo -n "$PH_APP_PERSISTENCE" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo -n "$PH_APP_PERSISTENCE" | cut -c2-)"
if [[ "$PH_APP" == "PieHelper" && \
	"$(pgrep -f "^/bin/bash ${PH_SCRIPTS_DIR}/startpieh.sh.*-p$|${PH_SCRIPTS_DIR}/startpieh.sh[[:space:]]*-p[[:space:]].*$" >/dev/null 2>&1 ; echo "$?")" -eq "0" ]]
then
	PH_APP_STATE="Yes"
else
	PH_APP_STATE="No"
fi
printf "%10s%-20s%s\n" "" "Active on pts" ": ${PH_APP_STATE}"
unset -n PH_APP_PERSISTENCE
return 0
}

function ph_allocate_new_tty {

declare PH_APP="$1"
declare -i PH_APP_TTY="0"

[[ -z "$PH_APP" ]] && \
	echo -n "1" && \
	return 1

printf "%8s%s\n" "" "--> Allocating the first free tty to ${PH_APP}"
if [[ "$PH_APP" == "PieHelper" ]]
then
	PH_APP_TTY="2"
	ph_run_with_rollback -c true -m "tty${PH_APP_TTY}"
else
	for ((PH_APP_TTY=3;PH_APP_TTY<="$((PH_PIEH_MAX_TTYS+1))";PH_APP_TTY++))
	do
		if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_TTY}$" >/dev/null
		then
			continue
		fi
		break
	done
	if [[ "$PH_APP_TTY" -eq "$(("$PH_PIEH_MAX_TTYS"+1))" ]]
	then
		ph_set_result -m "Could not allocate a tty to ${PH_APP} since the maximum number of $((PH_PIEH_MAX_TTYS-1)) ttys has been allocated"
		ph_run_with_rollback -c false -m "Could not allocate" || \
			return 1
	else
		ph_run_with_rollback -c true -m "tty${PH_APP_TTY}"
	fi
fi
return "$PH_APP_TTY"
}

function ph_check_object_existence {

declare PH_DIR=""
declare PH_FILE=""
declare PH_TYPE="Derivate"
declare PH_OBJECT=""
declare PH_OBJECT_TYPE="configuration file"
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RET_CODE="0"
declare -i PH_QUIESCE="1"

OPTIND="1"

while getopts o:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in o)
		[[ -n "$PH_OBJECT" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_OBJECT="$OPTARG" ;;
			     q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_QUIESCE="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_OBJECT" || "$#" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_DIR="${PH_OBJECT%/*}"
PH_FILE="${PH_OBJECT##*/}"
if [[ -d "$PH_OBJECT" ]]
then
	PH_OBJECT_TYPE="directory"
	PH_TYPE="Unique"
else
       	case "$PH_OBJECT" in sup)
		PH_DIR="$PH_CONF_DIR"
		PH_FILE="supported_apps" ;;
			cont)
		PH_DIR="$PH_CONF_DIR"
		PH_FILE="controller_cli_ids" ;;
			*/default_apps_*)
		PH_DIR="$PH_FILES_DIR"
		PH_TYPE="Unique"
		PH_FILE="default_apps_${PH_OBJECT##*_}" ;;
			int)
		PH_DIR="$PH_CONF_DIR"
		PH_FILE="integrated_apps" ;;
			os)
		PH_DIR="$PH_CONF_DIR"
		PH_FILE="OS.defaults" ;;
			defaults|alloweds)
		PH_DIR="$PH_CONF_DIR"
		PH_FILE="options.${PH_OBJECT}" ;;
			*/VERSION)
		PH_TYPE="Unique" ;;
			`echo -n "${PH_CHECK_SUPPORTED[@]}" | nawk '{ for (i=1;i<=NF;i++) { printf "%s%s", "*/" $i, ".*" ; if (i<NF) { printf "|" }}}'`)
		PH_TYPE="Unique" ;;
			`echo -n "${PH_SUPPORTED_DISTROS[@]}" | nawk '{ for (i=1;i<=NF;i++) { printf "%s%s", "*/" $i, ".conf" ; if (i<NF) { printf "|" }}}'`)
		[[ "$(declare -p "PH_SUPPORTED_$(echo "$(sed 's/\.conf//'<<<"${PH_OBJECT//"${PH_CONF_DIR}/distros/"/}_RELS")" | \
			tr "[:lower:]" "[:upper:]")" 2>/dev/null)" == "declare -ax"* ]] && \
			PH_OBJECT_TYPE="link" ;;
			*.conf)
		: ;;
			*/PieHelper.lst|*/OptsManagement_PieHelper.lst|*/AppManagement_PieHelper.lst|*/TTYManagement_PieHelper.lst)
		PH_OBJECT_TYPE="menu item"
		PH_TYPE="Unique" ;;
			*/TTYManagement.lst|*/OptsManagement.lst|*/AppManagement.lst)
		PH_OBJECT_TYPE="link" ;;
			*.lst)
		PH_OBJECT_TYPE="menu item" ;;
			*.sh)
		PH_OBJECT_TYPE="management script" ;;
			*.template)
		PH_OBJECT_TYPE="template"
		PH_TYPE="Unique" ;;
			*/auto_update_denied|*/.first_run)
		PH_OBJECT_TYPE="file"
		PH_TYPE="Optional" ;;
			*.expect)
		PH_OBJECT_TYPE="expect script"
		PH_TYPE="Unique" ;;
			*/functions*)
		PH_OBJECT_TYPE="codebase file"
		PH_TYPE="Unique" ;;
			*)
		PH_OBJECT_TYPE="file"
		PH_TYPE="Optional" ;;
       	esac
fi
[[ "$PH_QUIESCE" -eq "1" ]] && \
	printf "%8s%s\n" "" "--> Checking '${PH_TYPE}' ${PH_OBJECT_TYPE} '${PH_DIR}/${PH_FILE}'"
if [[ ! ( -f "${PH_DIR}/${PH_FILE}" && "$PH_OBJECT_TYPE" != @(directory|link) ) && \
	! ( -d "${PH_DIR}/${PH_FILE}" && "$PH_OBJECT_TYPE" == "directory" ) && \
	! ( -L "${PH_DIR}/${PH_FILE}" && "$PH_OBJECT_TYPE" == "link" ) ]]
then
	if [[ "$PH_TYPE" == "Unique" ]]
	then
		ph_set_result -a -m "${PH_TYPE} ${PH_OBJECT_TYPE} '${PH_DIR}/${PH_FILE}' is missing -> Reinstallation and reconfiguration of PieHelper is required"
	else
		if [[ "$PH_QUIESCE" -eq "1" ]]
		then
			printf "%10s\033[33m%s\033[0m\n\n" "" "Warning : Not found"
			ph_set_result -r 0
		fi
	fi
	return 1
else
	if [[ "$PH_QUIESCE" -eq "1" ]]
	then
		ph_run_with_rollback -c true -m "Found"
	fi
fi
return 0
}

function ph_check_default_base_conf_file_validity {

declare PH_i="$1"
declare PH_FILE=""

PH_FILE="$(ph_get_filename_from_shortname "$PH_i")"
if ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_FILE}"
then
	printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is present" >>"${PH_TMP_DIR}/reported_issues"
	return 1
fi
return 0
}

function ph_stop_all_running_apps {

declare PH_APPS_TO_STOP="$*"
declare PH_APP=""
declare PH_STOPPED_APPS=""
declare PH_APP_CMD=""
declare -l PH_APPL=""
declare -i PH_APP_TTY="0"

if [[ -z "$PH_APPS_TO_STOP" ]]
then
	PH_APPS_TO_STOP="$(confapps_ph.sh -p list -l run | nawk 'BEGIN { apps =  "" ; FS = "\x27" ; ORS =  " " } $0 ~ /Packaged/ || $0 ~ /Packageless/ { printf $2 ; next } { next }')"
else
	for PH_APP in $(echo -n "$PH_APPS_TO_STOP")
	do
		if [[ "$(ph_get_app_state_from_app_name "$PH_APP")" != "Running" ]]	
		then
			PH_APPS_TO_STOP="$(sed "s/^$PH_APP$//g;s/^$PH_APP //g;s/ $PH_APP / /g;s/ $PH_APP$//g" <<<"$PH_APPS_TO_STOP")"
		fi
	done
fi
for PH_APP in $(echo -n "$PH_APPS_TO_STOP")
do
	PH_APPL="${PH_APP:0:4}"
	PH_APP_CMD="/bin/bash $PH_SCRIPTS_DIR/start$PH_APPL.sh"
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
	if pgrep -t tty"$PH_APP_TTY" -f ^"$PH_APP_CMD" >/dev/null 2>&1
	then
		ph_do_app_action stop "$PH_APP" force || return 1
	else
		if [[ "$PH_APP" == "PieHelper" ]] && (pgrep -f ^"/bin/bash ${PH_SCRIPTS_DIR}/startpieh.sh.*-p$|${PH_SCRIPTS_DIR}/startpieh.sh[[:space:]]*-p[[:space:]].*$" >/dev/null 2>&1)
		then
			printf "%8s%s\n" "" "--> Stopping 'PieHelper' on a pseudo-terminal"
			if "$PH_SUDO" kill -9 "$(pgrep -f ^"/bin/bash ${PH_SCRIPTS_DIR}/startpieh.sh.*-p$|${PH_SCRIPTS_DIR}/startpieh.sh[[:space:]]*-p[[:space:]].*$" 2>/dev/null)"
			then
				ph_run_with_rollback -c "true"
			else
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not stop application"
				ph_set_result -r 1 -m "An error occurred stopping '$PH_APP' on a pseudo-terminal"
				return 1
			fi
		fi
	fi
done
return 0
}

function ph_git_clone_master {

declare PH_GIT_REPO_DIR=""
declare PH_GIT_REPO_NAME=""
declare PH_GIT_REPO_ARGS=""
declare PH_GIT_REPO=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts d:r:n:a: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in d)
			[[ -n "$PH_GIT_REPO_DIR" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO_DIR="$OPTARG" ;;
			     n)
			[[ -n "$PH_GIT_REPO_NAME" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO_NAME="$OPTARG" ;;
			     a)
			PH_GIT_REPO_ARGS="$OPTARG" ;;
			     r)
			[[ -n "$PH_GIT_REPO" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO="$OPTARG" ;;
			     *)
			OPTIND="$PH_OLDOPTIND"
			OPTARG="$PH_OLDOPTARG"
			ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_GIT_REPO_DIR" || -z "$PH_GIT_REPO" || -z "$PH_GIT_REPO_NAME" ]] && \
	return 1

if [[ ! -d "$PH_GIT_REPO_DIR" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -t directory -d '${PH_GIT_REPO_DIR}'" || \
		return 1
fi
printf "%8s%s\n" "" "--> Cloning github repository '${PH_GIT_REPO}'"
if cd "$PH_GIT_REPO_DIR" >/dev/null 2>&1
then
	if git clone ${PH_GIT_REPO_ARGS} "$PH_GIT_REPO" >/dev/null 2>&1
	then
		cd - >/dev/null 2>&1
		ph_add_value_to_param -p PH_GIT_UNDO_CLONE_MASTER -v "${PH_GIT_REPO_DIR}'${PH_GIT_REPO}'${PH_GIT_REPO_NAME}'${PH_GIT_REPO_ARGS}"
		ph_run_with_rollback -c true && \
			return 0
	else
		ph_set_result -m "Could not clone git repository '${PH_GIT_REPO}'"
	fi
else
	ph_set_result -m "Could not change working directory to '${GIT_REPO_DIR}'"
fi
cd - >/dev/null 2>&1
printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Could not clone"
ph_run_with_rollback -c false || \
	return 1
}

function ph_git_undo_clone_master {

declare PH_GIT_REPO=""
declare PH_GIT_REPO_ARGS=""
declare PH_GIT_REPO_DIR=""
declare PH_GIT_REPO_NAME=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts d:n:r:a: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in d)
			[[ -n "$PH_GIT_REPO_DIR" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO_DIR="$OPTARG" ;;
			     r)
			[[ -n "$PH_GIT_REPO" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO="$OPTARG" ;;
			     a)
			PH_GIT_REPO_ARGS="$OPTARG" ;;
			     n)
			[[ -n "$PH_GIT_REPO_NAME" ]] && \
				OPTIND="$PH_OLDOPTIND" && \
				OPTARG="$PH_OLDOPTARG" && \
				return 1
			PH_GIT_REPO_NAME="$OPTARG" ;;
			     *)
			OPTIND="$PH_OLDOPTIND"
			OPTARG="$PH_OLDOPTARG"
			ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_GIT_REPO_DIR" || -z "$PH_GIT_REPO" || -z "$PH_GIT_REPO_NAME" || \
	( -e "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" && ! -d "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" ) ]] && \
	return 1

printf "%8s%s\n" "" "--> Removing cloned repository '${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}'"
if [[ ! -e "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" ]]
then
	printf "%10s\033[32m%s\033[0m%s\n" "" "OK : " "Nothing to do"
	ph_set_result -r 0
	return 0
else
	if "$PH_SUDO" rm -r "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" 2>/dev/null
	then
		ph_add_value_to_param -p PH_GIT_CLONE_MASTER -v "${PH_GIT_REPO_DIR}'${PH_GIT_REPO}'${PH_GIT_REPO_NAME}'${PH_GIT_REPO_ARGS}"
		ph_run_with_rollback -c true && \
			return "$?"
	else
		ph_set_result -m "Could not remove directory '${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}'"
	fi
fi
printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Could not remove"
ph_run_with_rollback -c false || \
	return 1
}

function ph_update_app {

declare PH_APP=""
declare PH_APP_PKG=""
declare PH_APP_STATE=""
declare PH_OPTION=""
declare PH_UPDATE_DIR="/tmp/update"
declare PH_NEW_DIRS=""
declare PH_NEW_VERSION=""
declare PH_i=""
declare PH_j=""
declare PH_VALUE=""
declare PH_OPT=""
declare PH_ANSWER=""
declare PH_APP_CMD=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -i PH_RET_CODE="0"
declare -i PH_APP_TTY="0"
declare -l PH_APPL=""

OPTIND="1"

while getopts a: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
                PH_APP="$OPTARG" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "PieHelper" ]]
then
	ph_run_with_rollback -c "ph_git_clone_master -d '${PH_UPDATE_DIR}' -n PieHelper -r 'https://github.com/dkeppens/PieHelper.git'" || \
		return 1
	printf "%8s%s\n" "" "--> Checking for available PieHelper updates"
	PH_NEW_VERSION="$(cat "${PH_UPDATE_DIR}/PieHelper${PH_CONF_DIR##*PieHelper}/VERSION" 2>/dev/null)"
	if [[ "$PH_VERSION" == "$PH_NEW_VERSION" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (No available updates)"
		ph_run_with_rollback -l -c "ph_undo_git_clone_master -d '${PH_UPDATE_DIR}' -n PieHelper -r 'https://github.com/dkeppens/PieHelper.git'"
		return "$?"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Found update '${PH_NEW_VERSION}')"
	fi
	printf "%8s%s\n" "" "--> Checking if auto_update is allowed"
	if ph_check_object_existence -q -o "${PH_UPDATE_DIR}/PieHelper${PH_FILES_DIR##*PieHelper}/auto_update_denied"
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No"
		printf "%8s%s\n\n" "" "--> Displaying reminder for manual updates"
		printf "%12s%s\n" "" "- Version '$PH_NEW_VERSION' has major changes and is denying automatic update"
		printf "%l2s%s\n" "" "- To obtain the new version :"
		printf "%l4s%s\n" "" "* Quit PieHelper to a shell prompt"
		printf "%14s%s\n" "" "* Unconfigure and uninstall PieHelper by running 'confpieh_ph.sh -r' (Your system will reboot)"
		printf "%14s%s\n" "" "* Install and configure the new version according to the WIKI procedure at 'https://github.com/dkeppens/PieHelper/wiki/Install-instructions'"
		printf "%l2s%s\n\n" "" "- User settings will need to be reconfigured"
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		printf "%8s%s\n" "" "--> Cleaning up"
		"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		printf "%2s\033[32m%s\033[0m\n\n" "" "SUCCESS"
		return 0
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n\n" "" "--> Listing new changes since last update"
		nawk -v oldver="^VERSION ${PH_VERSION} -" -v newver="^VERSION ${PH_NEW_VERSION} -" 'BEGIN {
				flag = 0
			}
			$0 ~ oldver {
				getline ;
				while ($0 !~ /^VERSION /) {
					getline
				} ;
				flag = 1 ;
				print ;
				next
			}	
			$0 ~ newver {
				print $0 ;
				getline ;
				while ($0 !~ /^VERSION /) {
					print ;
					if (getline<=0) {
						exit 0
					}
				}
			} {
				if (flag==1) {
					print ;
					 next
				} else {
					next
				}
			}' "${PH_UPDATE_DIR}/PieHelper${PH_FILES_DIR##*PieHelper}/VERSIONS" 2>/dev/null | more
		printf "\n\033[36m%s\033[0m\n\n" "Important : - Updating will stop all running applications"
		while [[ "$PH_ANSWER" != @(y|n) ]]
		do
			[[ "$PH_COUNT" -ne "0" ]] && printf "\n%10s\033[31m%s\033[0m\n\n" "" "ERROR : Invalid response"
			printf "%8s%s" "" "--> Update now (y/n) ? "
			read PH_ANSWER 2>/dev/null
			ph_set_result -r 0
			if [[ "$PH_ANSWER" == "n" ]]
			then
				printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
				ph_set_result -w -m "Quit at user request"
				"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
				ph_show_result
				return "$?"
			fi
			((PH_COUNT++))
		done
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} \
		$1 !~ /^PieHelper$/ && $3 !~ /^-$/ { \
			print $1 \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
	do
		printf "%8s%s\n" "" "--> Checking ${PH_APP} application state"
		PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
		PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
		PH_APP_CMD="$(sed "s/#PH_TTY#/${PH_APP_TTY}/g" <<<"$PH_APP_CMD")"
		[[ "$PH_APP" == "Bash" ]] && \
			PH_APP_CMD="bash"
		if pgrep -t "tty${PH_APP_TTY}" -f "$PH_APP_CMD" >/dev/null
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : ${PH_APP} is running on it's allocated TTY -> Stopping"
			if ! ph_do_app_action stop "$PH_APP" force
			then
				printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
				"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
				return 1
			fi
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Not 'Running')"
		fi
	done
	ph_run_with_rollback -c "ph_store_all_options"
	printf "%8s%s\n" "" "--> Updating directory structure"
	for PH_i in $(find "$PH_UPDATE_DIR" -type d 2>/dev/null)
	do
		if [[ ! -d "${PH_BASE_DIR}/${PH_i##*/update}" && "${PH_BASE_DIR}/${PH_i##*/update}" != "${PH_BASE_DIR}/PieHelper/mnt/"* ]]
		then
			mkdir -p "${PH_BASE_DIR}/${PH_i##*/update}" 2>/dev/null
			[[ -z "$PH_NEW_DIRS" ]] && \
				PH_NEW_DIRS="${PH_i##*/update}/" || \
				PH_NEW_DIRS="${PH_NEW_DIRS} ${PH_i##*/update}/"
		fi
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' and optional non-codebase files"
	for PH_i in /PieHelper/ /PieHelper${PH_MNT_DIR##*PieHelper}/ /PieHelper${PH_TMP_DIR##*PieHelper}/ /PieHelper${PH_BUILD_DIR##*PieHelper}/ \
		/PieHelper${PH_SNAPSHOT_DIR##*PieHelper}/ /PieHelper${PH_CONF_DIR##*PieHelper}/ /PieHelper${PH_CONF_DIR##*PieHelper}/distros/ \
		/PieHelper${PH_FILES_DIR##*PieHelper}/ /PieHelper${PH_TEMPLATES_DIR##*PieHelper}/ /PieHelper${PH_EXCLUDES_DIR##*PieHelper}/ \
		/PieHelper${PH_MENUS_DIR##*PieHelper}/
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_UPDATE_DIR}${PH_i}${PH_j}" || \
				"${PH_j}" == @(*!(PieHelper).lst|*.conf|@(integrated|supported)_apps|OS.defaults|controller_cli_ids|options.@(allowed|default)s) ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j##*/}" 2>/dev/null
		done
	done
	for PH_i in $(echo -n "$PH_NEW_DIRS")
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_BASE_DIR}${PH_i}${PH_j}" ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j}" 2>/dev/null
		done
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' codebase files"
	for PH_i in /PieHelper${PH_SCRIPTS_DIR##*PieHelper}/app/pre_cmds/ /PieHelper${PH_SCRIPTS_DIR##*PieHelper}/app/post_cmds/ \
		/PieHelper${PH_MAIN_DIR##*PieHelper}/ /PieHelper${PH_MAIN_DIR##*PieHelper}/distros/ /PieHelper${PH_SCRIPTS_DIR##*PieHelper}/app/expect/
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_UPDATE_DIR}${PH_i}${PH_j}" || "$PH_i" == functions.user ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j}" 2>/dev/null
		done
	done
	printf "%8s%s\n" "" "--> Updating 'Unique' config files"
	cp -p "${PH_UPDATE_DIR}/PieHelper${PH_CONF_DIR##*PieHelper}/distros/"*.conf "${PH_CONF_DIR}/distros/" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' management scripts"
	for PH_i in $(ls "${PH_UPDATE_DIR}/PieHelper${PH_SCRIPTS_DIR##*PieHelper}/"+(conf|list)*.sh 2>/dev/null)
	do
		cp -p "${PH_UPDATE_DIR}/PieHelper${PH_SCRIPTS_DIR##*PieHelper}/${PH_i}" "${PH_SCRIPTS_DIR}/${PH_i}" 2>/dev/null
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' menus"
	for PH_i in $(ls "${PH_UPDATE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/" 2>/dev/null)
	do
		[[ -d "${PH_BASE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/${PH_i}" ]] && \
			continue
		if [[ "$PH_i" != @(OptsManagement.lst|TTYManagement.lst|AppManagement.lst|$(nawk 'BEGIN { \
				ORS = "|" \
			} \
			$1 !~ /^PieHelper$/ { \
				print $1 ".lst|" "OptsManagement_" $1 ".lst|" "TTYManagement_" $1 ".lst|" "AppManagement_" $1 ".lst" \
			}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)) ]]
		then
			cp -p "${PH_UPDATE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/${PH_i}" "${PH_MENUS_DIR}/${PH_i}" 2>/dev/null
		fi
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Sourcing new 'Shared' codebase"
	source "${PH_MAIN_DIR}/functions.update" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	for PH_APP in $(ph_get_app_list_by_state -s Supported -t minimum)
	do
		ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t support" || \
			return 1
	done
	ph_run_with_rollback -c "ph_retrieve_stored_options" || \
		return 1
	for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
	do
		ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t integrate" || \
			return 1
	done
	ph_secure_pieh -t delayed
	printf "%8s%s\n" "" "--> Cleaning up"
	"$PH_SUDO" rm -r /${PH_UPDATE_DIR}/PieHelper 2>/dev/null
	"$PH_SUDO" rm "${PH_TMP_DIR}/.first_run" 2>/dev/null
	"$PH_SUDO" rm "${PH_FILES_DIR}/auto_update_denied" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n\n" "" "OK"
	printf "%s\n" "Restart PieHelper manually to finalize updating to version '${PH_NEW_VERSION}'"
	printf "%s\n" "Press 'Enter' to quit"
	read 2>/dev/null
	ph_quit_pieh
else
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
	printf "%8s%s\n" "" "--> Checking ${PH_APP} application state"
	if [[ "$(ph_get_app_inst_state_from_app_name "$PH_APP")" == "PI" ]]
	then
		case "$PH_APP_STATE" in Running)
				ph_set_result -r 1
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not update package '${PH_APP_PKG}' while ${PH_APP} state is '${PH_APP_STATE}'" ;;
					*)
				ph_set_result -r 0
				printf "%10s\033[32m%s\033[0m\n" "" "OK"
				ph_update_pkg "$PH_APP_PKG"
				ph_set_result -r "$?" ;;
		esac
	else
		ph_set_result -r 1
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Updating requires installation state 'PI'"
	fi
fi
[[ "$PH_RESULT" != @(SUCCESS|Warning) ]] && \
	return 1
if [[ "$PH_FILE_SUFFIX" == "_GL" && "$PH_APP" == "Kodi" && "$PH_APP_TTY" -gt "1" ]]
then
	ph_modify_app_script -a "$PH_APP" -t "$PH_APP_TTY" || \
		return 1
fi
return 0
}

function ph_check_user_validity {

declare PH_APP_USER=""

PH_APP_USER="$1"

[[ "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ! echo "$PH_APP_USER" | grep -E "^[a-z_][a-z0-9_-]*[$]?$" >/dev/null
then
	ph_set_result -a -m "Usernames must be alphanumeric and can optionally contain only dash and underscore characters as well as a trailing dollar sign"
else
	if ! "$PH_SUDO" id "$PH_APP_USER" >/dev/null 2>&1
	then
		return 1
	fi
fi
return 0
}

function ph_get_app_tty_from_app_name {

declare PH_APP
declare PH_APP_STR_TTY

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ! PH_APP_STR_TTY="$(nawk -v app="^${PH_APP}$" -v max="$PH_PIEH_MAX_TTYS" '$1 ~ app { \
			if ($2 ~ /^-$/ || ($2 <= max && $2 > 1)) { \
				printf $2 ; \
				exit 0 \
			} else { \
				printf "%s", "1" ; \
				exit 1 \
			} \
		} \
	} { \
		next \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
then
	PH_APP_STR_TTY="1"
fi
echo -n "$PH_APP_STR_TTY"
[[ "$PH_APP_STR_TTY" -eq "1" ]] && \
	return 1
return 0
}

function ph_restore_file {

declare PH_FILE=""
declare PH_PARAMS=""
declare PH_TMP_FILE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RESTORE_AS_ROOT="1"

OPTIND="1"

while getopts f:rc PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in f)
		[[ -n "$PH_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG"
		PH_TMP_FILE="$("$PH_SUDO" ls -lAt "${PH_TMP_DIR}/$(echo -n "${PH_FILE##*/}" | sed 's/\./_/g')_tmp"* 2>/dev/null | nawk '{ \
				print ; \
				exit \
			}')" ;;
			     r)
		[[ "$PH_RESTORE_AS_ROOT" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_RESTORE_AS_ROOT="0" ;;
			     c)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-c" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-c" || \
			PH_PARAMS="${PH_PARAMS} -c" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || "$#" -lt "2" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_RESTORE_AS_ROOT" -eq "0" ]]
then
	"$PH_SUDO" mv "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
else
	mv "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
fi
if [[ "$?" -eq "0" ]]
then
	ph_add_value_to_param -p PH_STORE_FILES -v "${PH_FILE}'${PH_PARAMS}"
	return 0
fi
ph_set_result -m "An error occurred trying to restore '${PH_TMP_FILE}' as '${PH_FILE}'"
return 1
}


function ph_store_file {

declare PH_FILE=""
declare PH_PARAMS=""
declare PH_TMP_FILE=""
declare PH_COMMAND=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_STORE_AS_ROOT="1"

OPTIND="1"

while getopts f:rc PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in f)
		[[ -n "$PH_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG"
		PH_TMP_FILE="${PH_TMP_DIR}/$(echo -n "${PH_FILE##*/}" | sed 's/\./_/g')_tmp.$(date +'%s%N')" ;;
			     c)
		[[ -n "$PH_COMMAND" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-c" || \
			PH_PARAMS="${PH_PARAMS} -c"
		PH_COMMAND="cp -p" ;;
			     r)
		[[ "$PH_STORE_AS_ROOT" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_STORE_AS_ROOT="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || "$#" -lt "2" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_COMMAND" ]] && \
	PH_COMMAND="mv"
if [[ "$PH_STORE_AS_ROOT" -eq "0" ]]
then
	"$PH_SUDO" ${PH_COMMAND} "$PH_FILE" "$PH_TMP_FILE" 2>/dev/null
else
	${PH_COMMAND} "$PH_FILE" "$PH_TMP_FILE" 2>/dev/null
fi
if [[ "$?" -eq "0" ]]
then
	ph_add_value_to_param -p PH_RESTORE_FILES -v "${PH_FILE}'${PH_PARAMS}"
	return 0
fi
ph_set_result -m "An error occurred trying to store '${PH_FILE}' as '${PH_TMP_FILE}'"
return 1
}

function ph_create_default_base_conf_file {

declare PH_FILE_SHORTNAME="$1"
declare PH_FILE=""

[[ -z "$PH_FILE_SHORTNAME" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_FILE="$(ph_get_filename_from_shortname "$PH_FILE_SHORTNAME")"
if [[ ! -e "${PH_CONF_DIR}/${PH_FILE}" || -s "${PH_CONF_DIR}/${PH_FILE}" ]]
then
	if [[ -s "${PH_CONF_DIR}/${PH_FILE}" ]]
	then
		printf "%8s%s\n" "" "--> Creating base configuration file '${PH_FILE}'"
		ph_set_result -m "Could not create base configuration file '${PH_CONF_DIR}/${PH_FILE}' since one exists already"
		ph_run_with_rollback -c false -m "Could not create" || \
			return 1
	else
		ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_CONF_DIR}/${PH_FILE}'" || \
			return 1
	fi
fi
return 0
}

function ph_update_pieh_version {

declare PH_NEW_VERSION="$1"

[[ -z "$PH_NEW_VERSION" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Updating PieHelper version to '${PH_NEW_VERSION}'"
if [[ "$PH_VERSION" != "$PH_NEW_VERSION" ]]
then
	if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '${PH_CONF_DIR}/VERSION' -l '${PH_VERSION}"
	then
		if ph_run_with_rollback -c "ph_add_line_to_file -r -f '${PH_CONF_DIR}/VERSION' -l '${PH_NEW_VERSION}"
		then
			PH_VERSION="$PH_NEW_VERSION"
			ph_add_value_to_param -p PH_PIEH_VERSION -v "$PH_VERSION"
			ph_run_with_rollback -c true && \
				return "$?"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not update" || \
		return 1
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_get_app_cmd_from_app_name {

declare PH_FILE
declare PH_APP
declare PH_APP_CMD
declare -i PH_APP_TTY

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_FILE in "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
do
	PH_APP_CMD="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
			ORS = " " \
		} \
		$1 ~ app { \
			for (i=4;i<=NF;i++) { \
				if (i == NF) { \
					ORS = "" ; \
					print $i \
				} else { \
					print $i \
				} \
			} \
		}' "$PH_FILE" 2>/dev/null)"
	if [[ -n "$PH_APP_CMD" ]]
	then
		[[ "$PH_APP" == "PieHelper" ]] && \
			PH_APP_CMD="$(eval "echo -n \"${PH_APP_CMD}\"")"
		if echo "$PH_APP_CMD" | grep -E "#PH_TTY#" >/dev/null
		then
			if ! PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
			then
				return 1
			fi
		fi
		echo -n "${PH_APP_CMD//#PH_TTY#/${PH_APP_TTY}}"
		return 0
	fi
done
return 1
}

function ph_get_app_name_from_app_cmd {

declare PH_FILE
declare PH_APP_CMD
declare PH_APP

PH_APP_CMD="$1"

[[ -z "$PH_APP_CMD" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_FILE in "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
do
	PH_APP="$(nawk -v appcmd="^()*${PH_APP_CMD}$" 'BEGIN { \
			storevar = "" ; \
			count = "0" \
		} { \
			storevar = $1 ; \
			$1 = "" ; \
			$2 = "" ; \
			$3 = "" ; \
			if ($0 ~ appcmd) { \
				count++ \
			} \
		} { \
			next \
		} END { \
			if (count == 1) { \
				printf storevar \
			} \
		}' "$PH_FILE" 2>/dev/null)"
	if [[ -n "$PH_APP" ]]
	then
		echo -n "$PH_APP"
		return 0
	fi
done
return 1
}

function ph_get_app_user_from_app_name {

declare PH_APP
declare PH_APP_USER

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
		printf $2 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1 
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_name_from_base_conf_file {

declare PH_i
declare PH_j
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_APP_INST_STATE
declare PH_FILE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY
declare -i PH_COUNT
declare -l PH_il

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts u:t:c:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" && -z "$PH_APP_CMD" && -z "$PH_APP_INST_STATE" && \
	( "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in USER TTY CMD INST_STATE
do
	PH_il="$PH_i"
	case "$PH_i" in USER)
		PH_FILE="${PH_CONF_DIR}/supported_apps" ;;
			CMD)
		PH_FILE="${PH_CONF_DIR}/supported_apps" ;;
			TTY)
		PH_FILE="${PH_CONF_DIR}/integrated_apps" ;;
			INST_STATE)
		PH_FILE="${PH_CONF_DIR}/supported_apps" ;;
	esac
	declare -n PH_VAR="PH_APP_${PH_i}"
	if [[ ( "$PH_i" != "TTY" && -z "$PH_VAR" ) || \
		( "$PH_i" == "TTY" && "$PH_VAR" -le "1" ) ]]
	then
		unset -n PH_VAR
		continue
	fi
	for PH_j in 1 2
	do
		[[ "$PH_j" == "2" ]] && \
			PH_FILE="${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
		PH_COUNT="$(nawk -v comp="$PH_il" -v mstring="^()*${PH_VAR}()*$" 'BEGIN { \
				count = 0 ; \
				$1 = "" ; \
				if (comp == "user") { \
					$3 = "" \
				} elif (comp == "cmd") { \
					$2 = "" ; \
					$3 = "" \
				} elif (comp == "inst_state") { \
					$2 = "" \
				} ; \
				if (comp != "cmd") { \
					for (i=4;i<=NF;i++) { \
						$i = "" \
					} \
				} \
			} \
			$0 ~ mstring { \
				count++ ; \
				next \
			} { \
				next \
			} END { \
				printf "%s", count \
			}' "${PH_FILE}" 2>/dev/null)"
		[[ "$PH_COUNT" -gt "0" || "$PH_i" != "CMD" ]] && \
			break
	done
	case "$PH_COUNT" in 0)
		unset -n PH_VAR
		continue ;;
			    1)
		PH_APP="$(eval "ph_get_app_name_from_app_${PH_il} \"${PH_VAR}\"")" ;;
			    *)
		unset -n PH_VAR
		return 1 ;;
	esac
	unset -n PH_VAR
	[[ -n "$PH_APP" ]] && \
		break
done
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_inst_state {

declare PH_APP
declare PH_APP_INST_STATE

PH_APP_INST_STATE="$1"

[[ "$PH_APP_INST_STATE" != @(P|U)@(I|A) || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v inst_state="^${PH_APP_INST_STATE}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$3 ~ inst_state { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_user {

declare PH_APP
declare PH_APP_USER

PH_APP_USER="$1"

[[ -z "$PH_APP_USER" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v user="^${PH_APP_USER}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$2 ~ user { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_tty {

declare PH_APP
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v tty="^${PH_APP_TTY}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$2 ~ tty { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_check_mac_validity {

declare PH_MAC_ADDR

PH_MAC_ADDR="$1"

[[ -z "$PH_MAC_ADDR" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_MAC_ADDR" != @({5}(@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9])){1}(:))@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9]))|none) ]]
then
	return 1
fi
return 0
}

function ph_check_ip_validity {

declare PH_IPV4_ADDR

PH_IPV4_ADDR="$1"

[[ -z "$PH_IPV4_ADDR" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_IPV4_ADDR" != @({3}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9]))\.){1}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9])))|) ]]
then
	return 1
fi
return 0
}

function ph_get_pieh_conf_state {

declare PH_CONF_STATE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"

OPTIND="1"

while getopts q PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_QUIESCE="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( "$#" -ne "1" && "$PH_QUIESCE" -eq "0" ) || ( "$PH_QUIESCE" -eq "1" && "$#" -ne "0" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -f "${PH_TMP_DIR}/.first_run" ]]
then
	PH_CONF_STATE="unconfigured"
else
	PH_CONF_STATE="configured"
fi
if [[ "$PH_QUIESCE" -ne "0" ]]
then
	printf "\n%4s%8s%-20s%s\033[32m%s\033[0m\n" "" "Current " "PieHelper version " ": " "'${PH_VERSION}'"
	printf "%12s%-20s%s\033[32m%s\033[0m\n" "" "configuration state " ": " "'${PH_CONF_STATE}'"
else
	echo -n "$PH_CONF_STATE"
fi
return 0
}

function ph_print_bannerline {

declare -i PH_COUNT
declare -i PH_COLUMNS

PH_COLUMNS="$(tput cols 2>/dev/null)"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

while [[ "$PH_COUNT" -lt "$PH_COLUMNS" ]]
do
	printf "%s" "*"
	((PH_COUNT++))
done
printf "\n"
return 0
}

function ph_configure_app_options {

declare PH_APP="$1"
declare PH_ANSWER=""
declare -i PH_OPT="0"
declare -i PH_COUNT="0"
declare -i PH_RET_CODE="0"
declare -a PH_OPTAR=($(nawk -F'=' 'BEGIN { ORS = " " } $1 ~ /^PH_/ { print $1 }' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null))

printf "%8s%s\n" "" "--> Starting configuration of 'read-write $PH_APP' option(s) (Press 'Enter' to start)"
read 2>/dev/null
printf "%10s\033[32m%s\033[0m\n" "" "OK"
sleep 1
for ((PH_OPT=0;PH_OPT<="$(("${#PH_OPTAR[@]}"-1))";PH_OPT++))
do
	clear
        PH_COUNT="0"
        PH_ANSWER=""
	PH_RET_CODE="0"
        confopts_ph.sh -p get -a "$PH_APP" -o "${PH_OPTAR[$PH_OPT]}" | tail -n +4
        confopts_ph.sh -p help -a "$PH_APP" -o "${PH_OPTAR[$PH_OPT]}" | tail -n +4
	printf "%s\033[36m%s\033[0m\033[32m%s\033[0m\033[36m%s\033[0m\n" "- " "Changing the value of " "'${PH_OPTAR[$PH_OPT]}'" " interactively"
        while [[ "$PH_ANSWER" != @(y|n) ]]
        do
                [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && "$PH_COUNT" -eq "0" ]] && (printf "\n%12s\033[32m%s\n" "" "INFO : - A value for PH_MOON_SRV is required for further configuration" ; \
                                printf "%19s%s\033[0m\n\n" "" "- An empty value for PH_MOON_SRV will end configuration but it can later be restarted using either 'confapps_ph.sh' or the PieHelper menu : ")
        	[[ "$PH_COUNT" -gt "0" ]] && printf "\n%10s\033[31m%s\033[0m%s\n\n" "" "ERROR" " : Invalid response"
               	printf "%8s%s" "" "--> Do you want the change the value for ${PH_OPTAR[$PH_OPT]} (y/n) ? "
               	read PH_ANSWER 2>/dev/null
               	if ! ph_screen_input "$PH_ANSWER"
               	then
			if [[ "$PH_OPT" -eq "0" ]]
			then
				ph_set_result -r 1
			else
				ph_set_result -r 1
			fi
			unset PH_OPTAR
			return 1
               	fi
               	((PH_COUNT++))
        done
        printf "%10s%s\n" "" "OK"
        if [[ "$PH_ANSWER" == "y" ]]
        then
                false
                while [[ "$?" -ne "0" ]]
                do
			PH_ANSWER=""
                        printf "%8s%s" "" "--> Please enter the new value for '${PH_OPTAR[$PH_OPT]}' : "
                        read PH_ANSWER 2>/dev/null
                        printf "%10s%s\n" "" "OK"
                        if ph_set_option_to_value "$PH_APP" -r "${PH_OPTAR[$PH_OPT]}'$PH_ANSWER"
			then
				if [[ "${PH_OPTAR[$PH_OPT]}" != "PH_MOON_SRV" ]]
				then
					printf "%2s%s\n\n" "" "SUCCESS"
					sleep 2
				else
					if [[ -n "$PH_MOON_SRV" ]]
					then
						printf "%2s%s\n\n" "" "SUCCESS"
						sleep 2
					fi
				fi
			else
				printf "%8s%s\n\n" "" "--> Please select how to proceed"
				printf "%12s%s\033[32m%s\033[0m%s\n" "" "1. " "'r'" " to retry"
				printf "%12s%s\033[32m%s\033[0m%s\n" "" "2. " "'s'" " to skip to next option"
				printf "%12s%s\033[32m%s\033[0m%s\n\n" "" "3. " "Any other key" " to quit all configuration of '$PH_APP'"
				printf "%8s%s\n" "" "Your choice ? "
				read -s -n 1 PH_ANSWER 2>/dev/null
				printf "\r"
				case "$PH_ANSWER" in s|S)
						PH_RET_CODE="1"
						printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR" " : Skipped by user"
						printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
						sleep 2 ;;
						     r|R)
						printf "%10s%s\n" "" "OK (Retrying)"
						PH_ANSWER="y"
						sleep 1
						false ;;
						       *)
						ph_set_result -r 1
						printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR" " : Quit by user"
						printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
						unset PH_OPTAR
						sleep 2
						return 1 ;;
				esac
			fi
                done
	else
		if [[ "${PH_OPTAR[$PH_OPT]}" != "PH_MOON_SRV" ]]
		then
			printf "%2s%s\n\n" "" "SUCCESS"
			sleep 2
		fi
	fi
        [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && -z "$PH_MOON_SRV" ]] && PH_RET_CODE="1"
	ph_set_result -r "$PH_RET_CODE"
	[[ "$PH_ANSWER" == @(s|S) ]] && PH_ANSWER="" && continue
        if [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && -z "$PH_MOON_SRV" ]]
        then
		printf "%2s\033[31m%s\033[0m%s\n\n" "" "ABORT" " : Empty value for PH_MOON_SRV"
		sleep 2
		unset PH_OPTAR
		return 1
	fi
        PH_ANSWER=""
done
unset PH_OPTAR
return 0
}

function ph_configure_moon {

declare PH_MOON_USER=""
declare PH_MOON_PATH=""

ph_configure_app_options Moonlight
if [[ -n "$PH_MOON_SRV" ]]
then
	PH_MOON_PATH="$(nawk '$1 ~ /^Moonlight$/ { printf $3 }' "$PH_CONF_DIR/supported_apps" 2>/dev/null)"
	PH_MOON_USER="$(ph_get_app_user_from_app_name "Moonlight")"
	if [[ -d "$(getent passwd "$PH_MOON_USER" 2>/dev/null | cut -d':' -f6)/.cache" ]]
	then
		printf "%8s%s\n" "" "--> Removing run account '$PH_MOON_USER' 'Moonlight' cache directory"
		"$PH_SUDO" rm -r "$(getent passwd "$PH_MOON_USER" 2>/dev/null | cut -d':' -f6)"/".cache" 2>/dev/null
		if [[ "$?" -eq "0" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
			ph_set_result -r 0
		else
			printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR" " : Could not remove directory"
			ph_set_result -r 1
		fi
	fi
	if [[ ! -d "$(getent passwd "$PH_MOON_USER" 2>/dev/null | cut -d':' -f6)/.cache" ]]
	then
		printf "%8s%s\n" "" "--> Pairing with '$PH_MOON_SRV'"
		"$PH_SUDO" -E su "$PH_MOON_USER" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} pair ${PH_MOON_SRV}" >/dev/null 2>&1
		ph_set_result -r "$?"
	fi
fi
return 0
}

function ph_configure_kodi {

printf "%8s%s\n" "" "--> Configuring 'Kodi'"
printf "%10s\033[32m%s\033[0m\n" "" "OK (Nothing to do)"
ph_set_result -r 0
return 0
}

function ph_configure_x11 {

printf "%8s%s\n" "" "--> Configuring 'Kodi'"
printf "%10s\033[32m%s\033[0m\n" "" "OK (Nothing to do)"
ph_set_result -r 0
return 0
}

function ph_configure_bash {

printf "%8s%s\n" "" "--> Configuring 'Kodi'"
printf "%10s\033[32m%s\033[0m\n" "" "OK (Nothing to do)"
ph_set_result -r 0
return 0
}

function ph_configure_emul {

declare PH_ALSA_CARD=""
declare PH_ALSA_DEV=""

printf "%8s%s\n" "" "--> Configuring 'ALSA' audio"
PH_ALSA_CARD="$(aplay -l 2>/dev/null | nawk 'BEGIN { ORS = "" } $0 ~ /HDMI/ { for (i=1;i<=NF;i++) { if ($i~/^card$/) { sub(/:/,"",$(i+1)) ; print $(i+1) }}}' 2>/dev/null)"
PH_ALSA_DEV="$(aplay -l 2>/dev/null | nawk 'BEGIN { ORS = "" } $0 ~ /HDMI/ { for (i=1;i<=NF;i++) { if ($i~/^device$/) { sub(/:/,"",$(i+1)) ; print $(i+1) }}}' 2>/dev/null)"
"$PH_SUDO" -E nawk -v card="$PH_ALSA_CARD" -v dev="$PH_ALSA_DEV" '$1 ~ /^audio_enable$/ { print "audio_enable = true" ; next }
	$1 ~ /^audio_out_rate$/ { print "audio_out_rate = 44100" ; next }
	$1 ~ /^audio_driver$/ { print "audio_driver = alsa" ; next }
	$1 ~ /^audio_sync$/ { print "audio_sync = true" ; next }
	$1 ~ /^audio_device$/ { print "audio_device = hw:" card "," dev ; next }
	{ print }' /opt/retropie/configs/all/retroarch.cfg >/tmp/retroarch.cfg_tmp 2>/dev/null
if [[ "$?" -eq "0" ]]
then
	if [[ -n "$PH_ALSA_CARD" && -n "$PH_ALSA_DEV" ]]
	then
		"$PH_SUDO" mv /tmp/retroarch.cfg_tmp /opt/retropie/configs/all/retroarch.cfg 2>/dev/null
		if [[ "$?" -eq "0" ]]
		then
			ph_set_result -r 0
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not configure audio"
			"$PH_SUDO" rm /tmp/retroarch_cfg_tmp 2>/dev/null
			ph_set_result -r 1
			return 1
		fi
	else
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not configure audio"
		"$PH_SUDO" rm /tmp/retroarch_cfg_tmp 2>/dev/null
		ph_set_result -r 1
		return 1
	fi
else
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not configure audio"
	"$PH_SUDO" rm /tmp/retroarch_cfg_tmp 2>/dev/null
	ph_set_result -r 1
	return 1
fi
return 0
}

function ph_configure_app {

declare PH_APP=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -l PH_APPL=""

OPTIND="1"

while getopts a: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
                PH_APP="$OPTARG"
                PH_APPL="${PH_APP:0:4}" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

ph_configure_"$PH_APPL" 2>/dev/null
if [[ "$?" -ne "0" ]]
then
	if [[ "$(ph_check_app_state_validity -a "$PH_APP" -q -d ; echo "$?")" -ne "0" && \
		"$(functions 2>&1 | grep -E "function ph_configure_${PH_APPL} {" >/dev/null ; echo "$?")" -ne "0" ]]
	then
		ph_set_result -r 1 -m "User-side development is mandatory for configuration routines of 'Out-of-scope' applications"
	fi
	return 1
fi
return 0
}

function ph_setup_controllers {

declare PH_MAP="$PH_CTRL_MAP"
declare PH_i=""
declare PH_j=""
declare PH_ADD_CTRL_TYPE=""
declare PH_PARENT_DEV_PATH=""
declare -i PH_PRINT_FLAG="1"
declare -i PH_NUM_CTRL="$1"
declare -i PH_CTRL_CLI_ID="0"
declare -i PH_EVDEVS="0"

if [[ ! -f "$PH_CONF_DIR"/controller_cli_ids ]]
then
	ph_create_default_base_conf_file cont || return 1
fi
ph_cleanup_controllers reset
[[ "$PH_CTRL_TYPE" == "XBOX360" ]] && PH_MAP="no"
PH_EVDEVS="$(ls -l /dev/input/event+([[:digit:]]) 2>/dev/null | wc -l)"
[[ "$PH_EVDEVS" -eq "0" ]] && printf "%8s%s\n" "" "--> Running type verification of input devices" && printf "%10s%s\n" "" "ERROR : (None found)" && return 1 
for PH_i in $(find /dev/input -name "event+([[:digit:]])" -exec ls -l {} \; 2>/dev/null | sort -n 2>/dev/null | nawk 'BEGIN { ORS = " " } { print $NF }')
do
	printf "%8s%s\n" "" "--> Running type verification of input device '${PH_i##*event}'"
	PH_PARENT_DEV_PATH="$(udevadm info "$PH_i" 2>/dev/null | nawk -F'=' '$0 ~ /.: DEVPATH=/ { print $2 }')"
	PH_PARENT_DEV_PATH="${PH_PARENT_DEV_PATH%/*}"
	[[ "$PH_CTRL_TYPE" == "PS4" ]] && PH_ADD_CTRL_TYPE="PS4A"
	for PH_j in "$PH_CTRL_TYPE" $PH_ADD_CTRL_TYPE
	do
		[[ "$PH_j" != "PS4A" ]] && PH_PRINT_FLAG="0"
## add xboxurecv connection type for wireless XBOX360 USB Receiver
		PH_CTRL_CONN="$(udevadm info -q all --path "$PH_PARENT_DEV_PATH" 2>/dev/null | nawk -F'=' -v type="$PH_j" 'BEGIN { flag = 0 ; conn="" ; if (type~/^PS4$/) { string = "\"(Sony Interactive Entertainment )*Wireless Controller\"$" }
				else { if (type~/^PS4A$/) { string="\"Sony Interactive Entertainment DUALSHOCK.*4 USB Wireless Adaptor\"$" }
				else { if (type~/^PS3$/) { string="\".*PLAYSTATION\(R\)3 Controller\"$" }
				else { if (type~/^XBOX360$/) { string="\"Microsoft X-Box 360 pad\"$" }}}}}
				$2 ~ string { flag = 1 ; next }
				$1 ~ "^.: ID_BUS$" { if (type~/^PS4A/) { conn = "sonywadapt" } else { conn = $2 } ; next }
				{ next }
				END { if (flag==1) { print conn }}' 2>/dev/null)"
		if [[ -n "$PH_CTRL_CONN" ]]
		then
			PH_CTRL_CLI_ID="${PH_i##*event}"
			declare -n PH_CONN="PH_CTRL_CONN""$PH_CTRL_CLI_ID"
			declare -n PH_CLI_ID="PH_CTRL_CLI_ID""$PH_CTRL_CLI_ID"
			PH_CONN="$PH_CTRL_CONN"
			PH_CLI_ID="$PH_CTRL_CLI_ID"
			printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_CTRL_TYPE:$PH_CONN:id $PH_CLI_ID')"
			[[ "$PH_j" == "PS4" ]] && PH_PRINT_FLAG="1"
			echo "$PH_CLI_ID" >>"$PH_CONF_DIR"/controller_cli_ids 2>/dev/null
			unset -n PH_CLI_ID PH_CONN
		else
			[[ "$PH_j" != "PS4" && "$PH_PRINT_FLAG" -eq "0" ]] && printf "%10s\033[32m%s\033[0m\n" "" "OK (Not a '$PH_CTRL_TYPE' controller)"
		fi
	done
done
printf "%8s%s\n" "" "--> Verifying '$PH_CTRL_TYPE' controller count"
if [[ "$(cat "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null | wc -l)" -eq "$PH_NUM_CTRL" ]]
then
        printf "%10s\033[32m%s\033[0m\n" "" "OK"
else
        [[ "$(cat "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null | wc -l)" -lt "$PH_NUM_CTRL" ]] && \
                printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Insufficient number of '$PH_CTRL_TYPE' controllers connected (`cat \"$PH_CONF_DIR\"/controller_cli_ids 2>/dev/null | wc -l`<->'\"$PH_NUM_CTRL\"' requested)" && return 1
        declare -n PH_CONN=PH_CTRL_CONN"$(sed -n '1p' "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null)"
        declare -n PH_CLI_ID=PH_CTRL_CLI_ID"$(sed -n '1p' "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null)"
        printf "%10s\033[33m%s\033[0m" "" "Warning : Greater number of '$PH_CTRL_TYPE' controllers connected than requested (`cat \"$PH_CONF_DIR\"/controller_cli_ids 2>/dev/null | wc -l`<->'\"$PH_NUM_CTRL\"' requested) -> Using '$PH_CONN:CLI id $PH_CLI_ID'"
        if [[ "$PH_NUM_CTRL" -ne "1" ]]
        then
		for ((PH_i=2;PH_i<="${PH_NUM_CTRL}";PH_i++))
                do
                        [[ "$PH_i" -le "$PH_NUM_CTRL" ]] && printf "\033[33m%s\033[0m" ' &&'
                        printf "\033[33m%s\033[0m" " '$(eval echo -n \"\$PH_CTRL_CONN$PH_i\"):CLI id $(eval echo -n \"\$PH_CTRL_CLI_ID$PH_i\")'"
                done
        fi
        echo ''
	unset -n PH_CONN PH_CLI_ID
fi
[[ "$PH_NUM_CTRL" -ge "2" ]] && (printf "%8s%s\n" "" "--> Growing udev event queue for multiple controller usage" ; \
		"$PH_SUDO" udevadm control --children-max 500 2>/dev/null ; printf "%10s\033[32m%s\033[0m\n" "" "OK")
if [[ "$PH_MAP" == "yes" ]]
then
	ph_cleanup_controllers unmap || return 1
	printf "%8s%s\n" "" "--> Starting 'xboxdrv' instance with virtual 'XBOX360' controller mapping"
	for ((PH_CTRL_ID=1;PH_CTRL_ID<="${PH_NUM_CTRL}";PH_CTRL_ID++))
	do
		declare -n PH_CLI_ID=PH_CTRL_CLI_ID"$(sed -n ''"$PH_CTRL_CLI_ID"'p' "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null)"
		declare -n PH_CONN=PH_CTRL_CONN"$(sed -n ''"$PH_CTRL_CLI_ID"'p' "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null)"
		case "$PH_CTRL_TYPE"_"$PH_CONN" in PS4_bluetooth)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev /dev/input/event"$PH_CLI_ID" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" >/dev/null 2>&1 && printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && >"$PH_CONF_DIR"/controller_cli_ids && return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"$PH_CONF_DIR"/controller_cli_ids  2>/dev/null ;;
## correct button mappings for the three cases below
		   			   	 PS3_bluetooth)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev /dev/input/event"$PH_CLI_ID" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" >/dev/null 2>&1 && printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && >"$PH_CONF_DIR"/controller_cli_ids && return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"$PH_CONF_DIR"/controller_cli_ids 2>/dev/null ;;
			   			       PS3_usb)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev /dev/input/event"$PH_CLI_ID" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" >/dev/null 2>&1 && printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && >"$PH_CONF_DIR"/controller_cli_ids && return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"$PH_CONF_DIR"/controller_cli_ids 2>/dev/null ;;
				         		     *)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev /dev/input/event"$PH_CLI_ID" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat /tmp/xboxdrv"$PH_CTRL_CLI_ID"".pid" >/dev/null 2>&1 && printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && >"$PH_CONF_DIR"/controller_cli_ids && return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"$PH_CONF_DIR"/controller_cli_ids 2>/dev/null ;; 
		esac
		unset -n PH_CLI_ID PH_CONN
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
for PH_i in $(cat "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null | paste -d" " -s)
do
	[[ "$PH_i" -lt "$PH_EVDEVS" ]] && unset -n PH_CTRL_CONN"$PH_i" PH_CTRL_CLI_ID"$PH_i"
done
return 0
}

function ph_get_controller_cli_id {

declare PH_CTRL_CLI_ID=""

PH_CTRL_CLI_ID="$(sed -n ''"$1"'p' "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null)"
[[ -z "$PH_CTRL_CLI_ID" ]] && return 1
echo -n "$PH_CTRL_CLI_ID"
return 0
}

function ph_cleanup_controllers {

declare -i PH_RET_CODE="0"

if [[ "$1" == @(reset|full) ]]
then
	if [[ "$(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)" -gt "0" ]]
	then
		printf "%8s%s\n" "" "--> Resetting controller CLI ids"
		>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
	fi
fi
if [[ "$1" == @(unmap|full) ]]
then
	if pgrep xboxdrv >/dev/null 2>&1
	then
		printf "%8s%s\n" "" "--> Stopping 'xboxdrv' instance(s)"
		"$PH_SUDO" pkill -9 xboxdrv >/dev/null 2>&1
		if [[ "$?" -eq "0" ]]
		then
			"$PH_SUDO" rm /tmp/xboxdrv*.pid >/dev/null 2>&1
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
			sleep 1
		else
			printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Could not stop instance(s) -> A reboot is required"
			PH_RET_CODE="1"
		fi
	fi
fi
return "$PH_RET_CODE"
}

function ph_get_app_pkg_from_app_conf {

declare PH_APP
declare -u PH_APPU
declare -n PH_APP_PKG

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	unset -n PH_APP_PKG && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPU="${PH_APP:0:4}"
PH_APP_PKG="PH_${PH_APPU}_PKG_NAME"
echo -n "$PH_APP_PKG"
unset -n PH_APP_PKG
return 0
}

function ph_check_app_state_validity {

declare PH_OPTION=""
declare PH_APP=""
declare PH_APP_CMD=""
declare PH_i=""
declare PH_APP_TYPE=""
declare PH_APP_STATE="Unknown"
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -i PH_QUIESCE="1"
declare -i PH_FORCE_PRINT_FLAG="1"
declare -i PH_RET_CODE="0"
declare -l PH_APPL=""

OPTIND="1"

while getopts a:isuhrdqfv PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in i)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Integrated" ;;
			     s)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Supported" ;;
			     d)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Default" ;;
			     h)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Halted" ;;
			     v)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Reserved" ;;
			     r)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Running" ;;
			     u)
		[[ -n "$PH_APP_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_TYPE="Unused" ;;
			     f)
		[[ "$PH_FORCE_PRINT_FLAG" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FORCE_PRINT_FLAG="0" ;;
			     q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_QUIESCE="0" ;;
			     a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP="$OPTARG"
		PH_APPL="${PH_APP:0:4}" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_TYPE" || "$#" -lt "3" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_QUIESCE" -eq "1" ]] && \
	printf "%8s%s\n" "" "--> Checking the application state of ${PH_APP}"
case "$PH_APP_TYPE" in Default)
	cut -f1 "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null && \
		PH_APP_STATE="Default" ;;
		       *)
	if [[ "$PH_APPL" == @(none|all|prom) ]]
	then
		PH_APP_STATE="Reserved"
	else
		if ! ph_check_app_state_validity -a "$PH_APP" -q -d
		then
			[[ "$PH_APPL" == @(x11|kodi|moon|emul|bash|pieh) ]] && \
				PH_APP_STATE="Reserved"
		else
			PH_APP_STATE="Default"
		fi
	fi
	if cut -f1 "${PH_CONF_DIR}/supported_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
	then
		PH_APP_STATE="Supported"
		if cut -f1 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
		then
			PH_APP_STATE="Integrated"
			if nawk -v app="^${PH_APP}$" '$1 ~ app && $3 !~ /^-$/ {
					printf $1
				}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
			then
				PH_APP_STATE="Halted"
				PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
				PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
				if [[ "$PH_APP" == "Bash" ]]
				then
					PH_APP_CMD="bash"
					if [[ -n "$(ps --ppid "$(pgrep -t "tty${PH_APP_TTY}" -f "$PH_APP_CMD" 2>/dev/null)" 2>/dev/null | tail -n +2)" ]]
					then
						PH_APP_STATE="Running"
					fi
				else
					PH_APP_CMD="${PH_APP_CMD//#PH_TTY#/${PH_APP_TTY}}(sed "s/#PH_TTY#/""$PH_APP_TTY""/g" <<<"$PH_APP_CMD")"
					if pgrep -t "tty${PH_APP_TTY}" -f "$PH_APP_CMD" >/dev/null 2>&1
					then
						PH_APP_STATE="Running"
					else
						if [[ "$PH_APP" == "PieHelper" && \
							"$(pgrep -f "^/bin/bash ${PH_SCRIPTS_DIR}/startpieh.sh.*-p$|${PH_SCRIPTS_DIR}/startpieh.sh[[:space:]]*-p[[:space:]].*$" >/dev/null ; echo "$?")" -eq "0" ]]
						then
							PH_APP_STATE="Running"
						fi
					fi
				fi
			fi
		fi
	fi ;;
esac
if [[ "$PH_APP_TYPE" != "$PH_APP_STATE" ]]
then
	case "$PH_APP_STATE" in Unknown)
			if [[ "$PH_APP_TYPE" != "Unused" ]]
			then
				PH_RET_CODE="1"
			else
				PH_APP_TYPE="Unknown"
			fi ;;
				Reserved)
			[[ "$PH_APP_TYPE" != "Default" ]] && \
				PH_RET_CODE="1" ;;
				Default)
			[[ "$PH_APP_TYPE" == @(Halted|Running|Integrated|Reserved) ]] && \
				PH_RET_CODE="1" ;;
				Supported)
			[[ "$PH_APP_TYPE" == @(Halted|Running|Integrated|Unused) ]] && \
				PH_RET_CODE="1" ;;
				Integrated)
			[[ "$PH_APP_TYPE" == @(Halted|Running|Unused) ]] && \
				PH_RET_CODE="1" ;;
				Running)
			[[ "$PH_APP_TYPE" == @(Halted|Unused) ]] && \
				PH_RET_CODE="1" ;;
				Halted)
			[[ "$PH_APP_TYPE" == @(Running|Unused) ]] && \
				PH_RET_CODE="1" ;;
	esac
	if [[ "$PH_APP_STATE" == @(@(Support|Integrat|Halt)ed|Running) && "$PH_APP_TYPE" == "Default" ]]
	then
		ph_check_app_state_validity -a "$PH_APP" -q -d && \
			PH_RET_CODE="0"
	fi
fi
if [[ "$PH_QUIESCE" -eq "1" || "$PH_FORCE_PRINT_FLAG" -eq "0" ]]
then
	if [[ "$PH_RET_CODE" -eq "0" ]]
	then
		if [[ "$PH_QUIESCE" -eq "1" ]]
		then
			ph_run_with_rollback -c true -m "'${PH_APP_STATE}' (Needed '${PH_APP_TYPE}')"
		else
			echo -n "$PH_APP_STATE"
		fi
	else
		if [[ "$PH_QUIESCE" -eq "1" ]]
		then
			ph_run_with_rollback -c false -m "'${PH_APP_STATE}' (Needed '${PH_APP_TYPE}')"
		else
			echo -n "$PH_APP_STATE"
		fi
		ph_set_result -m "Application state '${PH_APP_TYPE}' is mandatory but got '${PH_APP_STATE}'"
	fi
fi
return "$PH_RET_CODE"
}

function ph_move_app {

declare PH_OPTION=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -i PH_APP_NEW_TTY="0"
declare -i PH_BOOT_TTY_FLAG="1"

OPTIND="1"

while getopts t:a: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$PH_APP_NEW_TTY" -gt "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_NEW_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$PH_APP_NEW_TTY" -eq "0" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
[[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]] && \
	PH_BOOT_TTY_FLAG="0"
ph_run_with_rollback -c "ph_undo_setup_tty -a '${PH_APP}' -t '${PH_APP_TTY}' -u '${PH_APP_USER}'" || \
	return 1
ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -t '${PH_APP_NEW_TTY}' -u '${PH_APP_USER}'" || \
	return 1
if [[ "$PH_BOOT_TTY_FLAG" -eq "0" ]]
then
	ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_NEW_TTY}'" || \
		return 1
fi
return 0
}

function ph_set_tty_for_boot {

declare PH_i=""
declare -i PH_APP_TTY="$1"
declare -i PH_CUR_TTY="0"
declare -i PH_RET_CODE="0"

[[ "$PH_APP_TTY" -eq "1" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
	[[ "$PH_APP_TTY" -eq "0" ]] && \
		return 0
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating StartApp configuration for " "'tty${PH_APP_TTY}'"
	if ph_run_with_rollback -c "ph_create_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
	then
		if ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
		then
			for PH_i in '[Service]' 'ExecStart=' 'ExecStart=-/sbin/agetty --noclear tty1 $TERM' "ExecStartPost=+/bin/chvt ${PH_APP_TTY}" 'TTYVTDisallocate=no' 'TTYReset=no' 'TTYVHangup=no'
			do
				if ! ph_run_with_rollback -c "ph_add_line_to_file -r -l '${PH_i}' -f '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
				then
					ph_run_with_rollback -c false -m "Could not create" || \
						return 1
				fi
			done
        		if "$PH_SUDO" chmod 644 /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
			then
        			if "$PH_SUDO" chown root:root /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
				then
					if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
					then
						ph_add_value_to_param -p PH_SET_BOOT_TTYS -v "$PH_APP_TTY"
						ph_run_with_rollback -c true && \
							return "$?"
					else
						ph_set_result -m "Could not reload systemd configuration"
					fi
				else
					ph_set_result -m "Could not set ownership of file '/etc/systemd/system/getty@tty1.service.d/autostart.conf' to 'root:root'"
				fi
			else
				ph_set_result -m "Could not set permissions of file '/etc/systemd/system/getty@tty1.service.d/autostart.conf' to '644'"
			fi
		fi
	fi
	ph_run_with_rollback -c false -m "Could not create"
else
	PH_CUR_TTY="$(nawk '$1 ~ /^ExecStartPost=/ { \
			print $2 \
		}' /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null)"
	[[ "$PH_CUR_TTY" -eq "$PH_APP_TTY" ]] && \
		return 0
	printf "%8s%s\n" "" "--> Removing StartApp configuration for 'TTY${PH_CUR_TTY}'"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
	then
		if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
		then
			ph_run_with_rollback -c true
			ph_run_with_rollback -c "ph_disable_app_tty '${PH_CUR_TTY}'" || \
				return 1
			ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_TTY}'" || \
				return 1
			ph_add_value_to_param -p PH_SET_BOOT_TTYS -v "$PH_APP_TTY"
			return 0
		else
			ph_set_result -m "An error occurred trying to reload systemd configuration"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not remove"
fi
return 1
}

function ph_get_app_name_from_option {

declare PH_APP
declare PH_OPT

PH_OPT="$1"

[[ -z "$PH_OPT" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(grep -El "^${PH_OPT}=" "${PH_CONF_DIR}/"*.conf 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	PH_APP="$(grep -El "^\[\[.*declare.*${PH_OPT}=" "${PH_CONF_DIR}/"*.conf 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
PH_APP="${PH_APP%%.conf}"
echo -n "${PH_APP##*/}"
return 0
}

function ph_set_variable {

declare PH_OPTION=""
declare PH_VARNAME=""
declare PH_OLDVALUE=""
declare PH_VALUE=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RET_CODE="0"

OPTIND="1"

while getopts n:v: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in n)
                PH_VARNAME="$OPTARG" ;;
                             v)
                PH_VALUE="$OPTARG" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_VARNAME" ]] && \
	return 1

declare -n PH_VAR="$PH_VARNAME"
PH_OLDVALUE="$PH_VAR"
if ! export PH_VAR="$PH_VALUE"
then
	unset -n PH_VAR
	PH_RET_CODE="1"
else
	unset -n PH_VAR
	ph_add_value_to_param -p PH_VARIABLES -v "$PH_VARNAME'$PH_OLDVALUE"
fi
return "$PH_RET_CODE"
}

function ph_store_option {

declare PH_OPT_NAME="$1"
[[ -z "$PH_OPT" ]] && \
	return 1

if [[ ! -f "${PH_FILES_DIR}/stored_options" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -q -t file -d '${PH_FILES_DIR}/stored_options'" || \
		return 1
fi
ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_FILES_DIR}/stored_options' -l '${PH_OPT_NAME}\'$(eval "echo -n \"\$${PH_OPT_NAME}\"")'" || \
	return 1
ph_add_value_to_param -p PH_RETRIEVE_STORED_OPTION -v "$PH_OPT_NAME"
return 0
}

function ph_store_app_options {

declare PH_APP="$1"
[[ -z "$PH_APP" ]] && \
	return 1
declare PH_OPT=""
declare PH_OPTS=""

PH_OPTS="$(nawk -F'=' 'BEGIN { \
		ORS = " " \
	} \
	$1 ~ /^PH_/ { \
		print $1 \
	}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)"
for PH_OPT in $(echo -n "$PH_OPTS")
do
	ph_store_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_store_all_options {

declare PH_APP=""

"$PH_SUDO" rm "${PH_FILES_DIR}/stored_options" 2>/dev/null
for PH_APP in $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $1 \
	} END { \
		print "Ctrls" \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)
do
	ph_store_app_options "$PH_APP" || \
		return 1
done
return 0
}

function ph_retrieve_stored_option {

declare PH_OPT_NAME="$1"
declare PH_OPT_VALUE=""

[[ -z "$PH_OPT_NAME" || ! -f "${PH_FILES_DIR}/stored_options" || -s "${PH_FILES_DIR}/stored_options" ]] && \
	return 1
tail -1 "${PH_FILES_DIR}/stored_options" 2>/dev/null | grep -E "^${PH_OPT_NAME}'" >/dev/null || \
	return 1

PH_OPT_VALUE="$(sed -n '$p' "${PH_FILES_DIR}/stored_options" 2>/dev/null | cut -d"'" -f2)"
ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_FILES_DIR}/stored_options' -l '${PH_OPT_NAME}\'${PH_OPT_VALUE}'" || \
	return 1
if [[ -f "${PH_FILES_DIR}/stored_options" && -s "${PH_FILES_DIR}/stored_options" ]]
then
	ph_run_with_rollback -c "ph_remove_empty_file -q -t file -d '${PH_FILES_DIR}/stored_options'" || \
		return 1
fi
ph_add_value_to_param -p PH_STORE_OPTION -v "$PH_OPT_NAME"
return 0
}

function ph_retrieve_stored_app_options {

declare PH_APP="$1"
[[ -z "$PH_APP" ]] && \
	return 1
declare PH_OPT=""
declare PH_VALUE=""

[[ ! -f "${PH_FILES_DIR}/stored_options" ]] && \
	return 1
for PH_OPT in $(nawk 'BEGIN { \
		ORS =  " " ; \
		FS = "\x27" \
	} { \
		print $1 \
	}' "${PH_FILES_DIR}/stored_options" 2>/dev/null)
do
	[[ "$(ph_get_app_name_from_option "$PH_OPT")" != "$PH_APP" ]] && \
		continue
	PH_VALUE="$(nawk -v opt=^"${PH_OPT}"$ 'BEGIN { \
			FS = "\x27" \
		} \
		$1 ~ opt { \
			print $2 \
		}' "${PH_FILES_DIR}/stored_options" 2>/dev/null)"
	ph_retrieve_stored_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_retrieve_stored_options {

declare PH_OPT=""

for PH_OPT in $(nawk 'BEGIN { \
		ORS =  " " ; \
		FS = "\x27" \
	} { \
		print $1 \
	}' "${PH_FILES_DIR}/stored_options" 2>/dev/null)
do
	ph_retrieve_stored_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_get_option_value_from_app_conf_file {

declare PH_OPT=""
declare PH_VALUE=""
declare PH_OPTION=""
declare PH_OPT_TYPE=""
declare PH_APP=""
declare PH_RESOLVE="no"
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts o:a:r PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in o)
                PH_OPT="$OPTARG" ;;
                             a)
                PH_APP="$OPTARG" ;;
                             r)
                PH_RESOLVE="yes" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_OPT" ]] && \
	return 1
[[ -z "$PH_APP" ]] && \
	PH_APP="$(ph_get_app_name_from_option "$PH_OPT")"
[[ -z "$PH_APP" ]] && \
	return 1
if grep -E ^"${PH_OPT}=" "${PH_CONF_DIR}/${PH_APP}.conf" >/dev/null 2>&1
then
	PH_OPT_TYPE="read-write"
else
	PH_OPT_TYPE="read-only"
fi
if [[ "$PH_OPT_TYPE" == "read-only" ]]
then
	PH_VALUE="$(nawk -v comp="^\[\[.*declare.*([[:space:]])+${PH_OPT}=" 'BEGIN { \
			FS = "\x27" \
		} \
		$0 ~ comp { \
			print $2 \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)"
else
	PH_VALUE="$(nawk -v opt="^$PH_OPT=" 'BEGIN { \
			FS = "\x27" \
		} \
		$1 ~ opt { \
			print $2 \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)"
fi
if [[ "$PH_RESOLVE" == "yes" ]]
then
	PH_VALUE="$(eval echo -n "$PH_VALUE")"
fi
echo -n "$PH_VALUE"
return 0
}

function ph_set_option_to_default_value {

declare PH_OPT="$1"
[[ -z "$PH_OPT" ]] && \
	return 1
declare PH_APP="$(ph_get_app_name_from_option "$PH_OPT")"
[[ -z "$PH_APP" ]] && \
	return 1
declare PH_VALUE="$(eval "echo -n \"\$${PH_OPT}\"")"
declare PH_DEF_VALUE="$(grep -E "^${PH_OPT}:" "${PH_CONF_DIR}/options.defaults" 2>/dev/null | cut -d":" -f2-)"

export "OLD_${PH_OPT}"="$PH_VALUE"
ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"${PH_OPT}'${PH_DEF_VALUE}\"" || \
	return 1
unset "OLD_${PH_OPT}"
return 0
}

function ph_set_app_options_to_default_value {

declare PH_APP="$1"
[[ -z "$PH_APP" ]] && \
	return 1
declare PH_OPT=""

for PH_OPT in $(nawk -F'=' 'BEGIN { \
		ORS = " " \
		} \
		$1 ~ /^PH_/ { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
do
	ph_set_option_to_default_value "$PH_OPT" || \
		return 1
done
return 0
}

function ph_set_all_options_to_default_value {

declare PH_APP=""

for PH_APP in Ctrls $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $1 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)
do
	ph_set_app_options_to_default_value "$PH_APP" || \
		return 1
done
return 0
}

function ph_show_menu {

declare PH_MENU="$1"
declare PH_LAST_RETURN="$PH_LAST_RETURN_GLOB"
unset PH_LAST_RETURN_GLOB

if [[ "$PH_MENU" == @(Advanced|Main|Apps|Controllers|OS) ]]
then
	declare PH_TYPE="menu"
else
	declare PH_TYPE="submenu"
fi
[[ "$PH_MENU" == @(OptsManagement|TTYManagement|AppManagement) ]] && PH_MENU="$(ls -l "$PH_FILES_DIR"/menus/"$PH_MENU".lst 2>/dev/null | nawk -F'/' '{ print $NF }' | cut -d'.' -f1)"
if [[ "$PH_MENU" == @(OptsManagement_*|TTYManagement_*|AppManagement_*) ]]
then
	declare PH_HEADER="Welcome to PieHelper ${PH_VERSION} '${PH_MENU%%_*} for ${PH_MENU##*_}' $PH_TYPE"
else
	if [[ "$PH_MENU" == "Settings" ]]
	then
		declare PH_HEADER="Welcome to PieHelper ${PH_VERSION} 'Controllers $PH_MENU' $PH_TYPE"
	else
		declare PH_HEADER="Welcome to PieHelper ${PH_VERSION} '$PH_MENU' $PH_TYPE"
	fi
fi
declare PH_j=""
declare -i PH_ANSWER="0"
declare -i PH_i="0"
declare -i PH_COUNT="0"
declare -i PH_COLUMNS="$(tput cols 2>/dev/null)"

while true
do
	if [[ "$PH_MENU" == @(OptsManagement_*|TTYManagement_*|AppManagement_*) ]]
	then
		ph_link_app_to_menu "${PH_MENU##*_}"
	else
		[[ "$PH_MENU" != @(Main|PS3|PS4|XBOX|Advanced|Settings|OS|OSdefaults|OptsManagement|Apps|Controllers|TTYManagement|AppManagement) ]] && ph_link_app_to_menu "$PH_MENU"
	fi
	PH_ANSWER="0"
	PH_COUNT="0"
	if [[ "$PH_MENU" == "Apps" ]]
	then
		>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show 'Supported' applications:confapps_ph.sh -p list -l sup | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show 'Integrated' applications:confapps_ph.sh -p list -l int | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show 'Halted' applications:confapps_ph.sh -p list -l halt | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show 'Running' applications:confapps_ph.sh -p list -l run | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show 'StartApp' application:confapps_ph.sh -p list -l start | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Show all of the above:confapps_ph.sh -p list -l all | more" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Change 'StartApp' application:confapps_ph.sh -p start -a prompt" >>"$PH_FILES_DIR/menus/Apps.lst"
		echo "Support new application:confapps_ph.sh -p sup -a prompt" >>"$PH_FILES_DIR/menus/Apps.lst"
		for PH_j in `nawk 'BEGIN { ORS = " " } { print $1 }' "$PH_CONF_DIR/supported_apps" 2>/dev/null`
		do
			echo "Go to '$PH_j' submenu:ph_show_menu $PH_j" >>"$PH_FILES_DIR"/menus/Apps.lst
		done
		echo "Go to 'Main' menu:ph_show_menu Main" >>"$PH_FILES_DIR"/menus/Apps.lst
		echo "Go to 'Advanced' menu:ph_show_menu Advanced" >>"$PH_FILES_DIR"/menus/Apps.lst
		echo "Go to 'Controllers' menu:ph_show_menu Controllers" >>"$PH_FILES_DIR"/menus/Apps.lst
		echo "Open Shell to home directory (Type 'CTRL-D' to return):cd;/bin/bash" >>"$PH_FILES_DIR"/menus/Apps.lst
		echo "Return to previous screen:return" >>"$PH_FILES_DIR"/menus/Apps.lst
	fi
	declare -a PH_MENU_ITEM
	for ((PH_i=1;PH_i<="$(cat "${PH_MENUS_DIR}/${PH_MENU}.lst" 2>/dev/null | wc -l)";PH_i++))
	do
		PH_MENU_ITEM+=("$(nawk -F':' -v line="$PH_i" 'NR == line { print $1 }' "${PH_FILES_DIR}/menus/${PH_MENU}.lst")")
	done
	declare -a PH_MENU_CMD
	for ((PH_i=1;PH_i<="$(cat "${PH_MENUS_DIR}/${PH_MENU}.lst" 2>/dev/null | wc -l)";PH_i++))
	do
		PH_MENU_CMD+=("$(nawk -F':' -v line="$PH_i" 'NR == line { print $2 }' "${PH_FILES_DIR}/menus/${PH_MENU}.lst")")
	done
	clear
	ph_print_bannerline
	printf "\n"
	printf "%$(echo -n "$((PH_COLUMNS/2-"${#PH_HEADER}"/2))")s\033[036m%s\033[0m\n" "" "$PH_HEADER"
	printf "\n"
	ph_print_bannerline
	printf "\n"
	for ((PH_i=1;PH_i<="$(("${#PH_MENU_ITEM[@]}"-1))";PH_i++))
	do
		printf "%-4s%-30s\n" "$PH_i. " "${PH_MENU_ITEM[$PH_i]}"
	done
	printf "\n"
	while [[ "$PH_ANSWER" -eq "0" || "$PH_ANSWER" -gt "$((${#PH_MENU_ITEM[@]}-1))" ]]
	do
		[[ "$PH_COUNT" -gt "0" ]] && printf "\n%2s%s\n\n" "" "ERROR : Invalid response"
		printf "%s" "Your Choice : "
		read PH_ANSWER 2>/dev/null
		((PH_COUNT++))
	done
	if [[ "$PH_ANSWER" -ne "$((${#PH_MENU_ITEM[@]}-1))" ]]
	then
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" == '"$PH_SUDO" init 6' ]]
		then
			printf "\n"
			ph_print_bannerline
			printf "\n"
			printf "%2s%s\n" "" "Rebooting your system"
			printf "\n"
			ph_print_bannerline
		fi
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" != ph_show_menu* && "${PH_MENU_CMD[$PH_ANSWER]}" != '"$PH_SUDO" init 6' ]]
		then
			printf "\n"
			printf "%s\n" "Output of running commands :"
			printf "\n"
			ph_print_bannerline
			printf "\n"
		fi
		eval "${PH_MENU_CMD[$PH_ANSWER]}"
		PH_ANSWER="$?"
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" != @(ph_show_menu*|return) ]]
		then
			printf "\n"
			ph_print_bannerline
			printf "\n"
		fi
	else
		if [[ -z "$PH_LAST_RETURN" ]]
		then
			eval "${PH_MENU_CMD[$PH_ANSWER]}" "$PH_ANSWER" 2>/dev/null
		else
			printf "\n"
			ph_print_bannerline
			printf "\n"
			printf "%s\n\n" "Already on first screen"
			ph_print_bannerline
			printf "\n"
		fi
		PH_ANSWER="0"
	fi
	[[ "$PH_ANSWER" -eq "0" || "$PH_ANSWER" -eq "1" ]] && printf "%s" "Press Enter to continue" && read 2>/dev/null
done
ph_quit_pieh
}

function ph_do_escape_paths {

echo "$@"| sed 's/\//\\\//g;s/ /\\ /g'
return 0
}

function ph_undo_escape_paths {

echo "$@" | sed 's/\\//g'
return 0
}


function ph_unconfigure_pieh {

declare PH_i=""
declare PH_ANSWER=""
declare PH_CONF_STATE=""
declare PH_ACTION=""
declare PH_MODE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"

OPTIND="1"

while getopts urb PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in r)
		[[ -n "$PH_ACTION" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ACTION="remove" ;;
			     u)
		[[ -n "$PH_ACTION" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ACTION="unconfigure" ;;
			     b)
		[[ -n "$PH_MODE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_MODE="batch" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_ACTION" || "$#" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_ROLLBACK_USED="yes"
[[ -z "$PH_MODE" ]] && \
	PH_MODE="normal"
PH_CONF_STATE="$(ph_get_pieh_conf_state -q)"
if [[ "$PH_MODE" == "normal" ]]
then
	if [[ "$PH_CONF_STATE" == "unconfigured" && "$PH_ACTION" == "unconfigure" ]]
	then
		ph_set_result -r 0 -w -m "PieHelper is already ${PH_CONF_STATE}"
		return 0
	fi
fi
if [[ "$PH_CONF_STATE" == "configured" ]]
then
	if [[ "$PH_MODE" == "normal" ]]
	then
		printf "%2s%s\n\n" "" "This will :"
		printf "%4s%s\n" "" "- Stop all running applications"
		printf "%4s%s\n" "" "- Unconfigure the current StartApp if one is set"
		printf "%4s%s\n" "" "- Reset all application options and controller settings to default values"
		printf "%4s%s\n" "" "- Remove the controller settings"
		printf "%4s%s\n" "" "- Unintegrate all integrated applications"
		printf "%4s%s\n" "" "- Unsupport all supported applications"
		printf "%4s%s\n" "" "- Remove all base configuration files"
		printf "%4s%s\n" "" "- Remove the PATH and LD_LIBRARY_PATH extension for PieHelper"
		printf "%4s%s\n" "" "- Restore any system related settings and scripts modified by PieHelper to their original state"
		printf "%4s%s\n" "" "- Enable the graphical environment"
		[[ "$PH_ACTION" == "remove" ]] && \
			printf "%4s%s\n" "" "- Remove all files related to PieHelper (third-party packages remain installed)"
		printf "%4s%s\n\n" "" "- Reboot your system"
		while [[ "$PH_ANSWER" != @(y@(es|)|n@(o|)) ]]
		do
			[[ "$PH_COUNT" -gt "0" ]] && \
				printf "\n%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Invalid response"
			if [[ "$PH_ACTION" == "unconfigure" ]]
			then
				printf "%8s%s%s" "" "--> Continue with PieHelper unconfiguration (y/n) ? "
			else
				printf "%8s%s%s" "" "--> Continue with PieHelper removal (y/n) ? "
			fi
			read -r PH_ANSWER 2>/dev/null
			ph_screen_input "$PH_ANSWER"
			((PH_COUNT++))
		done
		ph_run_with_rollback -c true -m "$PH_ANSWER"
		if [[ "$PH_ANSWER" == n@(o|) ]]
		then
			ph_set_result -w -m "Quit at user request"
			ph_show_result
			return "$?"
		fi
	fi
	ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.unconfigure_in_progress'" || \
		return 1
	if [[ -f "${PH_FILES_DIR}/stored/10-retropie_sh" ]]
	then
		ph_run_with_rollback -c "ph_pieh_unconfigured_emul_conf" || \
			return 1
	fi
	ph_run_with_rollback -c "ph_set_app_for_start none" || \
		return 1
	ph_stop_all_running_apps || \
		return 1
	ph_set_all_options_to_default_value || \
		return 1
	ph_run_with_rollback -c "ph_unintegrate_app -a integrated" || \
		return 1
	ph_run_with_rollback -c "ph_unsupport_app -a Ctrls" || \
		return 1
	ph_run_with_rollback -c "ph_unsupport_app -a supported" || \
		return 1
	for PH_i in cont os int defaults alloweds sup
	do
		ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/$(ph_get_filename_from_shortname "$PH_i")'" || \
			return 1
	done
	for PH_i in path logind
	do
		ph_run_with_rollback -c "ph_pieh_unconfigured_${PH_i}_conf" || \
			return 1
	done
	ph_run_with_rollback -c "ph_remove_empty_file -t link -d '${PH_CONF_DIR}/distros/${PH_DISTRO.conf}'" || \
		return 1
	ph_run_with_rollback -c "ph_set_bootenv graphical.target" || \
		return 1
	if [[ "$PH_MODE" == "batch" ]]
	then
		ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.unconfigure_in_progress'" || \
			return 1
	else
		ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.unconfigure_in_progress'" || \
			return 1
	fi
fi
if [[ "$PH_ACTION" != "remove" && "$PH_BATCH" == "no" ]]
then
	printf "%s\n\n" "" "PieHelper can be reconfigured by running '${PH_SCRIPTS_DIR}/confpieh_ph.sh -c'"
	printf "%s" "Press Enter to reboot into the graphical environment"
	read -r 2>/dev/null
	"$PH_SUDO" chvt 1 2>/dev/null
	"$PH_SUDO" init 6 2>/dev/null
else
	return 0
fi
}

function ph_pieh_unconfigured_path_conf {

if [[ -f /etc/profile.d/PieHelper-path.sh ]]
then
	printf "%8s%s\n" "" "--> Removing the PATH and LD_LIBRARY_PATH extension for PieHelper"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/profile.d/PieHelper-path.sh'"
	then
		ph_add_value_to_param -p PH_CONFIGURED_STATE -v path
		ph_run_with_rollback -c true
	else
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
return 0
}

function ph_rollback_changes {

declare PH_i=""
declare PH_CMD=""
declare PH_PARAMS=""
declare PH_MOVE_SCRIPTS_REGEX=""
declare PH_RUN_SECURE=""
declare PH_RUN_GIT_COMMIT_LOCAL=""
declare PH_RUN_GIT_COMMIT_MASTER=""
declare PH_RUN_GIT_ADD_LOCAL=""
declare PH_RUN_GIT_TAG_LOCAL=""
declare PH_ROLLBACK_TIME=""
declare PH_GIT_REPO_DIR=""
declare PH_GIT_REPO_NAME=""
declare PH_GIT_REPO_ARGS=""
declare PH_GIT_REPO=""
declare PH_LINE=""
declare PH_FILE=""
declare PH_FILE_TYPE=""
declare PH_FILE_SOURCE=""
declare PH_FILE_DEST=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_USER_GROUPS=""
declare PH_APP_CMD=""
declare PH_APP_PKG=""
declare PH_APP_INST_STATE=""
declare PH_APP_STR_TTY=""
declare PH_OPTION=""
declare PH_OPTION_VALUE=""
declare PH_VAR_NAME=""
declare PH_VAR_VALUE=""
declare PH_OPT=""
declare PH_VALUE=""
declare -i PH_PARAM_INDEX="0"
declare -i PH_DATA_INDEX="0"
declare -i PH_APP_TTY="0"
declare -i PH_RET_CODE="0"
declare -i PH_PKG_FLAG="1"
declare -a PH_RUN_ACLS

PH_ROLLBACK_USED="no"
for PH_i in "${PH_DEPTH_PARAMS[@]}"
do
	if [[ "$PH_i" == PH_@(INSTALL|REMOVE)_PKGS ]]
	then
		ph_update_pkg_index
		PH_RET_CODE="$?"
		break
	fi

done
if [[ "$PH_RET_CODE" -eq "0" ]]
then
	for PH_PARAM_INDEX in $(echo -n "${!PH_DEPTH_PARAMS[*]} " | tac -s " ")
	do
		PH_RET_CODE="0"
		PH_OPT="${PH_DEPTH_PARAMS["${PH_PARAM_INDEX}"]}"
		declare -n PH_DATA_ARRAY="$PH_OPT"
		PH_DATA_INDEX="$(echo "${!PH_DATA_ARRAY[@]}" | nawk '{ \
				printf $NF \
			}')"
		PH_VALUE="${PH_DATA_ARRAY["$PH_DATA_INDEX"]}"
		case "$PH_OPT" in PH_START_APPS)
			PH_CMD="ph_do_app_action start '${PH_VALUE}'" ;;
				  PH_STOP_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_do_app_action stop '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_UNBLACKLIST_MODULES)
			PH_CMD="ph_unblacklist_kernel_module '${PH_VALUE}'" ;;
				  PH_BLACKLIST_MODULES)
			PH_CMD="ph_blacklist_kernel_module '${PH_VALUE}'" ;;
				  PH_REMOVE_RIGHTS_USERS)
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_remove_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_CREATE_RIGHTS_USERS)
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_create_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REMOVE_ACLS_USERS)
			PH_ROLLBACK_TIME="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_FILE="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_PARAMS="${PH_PARAMS} -u '${PH_APP_USER}'"
			case "$PH_ROLLBACK_TIME" in immediate)
				[[ -n "$PH_FILE" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_user_acls -p remove ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_ACLS+=("remove'${PH_APP_USER}")
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_CREATE_ACLS_USERS)
			PH_ROLLBACK_TIME="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_FILE="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_PARAMS="${PH_PARAMS} -u '${PH_APP_USER}'"
			case "$PH_ROLLBACK_TIME" in immediate)
				[[ -n "$PH_FILE" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_user_acls -p create ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_ACLS+=("create'${PH_APP_USER}")
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_GIT_COMMIT_LOCAL)
			PH_RUN_GIT_COMMIT_LOCAL="$PH_VALUE"
			PH_CMD="continue" ;;
				  PH_SET_BOOT_TTYS)
			PH_CMD="ph_set_tty_for_boot '${PH_VALUE}'" ;;
				  PH_MODIFY_APPS_SCRIPT)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_TTY="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_modify_app_script -a '${PH_APP}' -t '${PH_APP_TTY}'" ;;
				  PH_GIT_COMMIT_MASTER)
			PH_RUN_GIT_COMMIT_MASTER="$PH_VALUE"
			PH_CMD="continue" ;;
				  PH_GIT_ADD_LOCAL)
			PH_RUN_GIT_ADD_LOCAL="$PH_VALUE"
			PH_CMD="continue" ;;
				  PH_GRANT_APPS_ACCESS)
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_grant_pieh_access -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REVOKE_APPS_ACCESS)
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_revoke_pieh_access -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_FROM_SUP_FILE)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_INST_STATE="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_APP_CMD="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			for PH_i in USER INST_STATE CMD
			do
				[[ -n "$(eval "echo -n \"\$PH_APP_${PH_i}\"")" ]] && \
					PH_PARAMS="${PH_PARAMS} -$(cut -c1<<<"$PH_i" | tr "[:upper:]" "[:lower:]") '\$PH_APP_${PH_i}'"
			done
			PH_CMD="ph_remove_app_from_support_file ${PH_PARAMS}" ;;
				  PH_ADD_APPS_TO_SUP_FILE)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_INST_STATE="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_APP_CMD="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_PARAMS="-a '${PH_APP}' -u '${PH_APP_USER}' -c '${PH_APP_CMD}'"
			[[ -n "$PH_APP_INST_STATE" ]] && \
				PH_PARAMS="${PH_PARAMS} -i '${PH_APP_INST_STATE}'"
			PH_CMD="ph_add_app_to_support_file ${PH_PARAMS}" ;;
				  PH_ADD_APPS_TO_INT_FILE)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_STR_TTY="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			[[ -n "${PH_APP_STR_TTY}" ]] && \
				PH_PARAMS="${PH_PARAMS} -t '${PH_APP_STR_TTY}'"
			PH_CMD="ph_add_app_to_integration_file ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_FROM_INT_FILE)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_STR_TTY="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			[[ -n "${PH_APP_STR_TTY}" ]] && \
				PH_PARAMS="${PH_PARAMS} -t '${PH_APP_STR_TTY}'"
			PH_CMD="ph_remove_app_from_integration_file ${PH_PARAMS}" ;;
				  PH_ADD_LINES)
			PH_FILE="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_LINE="$(echo -n "$PH_VALUE" | cut -f3- -d"'")"
			PH_CMD="ph_add_line_to_file $PH_PARAMS -f '${PH_FILE}' -l '${PH_LINE}'" ;;
				  PH_REMOVE_LINES)
			PH_FILE="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_LINE="$(echo -n "$PH_VALUE" | cut -f3- -d"'")"
			PH_CMD="ph_remove_line_from_file $PH_PARAMS -f '${PH_FILE}' -l '${PH_LINE}'" ;;
				  PH_GIT_TAG_LOCAL)
			PH_RUN_GIT_TAG_LOCAL="$PH_VALUE"
			PH_CMD="continue" ;;
				  PH_REMOVE_OOS_APPS_CODE)
			PH_CMD="ph_remove_oos_app_code '${PH_VALUE}'" ;;
				  PH_CREATE_OOS_APPS_CODE)
			PH_CMD="ph_create_oos_app_code '${PH_VALUE}'" ;;
				  PH_SECURE)
			PH_ROLLBACK_TIME="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_FILE="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			case "$PH_ROLLBACK_TIME" in immediate)
				[[ -n "$PH_FILE" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_secure_pieh ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_SECURE="yes"
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_INSTALL_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_install_app -a '${PH_VALUE}' -u '${PH_APP_USER}'" ;;
				  PH_UNINSTALL_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_uninstall_app -a '${PH_VALUE}' -u '${PH_APP_USER}'" ;;
				  PH_LINK_MENUS)
			PH_CMD="ph_link_app_to_menu '${PH_VALUE}'" ;;
				  PH_UNDO_LINK_MENUS)
			if [[ -n "$PH_VALUE" ]]
			then
				PH_CMD="ph_unlink_app_from_menu '${PH_VALUE}'"
			else
				PH_CMD="ph_unlink_app_from_menu"
			fi ;;
				  PH_UNDO_SETUP_TTYS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_undo_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				  PH_SETUP_TTYS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				  PH_ENABLE_TTYS)
			PH_CMD="ph_enable_app_tty '${PH_VALUE}'" ;;
				  PH_DISABLE_TTYS)
			PH_CMD="ph_disable_app_tty '${PH_VALUE}'" ;;
				  PH_COPY_FILES)
			PH_FILE_DEST="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_FILE_SOURCE="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_copy_file $PH_PARAMS -s '${PH_FILE_SOURCE}' -d '${PH_FILE_DEST}'" ;;
				  PH_GIT_CLONE_MASTER)
			PH_GIT_REPO_DIR="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_GIT_REPO="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_GIT_REPO_NAME="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_GIT_REPO_ARGS="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_CMD="ph_git_clone_master -d '${PH_GIT_REPO_DIR}' -n '${PH_GIT_REPO_NAME}' -r '${PH_GIT_REPO}' -a '${PH_GIT_REPO_ARGS}'" ;;
				  PH_GIT_UNDO_CLONE_MASTER)
			PH_GIT_REPO_DIR="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_GIT_REPO="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_GIT_REPO_NAME="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_GIT_REPO_ARGS="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_CMD="ph_git_undo_clone_master -d '${PH_GIT_REPO_DIR}' -n '${PH_GIT_REPO_NAME}' -r '${PH_GIT_REPO}' -a '${PH_GIT_REPO_ARGS}'" ;;
				  PH_CREATE_APP_USER)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_create_app_user -a '${PH_APP}' -u '${PH_APP_USER}'" ;;
				  PH_REMOVE_APP_USER)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_remove_app_user -a '${PH_APP}' -u '${PH_APP_USER}'" ;;
				  PH_CREATE_APPS_CONF_FILE)
			PH_CMD="ph_create_app_conf_file '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_CONF_FILE)
			PH_CMD="ph_remove_app_conf_file '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_SCRIPTS)
			PH_CMD="ph_create_app_scripts '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_SCRIPTS)
			PH_CMD="ph_remove_app_scripts '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_MENUS)
			PH_CMD="ph_create_app_menus '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_MENUS)
			PH_CMD="ph_remove_app_menus '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_ALLOWEDS)
			PH_CMD="ph_create_app_alloweds '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_ALLOWEDS)
			PH_CMD="ph_remove_app_alloweds '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_DEFAULTS)
			PH_CMD="ph_create_app_defaults '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_DEFAULTS)
			PH_CMD="ph_remove_app_defaults '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_CIFS_MPT)
			PH_CMD="ph_create_app_cifs_mpt '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_CIFS_MPT)
			PH_CMD="ph_remove_app_cifs_MPT '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_ITEMS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_create_app_items -a '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_ITEMS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_remove_app_items -a '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_INSTALL_PKGS)
			PH_PKG_FLAG="0"
			PH_CMD="ph_install_pkg '${PH_VALUE}'" ;;
				  PH_REMOVE_PKGS)
			PH_PKG_FLAG="0"
			PH_CMD="ph_remove_pkg '${PH_VALUE}'" ;;
				  PH_LOAD_MODULES)
			PH_CMD="ph_load_kernel_module '${PH_VALUE}'" ;;
				  PH_UNLOAD_MODULES)
			PH_CMD="ph_unload_kernel_module '${PH_VALUE}'" ;;
				  PH_BOOTENV)
			PH_CMD="ph_set_bootenv '${PH_VALUE}'" ;;
				  PH_GROUPS)
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER_GROUPS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_set_user_group_membership -u '${PH_APP_USER}' -g '${PH_APP_USER_GROUPS}'" ;;
				PH_PIEH_VERSION)
			PH_CMD="ph_update_pieh_version '${PH_VALUE}'" ;;
				PH_STARTAPP)
			PH_CMD="ph_set_app_for_start '${PH_VALUE}'" ;;
				PH_CREATE_EMPTY_FILES)
			PH_FILE_DEST="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_FILE_TYPE="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_FILE_SOURCE="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_CMD="ph_create_empty_file -t '${PH_FILE_TYPE}' -d '${PH_FILE_DEST}' -s '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_REMOVE_EMPTY_FILES)
			PH_FILE_DEST="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_FILE_TYPE="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_remove_empty_file -t '${PH_FILE_TYPE}' -d '${PH_FILE_DEST}' ${PH_PARAMS}" ;;
				PH_UNSUP_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_CMD="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_APP_INST_STATE="$(echo -n "$PH_VALUE" | cut -f5 -d"'")"
			PH_PARAMS=""
			for PH_i in "" _USER _CMD _PKG _INST_STATE
			do
				declare -n PH_VAR="PH_APP${PH_i}"
				if [[ -n "$PH_VAR" ]]
				then
					if [[ -z "$PH_i" ]]
					then
						PH_PARAMS="-a '${PH_VAR}'"
					else
						PH_PARAMS="${PH_PARAMS} -$(cut -c2<<<"$PH_i" | tr "[:upper:]" "[:lower:]") '${PH_VAR}'"
					fi
				fi
				unset -n PH_VAR
			done
			PH_CMD="ph_unsupport_app ${PH_PARAMS}" ;;
				PH_UNINT_APPS)
			PH_CMD="ph_unintegrate_app -a '${PH_VALUE}'" ;;
				PH_INT_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_integrate_app -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				PH_SUP_APPS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_APP_CMD="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "$PH_VALUE" | cut -f4 -d"'")"
			PH_PARAMS=""
			for PH_i in "" _USER _CMD _PKG
			do
				declare -n PH_VAR="PH_APP${PH_i}"
				if [[ -n "$PH_VAR" ]]
				then
					if [[ -z "$PH_i" ]]
					then
						PH_PARAMS="-a '${PH_VAR}'"
					else
						PH_PARAMS="${PH_PARAMS} -$(cut -c2<<<"$PH_i" | tr "[:upper:]" "[:lower:]") '${PH_VAR}'"
					fi
				fi
				unset -n PH_VAR
			done
			PH_CMD="ph_support_app ${PH_PARAMS}" ;;
				PH_RESTORE_FILES)
			PH_FILE_SOURCE="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_restore_file -f '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_STORE_FILES)
			PH_FILE_SOURCE="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_store_file -f '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_STORE_OPTION)
			PH_CMD="ph_store_option '${PH_VALUE}'" ;;
				PH_RETRIEVE_STORED_OPTION)
			PH_CMD="ph_retrieve_stored_option '${PH_VALUE}'" ;;
				PH_VARIABLES)
			PH_VAR_NAME="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_VAR_VALUE="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_CMD="ph_set_variable -n '${PH_VAR_NAME}' -v '${PH_VAR_VALUE}'" ;;
				PH_OPTIONS)
			PH_APP="$(echo -n "$PH_VALUE" | cut -f1 -d"'")"
			PH_OPTION="$(echo -n "$PH_VALUE" | cut -f2 -d"'")"
			PH_OPTION_VALUE="$(echo -n "$PH_VALUE" | cut -f3 -d"'")"
			PH_CMD="ph_set_option_to_value '${PH_APP}' -r \"${PH_OPTION}'${PH_OPTION_VALUE}\"" ;;
				PH_CONFIGURED_STATE)
			PH_CMD="ph_pieh_configured_${PH_VALUE}_conf" ;;
				PH_UNCONFIGURED_STATE)
			PH_CMD="ph_pieh_unconfigured_${PH_VALUE}_conf" ;;
		esac
		unset PH_DATA_ARRAY["$PH_DATA_INDEX"]
		unset PH_DEPTH_PARAMS["${PH_ARRAY_INDEX}"]
		unset -n PH_DATA_ARRAY
		eval "$PH_CMD"
		PH_RET_CODE="$?"
		[[ "$PH_RET_CODE" -ne "0" ]] && \
			break
	done
	[[ "$PH_PKG_FLAG" -eq "0" && "$PH_DISTRO" == "Debian" ]] && \
		ph_apt_clean
fi
if [[ -n "$PH_RUN_ACLS" || -n "$PH_RUN_SECURE" || -n "$PH_RUN_GIT_ADD_LOCAL" || -n "$PH_RUN_GIT_TAG_LOCAL" || -n "$PH_RUN_GIT_COMMIT_LOCAL" || -n "$PH_RUN_GIT_COMMIT_MASTER" ]]
then
	if [[ -n "$PH_RUN_SECURE" ]]
	then
		ph_secure_pieh
	else
		if [[ "${#PH_RUN_ACLS[@]}" -gt "0" ]]
		then
			for PH_i in $(echo -n "${PH_RUN_ACLS[@]}" | tac -s " ")
			do
				ph_user_acls -q -p "$(echo -n "$PH_i" | cut -d"'" -f1)" -u $(echo -n "$PH_RUN_ACLS" | cut -d"'" -f2)
			done
		fi
	fi
	[[ "$PH_RUN_GIT_ADD_LOCAL" == "yes" ]] && \
		ph_undo_git_add_local
	[[ "$PH_RUN_GIT_TAG_LOCAL" == "yes" ]] && \
		ph_undo_git_tag_local
	[[ "$PH_RUN_GIT_COMMIT_LOCAL" == "yes" ]] && \
		ph_undo_git_commit_local
	[[ "$PH_RUN_GIT_COMMIT_MASTER" == "yes" ]] && \
		ph_git_commit_master -m "$PH_OLD_GIT_COMMIT_MSG" -v "$PH_OLD_VERSION"
fi
ph_show_result
return "$?"
}

function ph_disable_app_tty {

declare PH_TTYS="$*"
declare -i PH_APP_TTY="0"

[[ "$#" -lt "1" || "$#" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP_TTY in ${PH_TTYS}
do
        printf "%8s%s\033[32m%s\033[0m\n" "" "--> Disabling " "'tty${PH_APP_TTY}'"
	if systemctl is-disabled getty@tty1 >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
        	if ! "$PH_SUDO" systemctl disable "getty@tty${PH_APP_TTY}" >/dev/null 2>&1
		then
			ph_run_with_rollback -c false -m "Could not disable" || \
				return 1
		fi
		ph_add_value_to_param -p PH_ENABLE_TTYS -v "$PH_APP_TTY"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_copy_file {

declare PH_CMD=""
declare PH_MSG=""
declare PH_PARAMS=""
declare PH_FILE_SOURCE=""
declare PH_FILE_DEST=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"
declare -i PH_COPY_AS_ROOT="1"

OPTIND="1"

while getopts s:d:mrq PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in s)
		[[ -n "$PH_FILE_SOURCE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_SOURCE="$OPTARG" ;;
			     d)
		[[ -n "$PH_FILE_DEST" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_DEST="$OPTARG" ;;
			     r)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-r" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_COPY_AS_ROOT="0" ;;
			     q)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-q" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-q" || \
			PH_PARAMS="${PH_PARAMS} -q"
		PH_QUIESCE="0" ;;
			     m)
		[[ -n "$PH_MSG" ]] && \
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-m" || \
			PH_PARAMS="${PH_PARAMS} -m"
		PH_MSG="Moving"
		PH_CMD="mv" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE_SOURCE" || -z "$PH_FILE_DEST" || "$#" -lt "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_CMD" ]] && \
	PH_CMD="cp -p" && \
	PH_MSG="Copying"
[[ "$PH_COPY_AS_ROOT" -eq "0" ]] && \
	PH_CMD="${PH_SUDO} ${PH_CMD}"
[[ "$PH_QUIESCE" -eq "1" ]] && \
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> ${PH_MSG} '${PH_FILE_SOURCE}' to " "'${PH_FILE_DEST}'"
if ${PH_CMD} "$PH_FILE_SOURCE" "$PH_FILE_DEST" 2>/dev/null
then
	ph_add_value_to_param -p PH_COPY_FILES -v "${PH_FILE_SOURCE}'${PH_FILE_DEST}'${PH_PARAMS}"
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c true
	return 0
else
	[[ "$PH_MSG" == "Moving" ]] && \
		PH_MSG="move" || \
		PH_MSG="copy"
	ph_set_result -m "An error occurred trying to ${PH_MSG} '${PH_FILE_SOURCE}' to '${PH_FILE_DEST}'"
	if [[ "$PH_QUIESCE" -eq "1" ]]
	then
		ph_run_with_rollback -c false -m "Could not ${PH_MSG}"
	fi
	return 1
fi
}

function ph_pieh_configured_logind_conf {

declare PH_i=""
declare -i PH_VALUE="0"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Changing settings in system file " "'/etc/systemd/logind.conf'"
if [[ "$(grep -E "^NAutoVTs=${PH_PIEH_MAX_TTYS}$" /etc/systemd/logind.conf >/dev/null 2>&1 ; echo "$?")" -ne "0" && \
	"$(grep -E "^ReserveVT=1$" /etc/systemd/logind.conf >/dev/null 2>&1 ; echo "$?")" -ne "0" ]]
then
	if ph_run_with_rollback -c "ph_copy_file -q -r -s '/etc/systemd/logind.conf' -d '${PH_FILES_DIR}/stored/logind_conf'"
	then
		for PH_i in NAutoVTs ReserveVT
		do
			[[ "$PH_i" == "NAutoVTs" ]] && \
				PH_VALUE="${PH_PIEH_MAX_TTYS}" || \
				PH_VALUE="1"
			if grep -E "^${PH_i}=" /etc/systemd/logind.conf >/dev/null 2>&1
			then
				if grep -E "^${PH_i}=${PH_VALUE}$" /etc/systemd/logind.conf >/dev/null 2>&1
				then
					continue
				else
					if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=.*'"
					then
						if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=${PH_VALUE}'"
						then
							continue
						fi
					fi
				fi
			fi
			if grep -E "^#${PH_i}=" /etc/systemd/logind.conf >/dev/null 2>&1
			then
				if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/systemd/logind.conf' -l '#${PH_i}=.*'"
				then
					if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=${PH_VALUE}'"
					then
						continue
					fi
				fi
			fi
			ph_run_with_rollback -c false -m "Could not change" || \
				return 1
		done
	else
		ph_run_with_rollback -c false -m "Could not change" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v "logind"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_pieh_unconfigured_logind_conf {

[[ ! -f "${PH_FILES_DIR}/logind_conf" ]] && \
	return 0

ph_run_with_rollback -c "ph_copy_file -r -m -s '${PH_FILES_DIR}/stored/logind_conf' -d '/etc/systemd/logind.conf'" || \
	return 1
ph_add_value_to_param -p PH_CONFIGURED_STATE -v logind
return 0
}

function ph_set_option_to_value {

declare PH_OPTION=""
declare PH_APP="$1"
declare PH_i=""
declare PH_j=""
declare PH_SUFFIX=""
declare PH_OPTARG_VAR=""
declare PH_OPTARG_VAL=""
declare PH_MSG_TYPE=""
declare PH_NEWVALUE=""
declare PH_OPT_DEFS=""
declare PH_OPT_REGEX=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_LENGTH="0"
declare -i PH_NOW="0"
declare -i PH_END="0"
declare -i PH_RET_CODE="0"
declare -i PH_OLD_SET_FLAG="1"
declare -u PH_APPU="${PH_APP:0:4}"

OPTIND="2"

[[ -z "$PH_APP" ]] && \
	return 1

([[ -f "${PH_CONF_DIR}/${PH_APP}.conf" && "$#" -gt "1" ]] ; return "$?") || \
	ph_set_option_to_value PieHelper -h && \
	while getopts o:r:h PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in o)
			export PH_MSG_TYPE="Warning" ;;
			     r)
			export PH_MSG_TYPE="ERROR" ;;
			     *)
			((PH_RET_CODE++)) ;;
	esac
	if [[ "$PH_RET_CODE" -ne "0" ]]
	then
		ph_run_with_rollback -c false -m "Could not set"
		break
	fi
	PH_OLD_SET_FLAG="1"
	PH_OPTARG_VAR="$(echo -n "$OPTARG" | nawk 'BEGIN { \
			FS = "\x27" \
		} { \
			print $1 \
		}')"
	PH_OPTARG_VAL="$(echo -n "$OPTARG" | nawk 'BEGIN { \
			FS = "\x27" \
		} { \
			print $2 \
		}')"
	if [[ "$PH_APP" != "LoginScript" ]]
	then
		if ! grep -E "^${PH_OPTARG_VAR}=" "${PH_CONF_DIR}/${PH_APP}.conf" >/dev/null
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "Variable '${PH_OPTARG_VAR}' is a read-only variable (Value cannot be changed)"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set ('${PH_OPTARG_VAR}' is read-only) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
	        PH_j="PH_${PH_APPU}"
		PH_LENGTH="$(echo -n PH_"$PH_APPU" | wc -c)"
		PH_SUFFIX="$(echo -n "$PH_OPTARG_VAR" | cut -c"$((PH_LENGTH+1))"-)"
		[[ "$PH_SUFFIX" == @(_CMD_OPTS|_NUM_CTRL|_USE_CTRL) ]] && \
			PH_SUFFIX=""
		for PH_i in _CMD_OPTS _NUM_CTRL _USE_CTRL "$PH_SUFFIX"
		do
			if [[ "$(declare -p "OLD_${PH_j}${PH_i}" 2>/dev/null)" != "declare -x "* ]]
			then
				export "OLD_${PH_j}${PH_i}"="$(eval "echo -n \"\$${PH_j}${PH_i}\"")"
			else
				[[ "$PH_OPTARG_VAR" == *"${PH_i}" ]] && \
					PH_OLD_SET_FLAG="0"
			fi
			[[ "$(declare -p "PH_OLDVALUE${PH_i}" 2>/dev/null)" == "declare -n "* ]] && \
				unset -n "PH_OLDVALUE${PH_i}"
			declare -n "PH_OLDVALUE${PH_i}"="OLD_${PH_j}${PH_i}"
			[[ "$(declare -p "PH_CURVALUE${PH_i}" 2>/dev/null)" == "declare -n "* ]] && \
				unset -n "PH_CURVALUE${PH_i}"
			declare -n "PH_CURVALUE${PH_i}"="${PH_j}${PH_i}"
			if [[ "$PH_OPTARG_VAR" == *"${PH_i}" ]]
			then
				[[ "$(declare -p PH_OLDVALUE 2>/dev/null)" == "declare -n "* ]] && \
					unset -n PH_OLDVALUE
				declare -n PH_OLDVALUE="OLD_${PH_j}${PH_i}"
				[[ "$(declare -p PH_CURVALUE 2>/dev/null)" == "declare -n "* ]] && \
					unset -n PH_CURVALUE
				declare -n PH_CURVALUE="${PH_j}${PH_i}"
			fi
		done
		if [[ "$PH_OPTARG_VAL" == "$PH_CURVALUE" ]]
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
			ph_run_with_rollback -c true -m "Nothing to do"
			continue
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_PKG" ]]
		then
			if ! ph_check_pkg_validity "$PH_OPTARG_VAL"
			then
				printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
				if [[ "$PH_MSG_TYPE" == "ERROR" ]]
				then
					((PH_RET_CODE++))
					ph_set_result -m "The new value '${PH_OPTARG_VAL}' for option '${PH_OPTARG_VAR}' is invalid since '${PH_OPTARG_VAL}' is not a valid package"
				else
					printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set ('${PH_OPTARG_VAL}' is not a valid package) -> Skipping"
					ph_set_result -r 0
				fi
				continue
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_MOON_USE_CTRL" && "$PH_OPTARG_VAL" == "no" ]]
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "The new value '${PH_OPTARG_VAL}' for option '${PH_OPTARG_VAR}' is invalid since '${PH_APP}' requires at least one controller"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set ('${PH_APP}' requires at least one controller) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_MOON_CMD_OPTS" && "$(echo -n "$PH_OPTARG_VAL" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -ne "0" ]]
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "New value '${PH_OPTARG_VAL}' for option '${PH_OPTARG_VAR}' is invalid since no controller ID arguments were found"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (The value must contain controller ID arguments) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
		if grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" >/dev/null 2>&1
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Checking if the new value " "'${PH_OPTARG_VAL}'" " for option '${PH_OPTARG_VAR}' is allowed"
			PH_OPT_DEFS="$(grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" 2>/dev/null | cut -d":" -f2)"
			PH_OPT_REGEX="$(grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" 2>/dev/null | cut -d":" -f3-)"
			if [[ ${PH_OPT_REGEX} ]]
			then
				true
			else
				false
			fi
       				if [[ "$?" -ne "0" ]]
				then
					if [[ "$PH_MSG_TYPE" == "ERROR" ]]
					then
						((PH_RET_CODE++))
						ph_set_result -m "New value '${PH_OPTARG_VAL}' for option '${PH_OPTARG_VAR}' is invalid since not '${PH_OPT_DEFS}')"
					else
						printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (Invalid value since not '${PH_OPT_DEFS}') -> Skipping"
						ph_set_result -r 0
					fi
					continue
				else
					ph_run_with_rollback -c true
				fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CIFS_MPT" && -n "$(ph_get_app_cifs_mpt -a '${PH_APP}' -r)" ]]
		then
			printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$(mount 2>/dev/null | nawk -v mstring="^$(ph_get_app_cifs_mpt -a "$PH_APP" -r)$" '$3 ~ mstring { \
					print \
				} { \
					next \
				}' | wc -l)" -gt "0" ]]
			then
				if [[ "$PH_MSG_TYPE" == "ERROR" ]]
				then
					((PH_RET_CODE++))
					ph_set_result -m "The current mountpoint '$(ph_get_app_cifs_mpt -a "$PH_APP" -r)' cannot be active when changing mountpoints for '${PH_APP}'"
				else
					printf "%10s\033[31m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (The old mountpoint is still active) -> Skipping"
					ph_set_result -r 0
				fi
				continue
			fi
		fi
	fi
	printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Setting option '${PH_OPTARG_VAR}' to " "'${PH_OPTARG_VAL}'" " in '${PH_CONF_DIR}/${PH_APP}.conf'"
	PH_OPTARG_VAL="$(ph_do_escape_paths "$PH_OPTARG_VAL")"
	if ! sed -i 's/^\('"${PH_OPTARG_VAR}"'=\)\([^\t]*\)\(\t*#.*\)/\1'\'"${PH_OPTARG_VAL}"\''\3/' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null
	then
		PH_OPTARG_VAL="$(ph_undo_escape_paths "$PH_OPTARG_VAL")"
		if [[ "$PH_MSG_TYPE" == "ERROR" ]]
		then
			((PH_RET_CODE++))
			ph_set_result -m "An error occurred trying to change the value of option '${PH_OPTARG_VAR}' in '${PH_CONF_DIR}/${PH_APP}.conf' to '${PH_OPTARG_VAL}'"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set"
			ph_set_result -r 0
		fi
		continue
	fi
	PH_OPTARG_VAL="$(ph_undo_escape_paths "$PH_OPTARG_VAL")"
	if [[ "$PH_APP" != "LoginScript" ]]
	then
		PH_CURVALUE="$PH_OPTARG_VAL"
		ph_add_value_to_param -p PH_OPTIONS -v "${PH_APP}'${PH_OPTARG_VAR}'${PH_OLDVALUE}"
		ph_run_with_rollback -c true
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CIFS_MPT" ]]
		then
			if [[ -n "$(eval "echo -n \"${PH_OPTARG_VAL}\"")" && ! -d "$(eval "echo -n \"${PH_OPTARG_VAL}\"")" ]]
			then
				if ! ph_run_with_rollback -c "ph_create_app_cifs_mpt '${PH_APP}'"
				then
					((PH_RET_CODE++))
					break
				fi
			fi
			if [[ -n "$(eval "echo -n \"${PH_OLDVALUE}\"")" && -d "$(eval "echo -n \"${PH_OLDVALUE}\"")" && \
				"$("$PH_SUDO" find "$(eval "echo -n \"${PH_OLDVALUE}\"")" -maxdepth 1 ! -wholename "$(eval "echo -n \"${PH_OLDVALUE}\"")" 2>/dev/null | wc -l)" -eq "0" ]]
			then
				if ! ph_run_with_rollback -c "ph_remove_empty_file -r -t directory -d '$(eval "echo -n \"${PH_OLDVALUE}\"")'"
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_NUM_CTRL" && "$(echo -n "$PH_CURVALUE_CMD_OPTS" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -eq "0" ]]
		then
			PH_END="$PH_OPTARG_VAL"
			PH_NOW="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk 'BEGIN { \
					count=0 \
				} { \
					for (i=1;i<=NF;i++) { \
						if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
							count++ \
						} \
					} \
				} END { \
					print count \
				}' 2>/dev/null)"
			if [[ "$PH_END" -ne "$PH_NOW" ]]
			then
				if [[ "$PH_NOW" -gt "$PH_END" ]]
				then
					PH_NEWVALUE="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk -v curval="$PH_NOW" 'BEGIN { \
							ORS = \"\" ; \
							compare = "/dev/input/eventPH_CTRL"curval \
						} { \
							for (i=1;i<=NF;i++) { \
								if ($(i+1) !~ compare && $i !~ compare) { \
									print $i ; \
									if (i<(NF-2)) { \
										print \" \" \
									} \
								} \
							} \
						}' 2>/dev/null)"
					while [[ "$((PH_NOW-1))" -gt "$PH_END" ]]
					do
						PH_NOW="$(echo -n "$PH_NEWVALUE" | nawk 'BEGIN { \
								count=0 \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
										count++ \
									} \
								} \
							} END { \
								print count \
							}' 2>/dev/null)"
						PH_NEWVALUE="$(echo -n "$PH_NEWVALUE" | nawk -v curval="$PH_NOW" 'BEGIN { \
								ORS = \"\" ; \
								compval = "/dev/input/eventPH_CTRL"curval \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($(i+1) !~ compval && $i !~ compval) { \
										print $i ; \
										if (i<(NF-2)) { \
											print \" \" \
										} \
									} \
								} \
							}' 2>/dev/null)"
					done
				else
					PH_NEWVALUE="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk -v curval="$PH_NOW" 'BEGIN { \
							ORS = \"\" ; \
							ind = 0 ; \
							compval = "/dev/input/eventPH_CTRL"curval ; \
							printval = "/dev/input/eventPH_CTRL"(curval+1) \
						} { \
							for (i=1;i<=NF;i++) { \
								if ($(i+1) ~ compval) { \
									param = $i ; \
									ind = i ; \
									print $i \" \" \
								} else { \
									if (i==NF) { \
										if (i==(ind+1)) { \
											print $i \" \" param \" \" printval \
										} else { \
											print $i \
										} \
									} else { \
										if (i==(ind+1) && ind>0) { \
											print $i \" \" param \" \" printval \" \" \
										} else { \
											print $i \" \" \
										} \
									} \
								} \
							} \
						}' 2>/dev/null)"
					while [[ "$((PH_NOW+1))" -lt "$PH_END" ]]
					do
						PH_NOW="$(echo -n "$PH_NEWVALUE" | nawk 'BEGIN { \
								count=0 \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
										count++ \
									} \
								} \
							} END { \
								print count \
							}' 2>/dev/null)"
						PH_NEWVALUE="$(echo -n "$PH_NEWVALUE" | nawk -v curval="$PH_NOW" 'BEGIN { \
								ORS = \"\" ; \
								ind = 0 ; \
								compval = "/dev/input/eventPH_CTRL"curval ; \
								printval = "/dev/input/eventPH_CTRL"(curval+1) \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($(i+1) ~ compval) { \
										param = $i ; \
										ind = i ; \
										print $i \" \" \
									} else { \
										if (i==NF) { \
											if (i==(ind+1)) { \
												print $i \" \" param \" \" printval \
											} else { \
												print $i \
											} \
										} else { \
											if (i==(ind+1) && ind>0) { \
												print $i \" \" param \" \" printval \" \" \
											} else { \
												print $i \" \" \
											} \
										} \
									} \
								} \
							}' 2>/dev/null)"
					done
				fi
				if ! ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_CMD_OPTS'${PH_NEWVALUE}\""
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CMD_OPTS" && "$(echo -n "$PH_OPTARG_VAL" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -eq "0" ]]
		then
			PH_NEWVALUE="$(echo -n "$PH_OPTARG_VAL" | nawk 'BEGIN { \
					count=0 \
				} { \
					for (i=1;i<=NF;i++) { \
						if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
							count++ \
						} \
					} \
				} END { \
					print count \
				}' 2>/dev/null)"
			if [[ "$PH_CURVALUE_NUM_CTRL" != "$PH_NEWVALUE" ]]
			then
				if ! ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_NUM_CTRL'${PH_NEWVALUE}\""
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_PKG" ]]
		then
			if ph_check_object_existence -q -o sup
			then
				if ph_get_pkg_inst_state "$PH_OPTARG_VAL"
				then
					if ! ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PI
					then
						((PH_RET_CODE++))
						break
					fi
				else
					if ! ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PA
					then
						((PH_RET_CODE++))
						break
					fi
				fi
			fi
		fi
		if [[ "$PH_OLD_SET_FLAG" -eq "1" ]]
		then
			export "OLD_${PH_OPTARG_VAR}"="$PH_OPTARG_VAL"
		fi
	else
		ph_add_value_to_param -p PH_OPTIONS -v "${PH_APP}'${PH_OPTARG_VAR}'"
		ph_run_with_rollback -c true
	fi
done
[[ "$OPTIND" -eq "2" ]] && \
	PH_RET_CODE="1"
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"
if [[ "$PH_APP" != "LoginScript" ]]
then
	if [[ "$PH_OLD_SET_FLAG" -eq "1" ]]
	then
		unset "OLD_${PH_OPTARG_VAR}" "OLD_PH_${PH_APPU}_NUM_CTRL" "OLD_PH_${PH_APPU}_USE_CTRL" "OLD_PH_${PH_APPU}_CMD_OPTS"
	fi
	unset -n PH_OLDVALUE PH_CURVALUE PH_OLDVALUE_CMD_OPTS PH_OLDVALUE_USE_CTRL PH_OLDVALUE_NUM_CTRL PH_CURVALUE_CMD_OPTS PH_CURVALUE_USE_CTRL PH_CURVALUE_NUM_CTRL
	[[ -n "$PH_SUFFIX" ]] && \
		unset -n "PH_OLDVALUE${PH_SUFFIX}" "PH_CURVALUE${PH_SUFFIX}"
fi
return "$PH_RET_CODE"
}

function ph_mount_cifs_share {

declare PH_APP="$1"
[[ -z "$PH_APP" ]] && return 1
declare PH_i=""
declare -u PH_APPU="${PH_APP:0:4}"
declare -i PH_LENGTH="$(echo -n "$PH_APPU" | wc -c)"
declare -i PH_RET_CODE="0"
for PH_i in "PH_${PH_APPU}_CIFS_USER" "PH_${PH_APPU}_CIFS_PASS" "PH_${PH_APPU}_CIFS_SRV" "PH_${PH_APPU}_CIFS_DIR" "PH_${PH_APPU}_CIFS_SUBDIR" "PH_${PH_APPU}_CIFS_MPT"
do
	if eval [[ -n \"\$OLD_"$PH_i"\" ]]
	then
		declare -n TMP_"$(echo -n "$PH_i" | cut -c"$((PH_LENGTH+5))"-)"=OLD_"$PH_i"
	else
		declare -n TMP_"$(echo -n "$PH_i" | cut -c"$((PH_LENGTH+5))"-)"="$PH_i"
	fi
done

TMP_CIFS_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
printf "%8s%s%s%s%s\n" "" "--> Mounting '" "$TMP_CIFS_DIR" "$TMP_CIFS_SUBDIR" "' cifs share from server '$TMP_CIFS_SRV' to '$(eval echo -n "$TMP_CIFS_MPT")'"
if [[ -z "$TMP_CIFS_USER" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not determine run account"
	PH_RET_CODE="1"
fi
if [[ "$PH_RET_CODE" -eq "0" ]]
then
	for PH_i in _CIFS_USER _CIFS_PASS _CIFS_SRV _CIFS_DIR _CIFS_SUBDIR _CIFS_MPT
	do
		eval [[ -z \"\$TMP"$PH_i"\" ]] && printf "%10s\033[31m%s%s%s%s\033[0m\n" "" "ERROR : Required variable 'PH_" "$PH_APPU" "$PH_i" "' is unset" && PH_RET_CODE="1" && break
	done
fi
if [[ "$PH_RET_CODE" -eq "0" ]]
then
	"$PH_SUDO" mount -t cifs -o username="$TMP_CIFS_USER" -o password="$TMP_CIFS_PASS" -o rw,uid="$TMP_CIFS_USER",gid="$PH_RUN_USER",file_mode="0770",dir_mode="0770" \
					"//$TMP_CIFS_SRV$(eval echo -n "$TMP_CIFS_DIR""$TMP_CIFS_SUBDIR")" "$(eval echo -n "$TMP_CIFS_MPT")" 2>/dev/null
	[[ "$?" -ne "0" ]] && printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not mount share" && PH_RET_CODE="1" || \
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
unset -n TMP_CIFS_USER TMP_CIFS_PASS TMP_CIFS_SRV TMP_CIFS_DIR TMP_CIFS_SUBDIR TMP_CIFS_MPT
ph_set_result -r "$PH_RET_CODE"
return "$PH_RET_CODE"
}

function ph_umount_cifs_share {

declare PH_APP="$1"
[[ -z "$PH_APP" ]] && return 1
declare -i PH_RET_CODE="0"
declare -u PH_APPU="${PH_APP:0:4}"
declare -n TMP_CIFS_MPT="PH_${PH_APPU}_CIFS_MPT"

printf "%8s%s\n" "" "--> Unmounting '$(eval echo -n "$TMP_CIFS_MPT")' cifs share"
"$PH_SUDO" umount -f "$(eval echo -n "$TMP_CIFS_MPT")" 2>/dev/null
if [[ "$?" -ne "0" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not unmount share"
	PH_RET_CODE="1"
else
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
unset -n TMP_CIFS_MPT
ph_set_result -r "$PH_RET_CODE"
return "$PH_RET_CODE"
}

function ph_screen_input {

if [[ "$(echo "$*" | sed 's/[ ,/.]//g')" == *+([![:word:]])* ]]
then
	ph_set_result -a -m "Invalid input characters detected"
fi
return 0
}

function ph_pieh_unconfigured_emul_conf {

declare PH_i=""
declare PH_MSG="configuration"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -e "${PH_FILES_DIR}/stored/10-retropie_sh" && ! -e "${PH_FILES_DIR}/stored/autologin_conf" ]]
then
	return 0
else
	for PH_i in 10-retropie_sh autologin_conf
	do
		if [[ "$PH_i" == "autologin_conf" ]]
		then
			PH_MSG="tty ${PH_MSG}"
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Restoring Emulationstation " "${PH_MSG}"
			if [[ ! -d /etc/systemd/system/getty@tty1.service.d ]]
			then
				if ! ph_run_with_rollback -c "ph_create_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
				then
					ph_run_with_rollback -c false -m "Could not restore" || \
						return 1
				fi
			fi
			if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '${PH_FILES_DIR}/stored/${PH_i}' -d '/etc/systemd/system/getty@tty1.service.d/${PH_i//_/\.}'"
			then
				if ph_run_with_rollback -c "ph_enable_app_tty 1"
				then
					ph_run_with_rollback -c true && \
						continue
				fi
			fi
		else
			PH_MSG="LoginScript ${PH_MSG}"
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Restoring Emulationstation " "${PH_MSG}"
			if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '${PH_FILES_DIR}/stored/${PH_i}' -d '/etc/profile.d/$(sed 's/_/\./g' <<<"$PH_i")'"
			then
				ph_run_with_rollback -c true && \
					continue
			fi
		fi
		ph_run_with_rollback -c false -m "Could not restore" || \
			return 1
	done
fi
ph_add_value_to_param -p PH_CONFIGURED_STATE -v emul
return 0
}

function ph_pieh_configured_emul_conf {

declare PH_i=""
declare PH_MSG="configuration"

[[ ! -f /etc/profile.d/10-retropie.sh && ! -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ]] && \
	return 0
[[ ( -f /etc/profile.d/10-retropie.sh && ! -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ) || \
	( ! -f /etc/profile.d/10-retropie.sh && -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ) ]] && \
	return 1
for PH_i in 10-retropie.sh autologin.conf
do
	if [[ "$PH_i" == "autologin.conf" ]]
	then
		PH_MSG="TTY ${PH_MSG}"
		printf "%8s%s\033[32m%s\033[0m\n" "" "--> Backing up Emulationstation " "StartApp ${PH_MSG}"
		if ph_run_with_rollback -c "ph_copy_file -r -q -m -s '/etc/systemd/system/getty@tty1.service.d/${PH_i}' -d '${PH_FILES_DIR}/stored/$(sed 's/\./_/g' <<<"$PH_i")'"
		then
			if ph_run_with_rollback -c "ph_remove_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
			then
				if systemctl is-enabled getty@tty1 >/dev/null 2>&1
				then
					if ph_run_with_rollback -c "ph_disable_app_tty 1"
					then
						ph_run_with_rollback -c true
						continue
					fi
				fi
			fi
		fi
	else
		PH_MSG="LoginScript ${PH_MSG}"
		printf "%8s%s\033[32m%s\033[0m\n" "" "--> Backing up Emulationstation " "StartApp ${PH_MSG}"
		if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '/etc/profile.d/${PH_i}' -d '${PH_FILES_DIR}/stored/$(sed 's/\./_/g' <<<"$PH_i")'"
		then
			ph_run_with_rollback -c true
			continue
		fi
	fi
	printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Could not backup configuration"
	ph_run_with_rollback -c false || \
		return 1
done
ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v emul
return 0
}

function ph_show_emul_info {

declare PH_APP_USER="$1"

[[ -z "$PH_APP_USER" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n\n" "" "--> Displaying info for Emulationstation (RetroPie)"
printf "%12s%s\n\n" "" "Game ROMS can either :"
printf "%14s%s\n" "" "- be copied locally under the directory '$(ph_get_cifs_mpt -a Emulationstation -r)'"
printf "%14s%s\n" "" "- be provided over CIFS by configuring the appropriate Emulationstation options"
printf "%12s%s\n\n" "" "Make sure to be logged in as user '${PH_APP_USER}' whenever you want to run proprietary Emulationstation tools !"
printf "%14s%s\n" "" "- Any tools delivered by Emulationstation are considered proprietary"
printf "%14s%s\n\n" "" "- Failure to do so could lead to permission issues requiring you to uninstall and reinstall Emulationstation"
ph_run_with_rollback -c true && \
	return $?
}

function ph_install_app {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_PKG=""
declare PH_APP_STATE=""
declare PH_OPTION=""
declare PH_EMUL_HOME=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -u PH_APPU=""

OPTIND="1"

while getopts a:u: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG"
                PH_APPU="${PH_APP:0:4}" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || ( -z "$PH_APP_USER" && "$#" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
if ph_check_app_state_validity -a "$PH_APP" -q -s
then
	printf "%8s%s\n" "" "--> Checking application state of '${PH_APP}'"
	ph_run_with_rollback -c true -m "${PH_APP_STATE} (Nothing to do)" && \
		return 0
fi
ph_update_pkg_index || \
	return 1
printf "%8s%s\n" "" "--> Determining '${PH_APP}' package"
[[ -z "$PH_APP_PKG" ]] && \
	PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
if [[ -n "$PH_APP_PKG" ]]
then
	ph_run_with_rollback -c true -m "$PH_APP_PKG"
	ph_run_with_rollback -c "ph_install_pkg '${PH_APP_PKG}'" || \
		return 1
	[[ "$PH_DISTRO" == "Debian" ]] && \
		ph_apt_clean
	if ph_check_object_existence -q -o sup
	then
		ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PI || \
			return 1
	fi
	if [[ -z "$PH_APP_USER" ]]
	then
		ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'"
	else
		ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_USER}"
	fi
	return 0
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine"
	ph_set_result -r 0
fi
printf "%8s%s\n" "" "--> Attempting unpackaged installation"
case "$PH_APP" in Moonlight)
		ph_run_with_rollback -c true -m "$PH_APP"
		cd ~ >/dev/null 2>&1
		"$PH_SUDO" rm -r moonlight-embedded >/dev/null 2>&1
		"$PH_SUDO" rm "/var/tmp/${PH_APP}.compile" "/var/tmp/${PH_APP}.build" >/dev/null 2>&1
		ph_run_with_rollback -c "ph_git_clone_master -n 'moonlight-embedded' -d '${HOME}' -r 'https://github.com/irtimmer/moonlight-embedded.git'" || \
			return 1
		printf "%8s%s\n" "" "--> Configuring source"
		if cd ~/moonlight-embedded >/dev/null 2>&1
		then
			if git submodule update --init >/dev/null 2>&1
			then
				if mkdir build >/dev/null 2>&1
				then
					if cd build >/dev/null 2>&1
					then
						ph_run_with_rollback -c true
						printf "%8s%s\n" "" "--> Generating '${PH_APP}' build (This may take a while)"
						if ! cmake ../ >"/var/tmp/${PH_APP}.build" >/dev/null 2>&1
						then
							ph_set_result -m "Could not generate a build for '${PH_APP}' (Logfile is '/var/tmp/${PH_APP}.build')"
							ph_run_with_rollback -c false -m "Could not generate"
							printf "%8s%s\n" "" "--> Displaying build log (Press 'q' to quit)"
							sleep 2
							if less "/var/tmp/${PH_APP}.build" 2>/dev/null
							then
								ph_run_with_rollback -c true
							else
								ph_run_with_rollback -c false -m "Could not display"
							fi
							cd ~ >/dev/null 2>&1
							return 1
						fi
						ph_run_with_rollback -c true -m "Built in '${HOME}/moonlight-embedded/build'"
						printf "%8s%s\n" "" "--> Compiling '${PH_APP}' (This may take a while)"
						if ! make >"/var/tmp/${PH_APP}.compile" >/dev/null 2>&1
						then
							ph_set_result -m "Could not compile '${PH_APP}' (Logfile is '/var/tmp/${PH_APP}.compile')"
							ph_run_with_rollback -c false -m "Could not compile"
							printf "%8s%s\n" "" "--> Displaying compilation log (Press 'q' to quit)"
							sleep 2
							if less "/var/tmp/${PH_APP}.compile" 2>/dev/null
							then
								ph_run_with_rollback -c true
							else
								ph_run_with_rollback -c false -m "Could not display"
							fi
							cd ~ >/dev/null 2>&1
							return 1
						fi
						ph_run_with_rollback -c true -m "Build log is '/var/tmp/${PH_APP}.generate' and compilation log is '/var/tmp/${PH_APP}.compile'"
						printf "%8s%s\n" "" "--> Installing files"
						if "$PH_SUDO" make install >/dev/null 2>&1
						then
							ph_run_with_rollback -c true
							if ph_check_object_existence -q -o sup
							then
								ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v UI || \
									return 1
							fi
							if [[ -z "$PH_APP_USER" ]]
							then
								ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'"
							else
								ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_USER}"
							fi
							return 0
					
						else
							ph_set_result -m "Could not deploy the compiled version of '${PH_APP}'"
						fi
					else
						ph_set_result -m "Could not change directory to '${HOME}/moonlight-embedded/build'"
					fi
				else
					ph_set_result -m "Could not create build directory '${HOME}/moonlight-embedded/build'"
				fi
			else
				ph_set_result -m "Could not clone submodule(s) for repository 'moonlight-embedded'"
			fi
		else
			ph_set_result -m "Could not change directory to '${HOME}/moonlight-embedded'"
		fi ;;
	 Emulationstation)
		ph_run_with_rollback -c true -m "$PH_APP"
		PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
		printf "%8s%s\n" "" "--> Checking required '${PH_APP}' info"
		for PH_i in APP_USER EMUL_HOME
		do
			if [[ -z "$(eval "echo -n \"\$PH_${PH_i}\"")" ]]
			then
				case "$PH_i" in APP_USER)
					ph_set_result -m "Could not determine user account for '${PH_APP}'" ;;
						EMUL_HOME)
					ph_set_result -m "Could not determine home directory of user '${PH_APP_USER}'" ;;
				esac
				ph_run_with_rollback -c false -m "Could not determine" || \
					return 1
			else
				if [[ "$PH_i" == "APP_USER" ]]
				then
					PH_EMUL_HOME="$(getent passwd "$PH_APP_USER" 2>/dev/null | head -1 | cut -d':' -f6)"
				fi
			fi
		done
		ph_run_with_rollback -c true
		ph_run_with_rollback -c "ph_grant_pieh_access -u '${PH_APP_USER}'" || \
			return 1
		if cd "$PH_EMUL_HOME" >/dev/null 2>&1
		then
			"$PH_SUDO" rm -r RetroPie-Setup >/dev/null 2>&1
			ph_run_with_rollback -c "ph_git_clone_master -r 'https://github.com/RetroPie/RetroPie-Setup.git' -d '${PH_EMUL_HOME}' -n 'RetroPie-Setup' -a '--depth=1'" || \
				return 1
			printf "%8s%s\n\n" "" "--> Configuring '${PH_APP}' setup script"
			if "$PH_SUDO" chown -R "${PH_APP_USER}:$("$PH_SUDO" id -gn "$PH_APP_USER" 2>/dev/null)" "${PH_EMUL_HOME}/RetroPie-Setup" 2>/dev/null
			then
				if "$PH_SUDO" chmod +x "${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh" >/dev/null 2>&1
				then
					ph_run_with_rollback -c true
					printf "%8s%s\n\n" "" "--> Executing '${PH_APP}' setup script"
					printf "%10s%s\n" "" "- The setup script will do a basic installation of '${PH_APP}'"
					printf "%10s%s\n" "" "- Note that running basic installation could take up to 30 minutes depending on system specs"
					printf "%10s%s\n" "" "- StartApp configuration from this script will be replaced by StartApp configuration from PieHelper"
					printf "%10s%s\n" "" "- Exit the script normally after basic installation completes and '${PH_APP}' installation will resume"
					printf "%10s%s" "" "- Press Enter to continue"
					read -r 2>/dev/null
					clear
					if "$PH_SUDO" -E -u "$PH_APP_USER" sh -c "${PH_SUDO} ./retropie_setup.sh"
					then
						clear
						printf "%8s%s\n\n" "" "--> Executing '${PH_APP}' setup script"
						ph_run_with_rollback -c true -m "Success"
						if [[ -f "${PH_CONF_DIR}/${PH_APP}.conf" ]]
						then
							ph_autoconf_emul_base || \
								return 1
						fi
						if [[ -f /etc/profile.d/10-retropie.sh ]]
						then
							ph_run_with_rollback -c "ph_pieh_configured_emul_conf" || \
								return 1
						fi
						if ph_check_object_existence -q -o sup
						then
							ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v UI || \
								return 1
						fi
						ph_show_emul_info "$PH_APP_USER"
						ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_USER}"
						cd ~ >/dev/null 2>&1
						return 0
					else
						ph_set_result -m "An error occured running setup script '${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh' as '${PH_APP_USER}'"
					fi
				else
					ph_set_result -m "Could not set execute permission on '${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh'"
				fi
			else
				ph_set_result -m "Could not recursively set ownership of '${PH_EMUL_HOME}/RetroPie-Setup' to '${PH_APP_USER}:$("$PH_SUDO" id -gn "$PH_APP_USER" 2>/dev/null)'"
			fi
		else
			ph_set_result -m "Could not change directory to '${PH_EMUL_HOME}'"
		fi ;;
	*)
		ph_set_result -m "Unpackaged installation is not supported for '${PH_APP}' (Set '${PH_APP}' option 'PH_${PH_APPU}_PKG_NAME' to the correct package name and try again)" ;;
esac
cd ~ >/dev/null 2>&1
ph_run_with_rollback -c false -m "Could not complete installation" || \
	return 1
}

function ph_autoconf_emul_base {

declare PH_APP="Emulationstation"
declare PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
declare PH_EMUL_HOME="$(getent passwd "$PH_APP_USER" 2>/dev/null | cut -d':' -f6)"
declare PH_EMUL_DIR_INIT=""
declare PH_EMUL_SETUP_DIR_INIT=""

printf "%8s%s\n" "" "--> Determining '${PH_APP}' base directory"
if [[ -f /etc/profile.d/10-retropie.sh ]]
then
	PH_EMUL_DIR_INIT="$(nawk -F'"' '$1 ~ /bash/ { \
			print $2 }' /etc/profile.d/10-retropie.sh 2>/dev/null)"
	if [[ -n "$PH_EMUL_DIR_INIT" ]]
	then
		PH_EMUL_DIR_INIT="${PH_EMUL_DIR_INIT%%/configs*}"
		printf "%10s\033[32m%s\033[0m%s\n" "" "OK : " "'${PH_EMUL_DIR_INIT}'"
	fi
else
	if [[ -d /opt/retropie ]]
	then
		PH_EMUL_DIR_INIT="/opt/retropie"
		printf "%10s\033[32m%s\033[0m%s\n" "" "OK : " "'${PH_EMUL_DIR_INIT}'"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine (Set '${PH_APP}' option 'PH_EMUL_DIR' manually using 'confopts_ph.sh' or the PieHelper menu"
	fi
	ph_set_result -r 0
fi
printf "%8s%s\n" "" "--> Determining '${PH_APP}' setup directory (This may take a while)"
if [[ -d "${PH_EMUL_HOME}/RetroPie" ]]
then
	PH_EMUL_SETUP_DIR_INIT="${PH_EMUL_HOME}/RetroPie"
else
	PH_EMUL_SETUP_DIR_INIT="$("$PH_SUDO" find / -type d ! -fstype nfs -name RetroPie 2>/dev/null)"
fi
if [[ -n "$PH_EMUL_SETUP_DIR_INIT" ]]
then
	printf "%10s\033[32m%s\033[0m%s\n" "" "OK : " "'${PH_EMUL_SETUP_DIR_INIT}'"
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine (Set '${PH_APP}' option 'PH_EMUL_SETUP_DIR' manually using 'confopts_ph.sh' or the PieHelper menu"
fi
ph_set_result -r 0
if [[ -n "$PH_EMUL_DIR_INIT" ]]
then
	ph_run_with_rollback -c "ph_set_option_to_value ${PH_APP} -r \"PH_EMUL_DIR'${PH_EMUL_DIR_INIT}\"" || \
		return 1
fi
if [[ -n "$PH_EMUL_SETUP_DIR_INIT" ]]
then
	ph_run_with_rollback -c "ph_set_option_to_value ${PH_APP} -r \"PH_EMUL_SETUP_DIR'${PH_EMUL_SETUP_DIR_INIT}\"" || \
		return 1
fi
return 0
}

function ph_uninstall_app {

declare PH_APP=""
declare PH_OPTION=""
declare PH_APP_PKG=""
declare PH_APP_INST_STATE=""
declare PH_PATH=""
declare PH_i=""
declare PH_APP_CMD=""
declare PH_APP_USER=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -l PH_APPL=""
declare -u PH_APPU=""

OPTIND="1"

while getopts a: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
                PH_APP="$OPTARG"
		PH_APPU="${PH_APP:0:4}"
		PH_APPL="${PH_APP:0:4}" ;;
        esac
done

OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

if [[ "$PH_APP" == "PieHelper" ]]
then
	ph_unconfigure_pieh -r || \
		return 1
	cd "$PH_MAIN_DIR"/..
	"$PH_SUDO" rm -r PieHelper 2>/dev/null
	printf "%s\n" "" "Sorry to see you go"
	printf "%s\n\n" "" "Thank you for using PieHelper !"
	printf "%s" "Press Enter to reboot into the graphical environment"
	read 2>/dev/null
	"$PH_SUDO" chvt 1
	"$PH_SUDO" init 6
fi
PH_APP_TTY="$(nawk -v app=^"$PH_APP"$ '$1 ~ app && $3 !~ /^-$/ { print $3 }' "$PH_CONF_DIR"/integrated_apps)"
PH_APP_USER="$(nawk -v app=^"$PH_APP"$ '$1 ~ app { print $2 }' "$PH_CONF_DIR"/integrated_apps)"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
PH_APP_CMD="$(sed "s/#PH_TTY#/""$PH_APP_TTY""/" <<<"$PH_APP_CMD")"
[[ "$PH_APP" == "Bash" ]] && PH_APP_CMD="bash"
if pgrep -t tty"$PH_APP_TTY" -f "$PH_APP_CMD" >/dev/null
then
	"$PH_SCRIPTS_DIR"/stop"$PH_APPL".sh
fi
printf "\033[36m%s\033[0m\n" "- Running prechecks"
printf "%8s%s\n" "" "--> Checking if application is 'Bash'"
if [[ "$PH_APP" == "Bash" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : (Yes) -> Skipping package removal"
else
	printf "%10s%s\n" "" "OK (No)"
	printf "%8s%s\n" "" "--> Checking dependencies"
	if [[ "$PH_APP" == "X11" ]] && (ph_check_state_validity -a "Kodi" -i >/dev/null)
	then
		printf "%10s%s\n" "" "ERROR : Could not remove app ('Kodi' is dependent)"
		printf "%2s%s\n\n" "" "FAILED"
		return 1
	else
		printf "%10s%s\n" "" "OK (None)"
	fi
fi
printf "%8s%s\n" "" "--> Checking if configured as the default application to start on system boot"
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Yes -> Unconfiguring"
	printf "%2s%s\n\n" "SUCCESS"
	! ph_set_app_for_start none && printf "%2s%s\n\n" "" "FAILED" && return 1
else
	printf "%10s%s\n" "" "OK (No)"
	printf "%2s%s\n\n" "" "SUCCESS"
fi
printf "\033[36m%s\033[0m\n" "- Removing $PH_APP from PieHelper"
if [[ "$PH_APP" != "Bash" ]]
then
	printf "%8s%s\n" "" "--> Checking '$PH_APP' install state"
	PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
	case "$PH_APP_INST_STATE" in PI)
		printf "%10s%s\n" "" "OK (Yes)"
		PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
		ph_update_pkg_index || \
			return 1
		if ! ph_run_with_rollback -c "ph_remove_pkg '${PH_APP_PKG}'"
		then
			return 1
		else
			[[ "$PH_DISTRO" == "Debian" ]] && \
				ph_apt_clean
			printf "%s\n" "- Cleaning up"
		fi ;;
				     PA|UA)
		ph_run_with_rollback -c true -m "Nothing to do" && \
			return "$?" ;;
				     *)
		printf "%10s%s\n" "" "OK (No)"
		printf "%8s%s\n" "" "--> Attempting packageless removal"
		case "$PH_APP" in Moonlight)
			printf "%10s%s\n" "" "OK ('$PH_APP')"
			printf "%8s%s\n" "" "--> Checking for '$PH_APP' build repository at default location"
			if [[ ! -d "$HOME"/moonlight-embedded ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
				printf "%8s%s\n" "" "--> Locating '$PH_APP' build repository"
				PH_PATH=`$PH_SUDO find / -type d ! -fstype nfs -name moonlight-embedded 2>/dev/null`
				[[ "$?" -ne "0" ]] && printf "%10s%s\n" "" "ERROR : Could not locate repository" && return 1
			else
				printf "%10s%s\n" "" "OK (Found)"
				PH_PATH="$HOME/moonlight-embedded"
			fi
			cd "$PH_PATH"/build
			printf "%8s%s\n" "" "--> Removing files from final location"
			cat install_manifest.txt 2>/dev/null | xargs -I '{}' "$PH_SUDO" rm {} >/dev/null 2>&1
			printf "%10s%s\n" "" "OK"
			cd "$HOME"
			printf "%8s%s\n" "" "--> Removing build repository"
			"$PH_SUDO" rm -r "$PH_PATH" 2>/dev/null
			printf "%10s%s\n" "" "OK" ;;
				  Emulationstation)
			printf "%10s%s\n" "" "OK ($PH_APP)"
			printf "%8s%s\n" "" "--> Checking for $PH_APP setup script at default location"
			if [[ ! -f "$PH_EMUL_SETUP_DIR"-Setup/retropie_setup.sh ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
				printf "%8s%s\n" "" "--> Locating '$PH_APP' setup script"
				PH_PATH="$("$PH_SUDO" find / -type f -perm -o=x ! -fstype nfs -name retropie_setup.sh 2>/dev/null)"
				[[ "$?" -ne "0" ]] && printf "%10s%s\n" "" "ERROR : Could not locate script" && return 1
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
				PH_PATH="${PH_PATH%/*}"
			else
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
				PH_PATH="$PH_EMUL_SETUP_DIR"-Setup
			fi
			ph_set_option_to_value "$PH_APP" -r "PH_EMUL_DIR'" -r "PH_EMUL_SETUP_DIR'" || (printf "%2s%s\n" "" "FAILED" ; return 1) || return 1
			printf "%8s%s\033[32m\n\n" "" "--> Executing $PH_APP setup script"
			printf "%12s%s\n" "" "- Use this setup script to do an uninstall of $PH_APP"
			printf "%12s%s\n\n" "" "- Exit the script normally after it finishes and removal from PieHelper will resume"
			printf "%12s%s" "" "Press Enter to continue"
			read 2>/dev/null
			printf "\033[0m%10s\033[32m%s\033[0m\n" "" "OK"
			printf "%2s%s\n" "" "SUCCESS"
			clear
			"$PH_SUDO" "$PH_PATH"/retropie_setup.sh
			printf "%s\n" "- Cleaning up"
			"$PH_SUDO" rm -r "$PH_PATH" 2>/dev/null ;;
		esac ;;
	esac
fi
if [[ "$PH_APP" == "Kodi" ]]
then
	printf "%8s%s\n" "" "--> Removing 'Kodi' preferences directory '`eval echo -n ~\"$PH_APP_USER\"`/.kodi'"
	"$PH_SUDO" rm -r `eval echo -n ~"$PH_APP_USER"`/.kodi 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
for PH_i in $(nawk -F'=' 'BEGIN { ORS = " " } $1 ~ /^PH_/ { print $1 }' "$PH_CONF_DIR"/"$PH_APP".conf 2>/dev/null)
do
	ph_set_option_to_default_value "$PH_i" || PH_RESULT="PARTIALLY FAILED"
done
[[ "$PH_APP_TTY" -ne "1" ]] && ph_undo_setup_tty -a "$PH_APP" -t "$PH_APP_TTY" -u "$PH_APP_USER"
ph_remove_app_from_integration_file -a "$PH_APP" || \
	PH_RESULT="PARTIALLY FAILED"
if [[ "$PH_APP" == "Moonlight" ]]
then
	printf "%8s%s\n" "" "--> Removing 'Moonlight' cache directory '`getent passwd \"$PH_APP_USER\" 2>/dev/null | cut -d':' -f6`/.cache'"
	"$PH_SUDO" rm -r "$(getent passwd "$PH_APP_USER" 2>/dev/null | cut -d':' -f6)"/".cache" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
printf "%2s%s\n\n" "" "$PH_RESULT"
return 0
}

function ph_unintegrate_app {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_CMD=""
declare PH_APP_STATE=""
declare PH_APP_INST_STATE=""
declare PH_APP_STR_TTY=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -a PH_PARAMS

OPTIND="1"

while getopts a:u:t:c:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_TTY="$OPTARG"
		[[ "$PH_APP_TTY" -eq "0" ]] && \
			PH_APP_STR_TTY="-" || \
			PH_APP_STR_TTY="$PH_APP_TTY" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_INST_SATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "integrated" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Integrated -t exact) $(ph_get_app_list_by_state -s Halted -t exact)
	do
		ph_unintegrate_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		for PH_i in USER TTY CMD INST_STATE
		do
			declare -n PH_VAR="PH_APP_${PH_i}"
			if [[ ( "$PH_i" != "TTY" && -n "$PH_VAR" ) || \
				( "$PH_i" == "TTY" && "$PH_VAR" -gt "1" ) ]]
			then
				case "$PH_i" in USER)
					PH_PARAMS+=("-u" "'${PH_VAR}'") ;;
						TTY)
					PH_PARAMS+=("-t" "'${PH_VAR}'") ;;
						CMD)
					PH_PARAMS+=("-c" "'${PH_VAR}'") ;;
						INST_STATE)
					PH_PARAMS+=("-i" "'${PH_VAR}'") ;;
				esac
			fi
			unset -n PH_VAR 2>/dev/null
		done
		[[ "${#PH_PARAMS[@]}" -gt "0" ]] && \
			PH_APP="$(ph_get_app_name_from_base_conf_file "${PH_PARAMS[@]}")"
	fi
fi
unset PH_PARAMS
printf "%8s%s\n" "" "--> Checking application name parameter"
if [[ -z "$PH_APP" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid name"
	ph_set_result -r 1 -m "A valid name is mandatory for unintegrating an application"
	return 1
else
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_APP_STATE" in Supported|Unknown|Unused|Reserved)
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid name"
			ph_set_result -r 0 -w -m "Application already unintegrated"
			return 0 ;;
				Integrated|Running|Halted)
			printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_APP')" ;;
	esac
	ph_set_result -r 0
fi
if [[ "$PH_APP" == "PieHelper" ]]
then
	printf "%8s%s\n" "" "--> Checking if PieHelper is being (un)configured"
	if [[ -f "${PH_TMP_DIR}/.unconfigure_in_progress" || -f "${PH_TMP_DIR}/.configure_in_progress" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK : 'Unconfigure' action in progress"
		ph_set_result -r 0
	else
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : 'Unconfigure' action not in progress"
		ph_set_result -r 1 -m "Integration for 'PieHelper' is mandatory while configuration state remains 'Configured'"
		return 1
	fi
fi
if [[ -z "$PH_APP_STR_TTY" ]]
then
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
else
	printf "%8s%s\n" "" "--> Checking the tty parameter"
	if [[ "$PH_APP" != "$(ph_get_app_name_from_app_tty "$PH_APP_TTY")" ]]
	then
		PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid TTY -> Setting to 'TTY${PH_APP_TTY}'"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK ('TTY${PH_APP_TTY}')"
	fi
	ph_set_result -r 0
fi
if [[ -z "$PH_APP_USER" ]]
then
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
else
	printf "%8s%s\n" "" "--> Checking run account parameter"
	if [[ "$PH_APP_USER" != "$(ph_get_app_user_from_app_name "$PH_APP")" ]]
	then
		PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
		printf "%10s\033[31m%s\033[0m\n" "" "Warning : Invalid run account -> Setting to '$PH_APP_USER'"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_APP_USER')"
	fi
	ph_set_result -r 0
fi
ph_stop_all_running_apps "$PH_APP" || \
	return 1
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	ph_run_with_rollback -c "ph_set_app_for_start none" || \
		return 1
fi
if [[ "$PH_APP_TTY" -gt "1" ]]
then
	ph_run_with_rollback -c "ph_undo_setup_tty -a '${PH_APP}' -t '${PH_APP_TTY}' -u '${PH_APP_USER}'" || \
		return 1
fi
ph_run_with_rollback -c "ph_remove_app_items -a '${PH_APP}' -t unintegrate" || \
	return 1
ph_run_with_rollback -c "ph_remove_app_from_integration_file -a '${PH_APP}'" || \
	return 1
ph_add_value_to_param -p PH_INT_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
return 0
}

function ph_unsupport_app {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_CMD=""
declare PH_APP_PKG=""
declare PH_APP_INST_STATE=""
declare PH_APP_STATE=""
declare PH_APP_EXEC=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -l PH_il=""
declare -u PH_APPU=""
declare -a PH_PARAMS

OPTIND="1"

while getopts a:c:u:p:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             p)
		[[ -n "$PH_APP_PKG" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" && -z "$PH_APP_USER" && -z "$PH_APP_CMD" && -z "$PH_APP_INST_STATE" && -z "$PH_APP_PKG" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == @(default|supported) ]]
then
	if [[ "$PH_APP" == "default" ]]
	then
		for PH_APP in $(ph_get_app_list_by_state -s Default -t minimum)
		do
			ph_unsupport_app -a "$PH_APP}" || \
				return 1
		done
	else
		for PH_APP in $(ph_get_app_list_by_state -s Supported -t exact)
		do
			ph_unsupport_app -a "$PH_APP" || \
				return 1
		done
	fi
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		for PH_i in USER CMD INST_STATE
		do
			declare -n PH_VAR="PH_APP_${PH_i}"
			if [[ -n "$PH_VAR" ]]
			then
				case "$PH_i" in USER)
					PH_PARAMS+=("-u" "'${PH_VAR}'") ;;
						CMD)
					PH_PARAMS+=("-c" "'${PH_VAR}'") ;;
						INST_STATE)	
					PH_PARAMS+=("-i" "'${PH_VAR}'") ;;
				esac
			fi
			unset -n PH_VAR
		done
		[[ "${#PH_PARAMS[@]}" -gt "0" ]] && \
			PH_APP="$(ph_get_app_name_from_base_conf_file "${PH_PARAMS[@]}")"
	fi
fi
unset PH_PARAMS
printf "%8s%s\n" "" "--> Checking the requirements to unsupport"
if [[ -n "$PH_APP" ]]
then
	for PH_i in CMD USER
	do
		PH_il="$PH_i"
		declare -n PH_VAR="PH_APP_${PH_i}"
		for PH_j in 1 2
		do
			if [[ -z "$PH_VAR" ]]
			then
				case "$PH_j" in 1)
					PH_VAR="$(ph_get_app_${PH_il}_from_app_name "$PH_APP")" ;;
						2)
					unset -n PH_VAR
					[[ "$PH_il" == "cmd" ]] && \
						PH_il="start command"
					ph_set_result -m "Could not unsupport application ${PH_APP} without knowing the application's ${PH_il}"
					ph_run_with_rollback -c false -m "Could not unsupport" || \
						return 1 ;;
				esac
			fi
		done
		unset -n PH_VAR
	done
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_APP_STATE" in Integrated|Halted|Running)
		ph_set_result -m "Could not unsupport application ${PH_APP} when it's still integrated" ;;
				Supported)
		ph_run_with_rollback -c true -m "$PH_APP"
		if [[ "$PH_APP" == "PieHelper" ]]
		then
			printf "%8s%s\n" "" "--> Checking if PieHelper is being (un)configured"
			if [[ -f "${PH_TMP_DIR}/.unconfigure_in_progress" || -f "${PH_TMP_DIR}/.configure_in_progress" ]]
			then
				ph_run_with_rollback -c true -m "yes"
			else
				ph_set_result -m "PieHelper should be unsupported by running either 'confpieh_ph.sh -u' or 'confapps_ph.sh -a PieHelper -p unsup'"
				ph_run_with_rollback -c false -m "no" || \
					return 1
			fi
		fi
		printf "%8s%s\n" "" "--> Checking start command parameter"
		if [[ "$PH_APP_CMD" != "$(ph_get_app_cmd_from_app_name "$PH_APP")" ]]
		then
			PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known start command -> Set to '${PH_APP_CMD}'"
			ph_set_result -r 0
		else
			ph_run_with_rollback -c true -m "$PH_APP_CMD"
		fi
		PH_APP_EXEC="$(ph_get_app_executable -a "$PH_APP" -c "$PH_APP_CMD")"
		PH_APPU="${PH_APP:0:4}"
		printf "%8s%s\n" "" "--> Checking package parameter"
		if [[ "$PH_APP_PKG" != "$(eval "echo -n \"\$PH_${PH_APPU}_PKG_NAME\"")" ]]
		then
			PH_APP_PKG="$(eval "echo -n \"\$PH_${PH_APPU}_PKG_NAME\"")"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known package -> Set to '${PH_APP_PKG}'"
			ph_set_result -r 0
		else
			ph_run_with_rollback -c true -m "$PH_APP_PKG"
		fi
		if [[ -z "$PH_APP_INST_STATE" ]]
		then
			PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
		else
			printf "%8s%s\n" "" "--> Checking install state parameter"
			if ph_get_pkg_inst_state "$PH_APP_PKG"
			then
				if [[ "$PH_APP_INST_STATE" != "Packaged" ]]
				then
					PH_APP_INST_STATE="Packaged"
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known install state -> Set to '${PH_APP_INST_STATE}'"
					ph_set_result -r 0
				else
					ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
				fi
			else
				if [[ "$PH_APP_INST_STATE" != "Packageless" ]]
				then
					PH_APP_INST_STATE="Packageless"
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known install state -> Set to '${PH_APP_INST_STATE}'"
					ph_set_result -r 0
				else
					ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
				fi
			fi
		fi
		ph_run_with_rollback -c "ph_remove_app_items -a '${PH_APP}' -t unsupport" || \
			return 1
		if [[ "$PH_APP" != "PieHelper" ]]
		then
			:
			##### prompt whether to and possibly ph_uninstall_app
			##### plus add getopts param for passing it, also in confapps_ph.sh
		fi
		if ! ph_check_app_state_validity -a "$PH_APP" -q -d
		then
			ph_run_with_rollback -c "ph_remove_oos_app_code '${PH_APP}'" || \
				return 1
		fi
		ph_run_with_rollback -c "ph_remove_app_from_support_file -a '${PH_APP}'" || \
			return 1
		if [[ "$PH_APP" == "PieHelper" && ! -f "${PH_TMP_DIR}/.first_run" ]]
		then
			ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.first_run'" || \
				return 1
		fi
		ph_add_value_to_param -p PH_SUP_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_CMD}'${PH_APP_PKG}"
		return 0 ;;
				*)
		ph_run_with_rollback -c true -m "Nothing to do" && \
			return "$?" ;;
	esac
else
	ph_set_result -m "Could not unsupport an application without knowing the application's name"
fi
ph_run_with_rollback -c false -m "Could not unsupport" || \
	return 1
}

function ph_remove_app_from_support_file {
	
declare PH_i=""
declare PH_APP=""
declare PH_APP_CMD=""
declare PH_APP_USER=""
declare PH_APP_INST_STATE=""
declare PH_REMOVE_STRING=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -l PH_il=""

OPTIND="1"

while getopts a:u:c:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
			     i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} from configuration file " "'${PH_CONF_DIR}/supported_apps'"
PH_REMOVE_STRING="${PH_APP}"
for PH_i in USER INST_STATE CMD
do
	PH_il="$PH_i"
	declare -n PH_VAR="PH_APP_${PH_i}"
	if [[ -z "$PH_VAR" ]]
	then
		PH_VAR="$(eval "ph_get_app_${PH_il}_from_app_name \"$PH_APP\"")"
		if [[ -n "$PH_VAR" ]]
		then
			PH_REMOVE_STRING="${PH_REMOVE_STRING}\t${PH_VAR}"
		fi
	else
		PH_REMOVE_STRING="${PH_REMOVE_STRING}\t${PH_VAR}"
	fi
	unset -n PH_VAR
done
[[ "${PH_REMOVE_STRING}" == "${PH_APP}" ]] && \
	PH_REMOVE_STRING="${PH_REMOVE_STRING}\t.*"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
                    1)
	if ! ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/supported_apps' -l '${PH_REMOVE_STRING}'"
	then
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi ;;
                    *)
	ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/supported_apps' is corrupted -> Found multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_ADD_APPS_TO_SUP_FILE -v "${PH_APP}'${PH_APP_USER}'${PH_APP_INST_STATE}'${PH_APP_CMD}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_remove_app_from_integration_file {
	
declare PH_APP
declare PH_APP_STR_TTY
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:t: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ -n "$PH_APP_STR_TTY" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_STR_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || ( -n "$PH_APP_STR_TTY" && "$#" -ne "4" ) || \
	( -z "$PH_APP_STR_TTY" && "$#" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing application ${PH_APP} from configuration file " "'${PH_CONF_DIR}/integrated_apps'"
[[ -z "$PH_APP_STR_TTY" ]] && \
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
		    1)
	if [[ -n "$PH_APP_STR_TTY" ]]
	then
		ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\t${PH_APP_STR_TTY}'"
	else
		ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\t.*'"
	fi
	if [[ "$?" -ne "0" ]]
	then
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi ;;
		    *)
	ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/integrated_apps' is corrupted -> Found multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_ADD_APPS_TO_INT_FILE -v "${PH_APP}'${PH_APP_STR_TTY}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_get_app_name_from_app_pkg {

declare PH_APP
declare PH_APP_PKG
declare -u PH_APPU

PH_APP_PKG="$1"

[[ -z "$PH_APP_PKG" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in $(ph_get_app_list_by_state -s Default -t exact) $(ph_get_app_list_by_state -s Supported -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	declare -n PH_PKG="PH_${PH_APPU}_PKG"
	if [[ "$PH_APP_PKG" == "$PH_PKG" ]]
	then
		echo -n "$PH_APP"
		return 0
	fi
done
return 1
}

function ph_support_app {

declare PH_i=""
declare PH_APP=""
declare PH_APP_EXEC=""
declare PH_APP_CMD=""
declare PH_APP_GRAPH=""
declare PH_APP_PKG=""
declare PH_APP_NEW_PKG=""
declare PH_APP_USER=""
declare PH_APP_STATE=""
declare PH_APP_INST_STATE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -i PH_ANSWER="0"
declare -i PH_APP_PKG_CHANGED_FLAG="1"
declare -l PH_APPL=""
declare -u PH_APPU=""

OPTIND="1"
PH_PASS_APP_USER=""

while getopts a:c:u:p: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             p)
		[[ -n "$PH_APP_PKG" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" && -z "$PH_APP_PKG" && -z "$PH_APP_CMD" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "default" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Default -t exact)
	do
		ph_support_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		printf "%8s%s\n" "" "--> Attempting to determine missing arguments"
		for PH_i in CMD PKG
		do
			if [[ -n "$(eval "echo -n \"\$PH_APP_${PH_i}\"")" ]]
			then
				case "$PH_i" in CMD)
					PH_APP="$(ph_get_app_name_from_base_conf_file -c "$PH_APP_CMD")" ;;
						PKG)	
					PH_APP="$(ph_get_app_name_from_app_pkg "$PH_APP_PKG")" ;;
				esac
			fi
			[[ -n "$PH_APP" ]] && \
				break
		done
		if [[ -n "$PH_APP" ]]
		then
			ph_run_with_rollback -c true
		else
			ph_set_result -m "Function '${FUNCNAME[0]}' requires an application name but could not determine it automatically"
			ph_run_with_rollback -c false -m "Could not determine" || \
				return 1
		fi
	fi
fi
PH_APP_INST_STATE=""
printf "%8s%s\n" "" "--> Checking the application state of ${PH_APP}"
PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
case "$PH_APP_STATE" in Supported|Integrated|Running|Halted)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
			Unknown|Default)
	ph_run_with_rollback -c true -m "$PH_APP_STATE"
	printf "%8s%s\n" "" "--> Checking the start command of ${PH_APP}"
	if ! ph_check_app_state_validity -a "$PH_APP" -q -d
	then
		if [[ -z "$PH_APP_CMD" ]]
		then
			ph_set_result -m "Cannot support out-of-scope application ${PH_APP} without a valid start command"
			ph_run_with_rollback -c false -m "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_CMD"
		printf "%8s%s\n" "" "--> Checking the package of ${PH_APP}"
		if [[ -z "$PH_APP_PKG" || "$(ph_check_pkg_validity "$PH_APP_PKG" ; echo "$?")" -ne "0" ]]
		then
			ph_set_result -m "Cannot support out-of-scope application ${PH_APP} without a valid package name"
			ph_run_with_rollback -c false "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_PKG"
	else
		if [[ -n "$PH_APP_CMD" && "$PH_APP_CMD" != "$(ph_get_app_cmd_from_app_name "$PH_APP")" ]]
		then
			PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known start command -> Set to '${PH_APP_CMD}'"
			ph_set_result -r 0
		else
			[[ -z "$PH_APP_CMD" ]] && \
				PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
			ph_run_with_rollback -c true -m "'${PH_APP_CMD}'"
		fi
		printf "%8s%s\n" "" "--> Checking the package of ${PH_APP}"
		if [[ -n "$PH_APP_PKG" && "$PH_APP_PKG" != "$(ph_get_app_pkg_from_app_conf "$PH_APP")" ]]
		then
			PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
			if [[ -n "$PH_APP_PKG" ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known package -> Set to '${PH_APP_PKG}'"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known installation method -> Set to none" 
			fi
			ph_set_result -r 0
		else
			[[ -z "$PH_APP_PKG" ]] && \
				PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
			if [[ -z "$PH_APP_PKG" ]]
			then
				ph_run_with_rollback -c true -m "Packageless"
			else
				ph_run_with_rollback -c true -m "$PH_APP_PKG"
			fi
		fi
	fi
	printf "%8s%s\n" "" "--> Checking the installation state of ${PH_APP}"
	if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf -a "$PH_APP" -c "$PH_APP_CMD")"
	then
		ph_run_with_rollback -c false -m "Could not support" || \
			return 1
	fi
	ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
	declare -a PH_PARAMS
	[[ "$PH_APP_INST_STATE" == P* ]] && \
		PH_PARAMS+=("-p" "'${PH_APP_PKG}'")
	for PH_i in USER PKG
	do
		declare -n PH_VAR="PH_APP_${PH_i}"
		[[ -n "$PH_VAR" ]] && \
			PH_PARAMS+=("-$(cut -c1<<<"$PH_i" | tr "[:upper:]" "[:lower:]")" "'${PH_VAR}'")
		unset -n PH_VAR
	done
	if ! ph_check_app_user -a "$PH_APP" -i "$PH_APP_INST_STATE" "${PH_PARAMS[@]}"
	then
		unset PH_PARAMS
		return 1
	fi
	unset PH_PARAMS
	PH_APP_USER="$PH_PASS_APP_USER"
	unset PH_PASS_APP_USER
	PH_APP_GRAPH="$(ph_get_app_graphical_prop -a "$PH_APP" -c "$PH_APP_CMD")"
	PH_APP_EXEC="$(ph_get_app_executable -a "$PH_APP" -c "$PH_APP_CMD")"
	if [[ "$PH_APP" != "PieHelper" ]]
	then
		while true
		do
			PH_COUNT="0"
			printf "%8s%s\n" "" "--> Checking the executable location of ${PH_APP}"
			while true
			do
				PH_ANSWER="0"
				if [[ ! -x "$PH_APP_EXEC" ]]
				then
					[[ "$PH_COUNT" -eq "0" ]] && \
						printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
					printf "%8s%s\n\n" "" "--> How do you wish to proceed ?"
					printf "%12s\033[32m%s\033[0m\n" "" "1. Install ${PH_APP}"
					printf "%12s\033[32m%s\033[0m\n" "" "2. Enter the full pathname of executable '${PH_APP_EXEC##*/}' manually"
					printf "%12s\033[32m%s\033[0m\n" "" "3. Run a full system scan for '${PH_APP_EXEC##*/}'"
					printf "%12s\033[32m%s\033[0m\n" "" "4. Skip installation of ${PH_APP} for now"
					printf "%12s\033[32m%s\033[0m\n\n" "" "5. Quit and rollback changes"
					printf "%12s%s" "" "Your choice : "
					read -r PH_ANSWER 2>/dev/null
					ph_screen_input "$PH_ANSWER"
					PH_COUNT="$((PH_COUNT+1))"
					[[ "$PH_ANSWER" -ge "1" && "$PH_ANSWER" -le "5" ]] && \
						ph_run_with_rollback -c true
					case "$PH_ANSWER" in 1)
						break ;;
							     2)
						printf "%8s%s" "" "--> Please enter the full pathname of '${PH_APP_EXEC##*/}' (Leave empty to return to the previous menu) :"
						read -r PH_APP_EXEC 2>/dev/null
						ph_screen_input "$PH_APP_EXEC"
						[[ -z "$PH_APP_EXEC" ]] && \
							ph_run_with_rollback -c true && \
							continue ;;
							     3)
						printf "%8s%s\n" "" "--> Scanning for executable '${PH_APP_EXEC##*/}' (This may take a while)"
						PH_APP_EXEC="$("$PH_SUDO" find / -type f -perm -o=x \( ! -fstype nfs -a ! -fstype cifs \) -name "${PH_APP_EXEC##*/}" 2>/dev/null)" ;;
							     4)
						printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping installation but ${PH_APP} will not function until it is installed"
						ph_set_result -r 0
						break 2 ;;
							     5)
						ph_quit_with_rollback ;;
							     *)
						printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
						continue ;;
					esac
					if [[ -x "$PH_APP_EXEC" ]]
					then
						ph_run_with_rollback -c true -m "Found as and changing to '${PH_APP_EXEC}'"
						PH_APP_CMD="$(echo "$PH_APP_CMD" | nawk -v app="$PH_APP" -v newpath="$PH_APP_EXEC" -v appgraph="$PH_APP_GRAPH" 'BEGIN { \
								i = "2" \
							} { \
								if (appgraph == "yes") { \
									if (app == "X11") { \
										printf newpath \
									} else { \
										printf $1 " " newpath ; \
										i++ \
									} \
								} else { \
									printf newpath \
								} ; \
								for (j=i;j<=NF;j++) { \
									printf " " $j \
								} \
							}')"
						if PH_APP_NEW_PKG="$(dpkg -S "$PH_APP_EXEC" 2>/dev/null | cut -d':' -f1)"
						then
							if [[ "$PH_APP_NEW_PKG" != "$PH_APP_PKG" ]]
							then
								PH_APP_PKG="$PH_APP_NEW_PKG"
								PH_APP_PKG_CHANGED_FLAG="0"
							fi
						else
							ph_set_result -m "An error occurred trying to determine the package name of file '${PH_APP_EXEC}'"
							ph_run_with_rollback -c false -m "Could not change" || \
								return 1
						fi
						break 2
					else
						continue 2
					fi
				else
					ph_run_with_rollback -c true -m "Found"
					break 2
				fi
			done
			ph_run_with_rollback -c "ph_install_app -a '${PH_APP}' -u '${PH_APP_USER}'" || \
				return 1
		done
		printf "%8s%s\n" "" "--> Rechecking the installation state of ${PH_APP}"
		if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf -a "$PH_APP" -c "$PH_APP_CMD")"
		then
			ph_run_with_rollback -c false -m "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
	fi
	printf "%8s%s\n" "" "--> Checking for ${PH_APP} dependencies"
	if [[ "$PH_APP_GRAPH" == "yes" && "$PH_APP" != "X11" ]]
	then
		ph_run_with_rollback -c true -m "X11"
		printf "%8s%s\n" "" "--> Checking the application state of X11"
		PH_APP_STATE="$(ph_get_app_state_from_app_name X11)"
		if [[ "$PH_APP_STATE" == "Default" ]]
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : X11 is currently unsupported -> Supporting"
			ph_set_result -r 0
			ph_run_with_rollback -c "ph_support_app -a X11" || \
				return 1
		else
			ph_run_with_rollback -c true -m "$PH_APP_STATE"
		fi
	else
		ph_run_with_rollback -c true -m "None"
	fi
	ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t support" || \
		return 1
	if [[ "$PH_APP_PKG_CHANGED_FLAG" -eq "0" ]]
	then
		PH_APPU="${PH_APP:0:4}"
		ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_PKG'${PH_APP_NEW_PKG}\"" || \
			return 1
	fi
	if [[ -n "$PH_APP_INST_STATE" ]]
	then
		ph_run_with_rollback -c "ph_add_app_to_support_file -a '${PH_APP}' -u '${PH_APP_USER}' -i '${PH_APP_INST_STATE}' -c '${PH_APP_CMD}'" || \
			return 1
	else
		ph_run_with_rollback -c "ph_add_app_to_support_file -a '${PH_APP}' -u '${PH_APP_USER}' -c '${PH_APP_CMD}'" || \
			return 1
	fi
	if ! ph_check_app_state_validity -a "$PH_APP" -q -d
	then
		ph_run_with_rollback -c "ph_create_oos_app_code '${PH_APP}'" || \
			return 1
	fi
	ph_add_value_to_param -p PH_UNSUP_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_CMD}'${PH_APP_PKG}'${PH_APP_INST_STATE}"
	return 0 ;;
			*)
	PH_APPL="${PH_APP:0:4}"
	ph_set_result -m "Could not support ${PH_APP} since it is using a reserved shortname '${PH_APPL}'" ;;
esac
ph_run_with_rollback -c false -m "Could not support" || \
	return 1
}

function ph_modify_app_script {

declare PH_APP=""
declare PH_APP_SCRIPT=""
declare PH_APP_USER=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -i PH_APP_CUR_TTY="0"
declare -i PH_RET_CODE="0"

while getopts a:t: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in a)
			PH_APP="$OPTARG" ;;
			     t)
			PH_APP_TTY="$OPTARG" ;;
	esac
done

OPTARG="$PH_OLDOPTARG"
OPTIND="$PH_OLDOPTIND"

[[ -z "$PH_APP" ]] && return 1
[[ "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_TTY" -le "1" ]] && return 1
case "$PH_APP" in Kodi)
	PH_APP_SCRIPT="/usr/bin/kodi"
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_CUR_TTY="$("$PH_SUDO" nawk '$0 ~ /\/bin\/chvt [0-9]/ { print $NF ; exit }' "$PH_APP_SCRIPT" 2>/dev/null)"
	printf "%8s%s\n" "" "--> Modifying '$PH_APP' script '$PH_APP_SCRIPT' to use 'TTY$PH_APP_TTY'"
	"$PH_SUDO" nawk -v tty="$PH_APP_TTY" 'BEGIN { flag = "0" } $0 ~ /\/bin\/chvt [0-9]/ { for (i=1;i<=NF;i++) {
		if ($i=="/bin/chvt") { flag = "1" ; printf "%s", $i " " } else {
						if (flag==1) { printf tty } else { printf "%s", $i " " }}} ; printf "\n" ; next }
					{ print }' "$PH_APP_SCRIPT" >"$PH_TMP_DIR"/kodi_tmp 2>/dev/null
	if [[ "$?" -eq "0" ]]
	then
		"$PH_SUDO" chown "$PH_APP_USER":"$("$PH_SUDO" id -gn "$PH_RUN_USER")" "$PH_TMP_DIR"/kodi_tmp 2>/dev/null || PH_RET_CODE="1"
		"$PH_SUDO" chmod 774 "$PH_TMP_DIR"/kodi_tmp 2>/dev/null || PH_RET_CODE="1"
		if [[ "$PH_RET_CODE" -eq "0" ]]
		then
			"$PH_SUDO" mv "$PH_TMP_DIR"/kodi_tmp "$PH_APP_SCRIPT" 2>/dev/null || PH_RET_CODE="1"
		fi
	else
		PH_RET_CODE="1"
	fi ;;
		  *)
	return "$PH_RET_CODE" ;;
esac
if [[ "$PH_RET_CODE" -ne "0" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not modify script"
	[[ "$PH_APP" == "Kodi" ]] && "$PH_SUDO" rm "$PH_TMP_DIR"/kodi_tmp 2>/dev/null
	ph_set_result -r 1 -m "An error occurred modifying '$PH_APP' script '$PH_APP_SCRIPT'"
else
	ph_add_value_to_param -p PH_MODIFY_APPS_SCRIPT -v "$PH_APP'$PH_APP_CUR_TTY"
	ph_run_with_rollback -c "true"
fi
return "$PH_RET_CODE"
}

function ph_get_app_inst_state_from_app_conf {

declare PH_APP
declare PH_APP_PKG
declare PH_APP_CMD
declare PH_APP_EXEC
declare PH_APP_INST_STATE
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:c: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
if [[ -n "$PH_APP_PKG" ]]
then
	if ph_check_pkg_validity "$PH_APP_PKG"
	then
		if ph_get_pkg_inst_state "$PH_APP"
		then
			PH_APP_INST_STATE="PI"
		else
			PH_APP_INST_STATE="PA"
		fi
	else
		ph_set_result -m "Configuration file '${PH_CONF_DIR}/${PH_APP}.conf' contains an invalid package name '${PH_APP_PKG}'"
		return 1
	fi
else
	if [[ "$PH_APP" == "PieHelper" ]]
	then
		PH_APP_INST_STATE="UI"
	else
		[[ -z "$PH_APP_CMD" ]] && \
			PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
		if [[ -n "$PH_APP_CMD" ]]
		then
			PH_APP_EXEC="$(ph_get_app_executable -a "$PH_APP" -c "$PH_APP_CMD")"
		else
			ph_set_result -m "Could not determine the application's installation state without a valid start command"
			return 1
		fi
		if [[ -x "$PH_APP_EXEC" ]]
		then
			PH_APP_INST_STATE="UI"
		else
			PH_APP_INST_STATE="UA"
		fi
	fi
fi
echo -n "$PH_APP_INST_STATE"
return 0
}

function ph_add_app_to_support_file {

declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_PKG=""
declare PH_APP_CMD=""
declare PH_APP_INST_STATE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"

OPTIND="1"

while getopts a:c:u:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( -z "$PH_APP_INST_STATE" && "$#" -ne "6" ) || ( -n "$PH_APP_INST_STATE" && "$#" -ne "8" ) || \
	-z "$PH_APP" || -z "$PH_APP_USER" || -z "$PH_APP_CMD" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Adding application ${PH_APP} to configuration file " "'${PH_CONF_DIR}/supported_apps'"
if [[ -z "$PH_APP_INST_STATE" ]]
then
	if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf -a "$PH_APP" -c "$PH_APP_CMD")"
	then
		ph_run_with_rollback -c false -m "Could not add" || \
			return 1
	fi
fi
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
		if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/supported_apps' -l '${PH_APP}\\t${PH_APP_USER}\\t${PH_APP_INST_STATE}\\t${PH_APP_CMD}'"
		then
			ph_run_with_rollback -c false -m "Could not add" || \
				return 1
		fi ;;
		    1)
		ph_run_with_rollback -c true -m "Nothing to do" && \
			return "$?" ;;
		    *)
		ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/supported_apps' is corrupted -> Multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_REMOVE_APPS_FROM_SUP_FILE -v "${PH_APP}'${PH_APP_USER}'${PH_APP_INST_STATE}'${PH_APP_CMD}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_update_base_conf_file {

declare PH_APP
declare PH_APP_USER
declare PH_APP_INST_STATE
declare PH_APP_CMD
declare PH_FILE
declare PH_VALUE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COLUMN
declare -i PH_APP_TTY

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:f:c:v: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             f)
		[[ -n "$PH_FILE" || "$OPTARG" != @(sup|int) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_FILE="$OPTARG" ;;
                             c)
		[[ "$PH_COLUMN" -gt "0" || "$OPTARG" -lt "1" || "$OPTARG" -gt "4" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_COLUMN="$OPTARG" ;;
                             v)
		[[ -n "$PH_VALUE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_VALUE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_FILE" || -z "$PH_VALUE" || "$PH_COLUMN" -lt "2" || \
	( "$PH_COLUMN" -gt "4" && "$PH_FILE" == "sup" ) || ( "$PH_COLUMN" -ne "2" && "$PH_FILE" == "int" ) ]] && \
	return 1

PH_FILE="$(ph_get_filename_from_shortname "$PH_FILE")"
if [[ "$PH_FILE" == "supported_apps" ]]
then
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_INST_STATE="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
else
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
fi
printf "%8s%s\n" "" "--> Updating the information for ${PH_APP} in configuration file '${PH_CONF_DIR}/${PH_FILE}'"
while true
do
	if [[ "$PH_FILE" == "supported_apps" ]]
	then
		if ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\t${PH_APP_USER}\t${PH_APP_INST_STATE}\t${PH_APP_CMD}'"
		then
			case "$PH_COLUMN" in 2)
				PH_APP_USER="$PH_VALUE" ;;
					     3)
				PH_APP_INST_STATE="$PH_VALUE" ;;
					     4)
				PH_APP_CMD="$PH_VALUE" ;;
			esac
			if ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\\t${PH_APP_USER}\\t${PH_APP_INST_STATE}\\t${PH_APP_CMD}'"
			then
				break
			fi
		fi
	else
		if ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\t${PH_APP_TTY}'"
		then
			if ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\\t${PH_VALUE}'"
			then
				break
			fi
		fi
	fi
	ph_run_with_rollback -c false -m "Could not update" || \
		return 1
done
ph_run_with_rollback -c true && \
	return "$?"
return 0
}

function ph_add_app_to_integration_file {

declare PH_APP
declare PH_APP_STR_TTY
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:t: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ -n "$PH_APP_STR_TTY" || (( "$OPTARG" != @(+([[:digit:]])|-) ) && \
			( "$OPTARG" == +([[:digit:]]) && "$OPTARG" -le "1" && "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" )) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_STR_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || ( -n "$PH_APP_STR_TTY" && "$#" -ne "4" ) || \
	( -z "$PH_APP_STR_TTY" && "$#" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_APP_STR_TTY" ]] && \
	PH_APP_STR_TTY="-"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Adding application ${PH_APP} to configuration file " "'${PH_CONF_DIR}/integrated_apps'"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
		if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\\t${PH_APP_STR_TTY}'"
		then
			ph_set_result -m "An error occurred adding ${PH_APP} to configuration file '${PH_CONF_DIR}/integrated_apps'"
			ph_run_with_rollback -c false -m "Could not add" || \
				return 1
		fi ;;
		   1)
		ph_run_with_rollback -c true -m "Nothing to do" && \
			return "$?" ;;
		    *)
		ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/integrated_apps' is corrupted -> Multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_REMOVE_APPS_FROM_INT_FILE -v "${PH_APP}'${PH_APP_STR_TTY}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_get_app_inst_state_from_app_name {

declare PH_APP
declare PH_APP_INST_STATE

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_INST_STATE="$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
		printf $3 ; \
		exit 0 \
	} { \
		next \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ "$PH_APP_INST_STATE" != @(Absent|Package@(d|less)) ]] && \
	return 1
echo -n "$PH_APP_INST_STATE"
return 0
}

function ph_check_app_user {

declare PH_i=""
declare PH_APP=""
declare PH_APP_PKG=""
declare PH_APP_INST_STATE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -i PH_CREATE_FLAG="1"

OPTIND="1"

while getopts a:p:u:i: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     p)
		[[ -n "$PH_APP_PKG" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
			     u)
		[[ -n "$PH_PASS_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_PASS_APP_USER="$OPTARG" ;;
			     i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|A) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( -z "$PH_APP" && -z "$PH_APP_PKG" ) || -z "$PH_APP_INST_STATE" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -z "$PH_APP" || ( -z "$PH_APP_PKG" && "$PH_APP_INST_STATE" == P* ) ]]
then
	printf "%8s%s\n" "" "--> Attempting to determine missing arguments"
	for PH_i in 1 2
	do
		if [[ "$PH_i" == "1" ]]
		then
			if [[ -n "$PH_APP_PKG" && -z "$PH_APP" ]]
			then
				PH_APP="$(ph_get_app_name_from_app_pkg "$PH_APP_PKG")"
			fi
		else
			if [[ -z "$PH_APP" ]]
			then
				ph_set_result -m "Function '${FUNCNAME[0]}' requires an application name but could not determine it automatically"
				ph_run_with_rollback -c false -m "Could not determine" || \
					return 1
			else
				if [[ -z "$PH_APP_PKG" && "$PH_APP_INST_STATE" == P* ]]
				then
					PH_APP_PKG="$(ph_get_app_pkg_from_app_conf "$PH_APP")"
					if [[ -z "$PH_APP_PKG" ]]
					then
						ph_set_result -m "Function '${FUNCNAME[0]}' requires an application package but could not determine it automatically"
						ph_run_with_rollback -c false -m "Could not determine" || \
							return 1
					fi
					
				fi
			fi
		fi
	done
	ph_run_with_rollback -c true
fi
printf "%8s%s\n" "" "--> Checking the user account for ${PH_APP}"
if [[ "$PH_APP" == "PieHelper" ]]
then
	PH_PASS_APP_USER="$PH_RUN_USER"
else
	while true
	do
		PH_COUNT="$((PH_COUNT+1))"
		if ! ph_check_user_validity "$PH_PASS_APP_USER"
		then
			if [[ -n "$PH_PASS_APP_USER" ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : User account '${PH_PASS_APP_USER}' does not exist -> Creating"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : " "No user provided"
				if [[ "$PH_COUNT" -eq "1" && "$PH_APP_INST_STATE" == "PI" ]]
				then
					ph_set_result -r 0
					printf "%8s%s\n" "" "--> Attempting to determine the user for ${PH_APP} from package '${PH_APP_PKG}'"
					PH_PASS_APP_USER="$(systemctl show "$PH_APP_PKG" 2>/dev/null | nawk -F'=' '$1 ~ /^U(ser|ID)$/ && $2 !~ /\[not set\]/ { \
							printf $2 ; \
							exit 0 \
						}')"
					if [[ -n "$PH_PASS_APP_USER" ]]
					then
						if [[ "$PH_PASS_APP_USER" == +([[:digit:]]) ]]
						then
							PH_PASS_APP_USER="$(getent passwd "$PH_PASS_APP_USER" 2>/dev/null | head -1 | cut -d':' -f1)"
						fi
						break
					else
						printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine"
					fi
				fi
			fi
			ph_set_result -r 0
		fi
		if [[ -z "$PH_PASS_APP_USER" ]]
		then
			printf "%8s%s\n\n" "" "--> Please enter a valid user account for application ${PH_APP}"
			printf "%10s%s\n" "" "- Entering an existing account will update the account's secondary group membership to include the following groups : 'tty,audio,video,input'"
			printf "%10s%s\n" "" "- Entering an non-existent account will create a user and corresponding UPG (User Private Group)"
			printf "%10s%s\n" "" "- Usernames must be alphanumeric and can optionally contain dash and underscore characters as well as a trailing dollar sign"
			printf "%10s%s\033[32m%s\033[0m\n" "" "- Leave empty to use the default of " "'${PH_RUN_USER}'"
			printf "%10s%s\033[32m%s\033[0m\n\n" "" "- Or enter 'quit' to stop and rollback all changes"
			printf "%8s%s" "" "User account : "
			read -r PH_PASS_APP_USER 2>/dev/null
			ph_screen_input "$PH_PASS_APP_USER"
			case "$PH_PASS_APP_USER" in "")
				PH_PASS_APP_USER="$PH_RUN_USER" ;;
					quit)
				ph_quit_with_rollback ;;
					*)
				continue ;;
			esac
		else
			PH_CREATE_FLAG="0"
		fi
		break
	done
fi
ph_run_with_rollback -c true -m "$PH_PASS_APP_USER"
if [[ "$PH_PASS_APP_USER" != @(${PH_RUN_USER}|root) ]]
then
	if [[ "$PH_CREATE_FLAG" -eq "0" ]]
	then
		ph_run_with_rollback -c "ph_create_app_user -a '${PH_APP}' -u '${PH_PASS_APP_USER}'" || \
			return 1
	else
		ph_run_with_rollback -c "ph_set_user_group_membership '${PH_PASS_APP_USER}'" || \
			return 1
	fi
	ph_run_with_rollback -c "ph_grant_pieh_access '${PH_PASS_APP_USER}'" || \
		return 1
fi
return 0
}

function ph_quit_with_rollback {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

ph_set_result -r 0 -w -m "Quitting at user request"
ph_show_result
ph_rollback_changes
exit "$?"
}

function ph_remove_app_user {

declare PH_APP=""
declare PH_APP_USER=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:u: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing user account " "'${PH_APP_USER}'"
if ! ph_check_user_validity "$PH_APP_USER"
then
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
else
	if "$PH_SUDO" userdel -r "$PH_APP_USER" 2>/dev/null
	then
		ph_add_value_to_param -p PH_CREATE_APP_USER -v "${PH_APP}'${PH_APP_USER}"
		ph_run_with_rollback -c true && \
			return "$?"
	else
		ph_set_result -m "An error occurred trying to remove user '${PH_APP_USER}'"
	fi
fi
ph_run_with_rollback -c false -m "Could not remove" || \
	return 1
}

function ph_create_app_user {

declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_USER_PASS=""
declare PH_APP_USER_PASS_REPEAT=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"

OPTIND="1"

while getopts a:u: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

while [[ -z "$PH_APP_USER_PASS" || "$(ph_check_password_validity "$PH_APP_USER_PASS" ; echo "$?")" -ne "0" ||
	"$PH_APP_USER_PASS" != "$PH_APP_USER_PASS_REPEAT" ]]
do
	[[ "$PH_COUNT" -gt "0" ]] && \
		ph_set_result -r 0
	printf "%8s%s\033[32m%s\033[0m\n\n" "" "--> Please enter a password for user " "'${PH_APP_USER}'"
	printf "%10s%s\n" "" "- Passwords may not contain single quote (') or blank characters such as space or tab"
	printf "%10s%s\n" "" "- Entered passwords will not be displayed"
	printf "%10s%s\033[32m%s\033[0m\n\n" "" "- Or enter 'quit' to stop and rollback all changes"
	printf "%8s%s" "" "User password : "
	read -rs PH_APP_USER_PASS 2>/dev/null
	ph_screen_input "$PH_APP_USER_PASS"
	PH_COUNT="$((PH_COUNT+1))"
	case "$PH_APP_USER_PASS" in "")
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords may not be empty" ;;
			quit)
		ph_quit_with_rollback ;;
			*)
		if ! ph_check_password_validity "$PH_APP_USER_PASS"
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords may not contain single quote (') or space characters"
		else
			ph_run_with_rollback -c true
			printf "%8s%s" "" "Please re-enter the password : "
			read -rs PH_APP_USER_PASS_REPEAT 2>/dev/null
			ph_screen_input "$PH_APP_USER_PASS_REPEAT"
			if [[ "$PH_APP_USER_PASS" == "$PH_APP_USER_PASS_REPEAT" ]]
			then
				ph_run_with_rollback -c true
				printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating user account " "'${PH_APP_USER}'"
				if "$PH_SUDO" useradd -d "/home/${PH_APP_USER}" -m -c "PieHelper application ${PH_APP}" -s /bin/bash \
					-G tty,audio,video,input "$PH_APP_USER" >/dev/null 2>&1
				then
					if "$PH_SUDO" "${PH_SCRIPTS_DIR}/app/setpasswd.expect" "$PH_APP_USER" "$PH_APP_USER_PASS" >/dev/null 2>&1
					then
						ph_add_value_to_param -p PH_REMOVE_APP_USER -v "${PH_APP}'${PH_APP_USER}"
						ph_run_with_rollback -c true -m "$PH_APP_USER" && \
							return "$?"
					else
						ph_set_result -m "An error occurred trying to set the password for user '${PH_APP_USER}'"
					fi
				else
					ph_set_result -m "An error occurred trying to create user '${PH_APP_USER}'"
				fi
				break
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords do not match -> Try again"
			fi
		fi
		continue ;;
	esac
done
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_revoke_pieh_access {

declare PH_APP_USER=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts u:q PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
                             q)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) ]]
then
	ph_run_with_rollback -c "ph_user_acls -p remove -u '${PH_APP_USER}' -t immediate ${PH_PARAMS}" || \
		return 1
	ph_run_with_rollback -c "ph_remove_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" || \
		return 1
	if [[ -z "$PH_PARAMS" ]]
	then
		printf "%8s%s\n\n" "" "--> Displaying reminder"
		printf "%12s\033[33m%s\033[0m\n" "" "PieHelper access for user '${PH_APP_USER}' is revoked but the user might still have system access"
		printf "%12s\033[33m%s\033[0m\n" "" "Additionally removing the system account : "
		printf "%14s\033[33m%s\033[0m\n" "" "- Can be done by running '${PH_SUDO} userdel -r ${PH_APP_USER}' from the command line"
		printf "%14s\033[33m%s\033[0m\n" "" "- Should not be done if user '${PH_APP_USER}' is still required for other reasons"
		printf "%14s\033[33m%s\033[0m\n\n" "" "- Keep in mind that doing so will also remove the home directory of '${PH_APP_USER}' and its contents"
		ph_run_with_rollback -c true
	fi
	ph_add_value_to_param -p PH_GRANT_APPS_ACCESS -v "${PH_APP_USER}'${PH_PARAMS}"
fi
return 0
}

function ph_grant_pieh_access {

declare PH_APP_USER=""
declare PH_OPTION=""
declare PH_PARAMS=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts u:q PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
                             q)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -gt "3" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) ]]
then
	ph_run_with_rollback -c "ph_user_acls -p create -u '${PH_APP_USER}' -t immediate ${PH_PARAMS}" || \
		return 1
	ph_run_with_rollback -c "ph_create_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" || \
		return 1
	ph_add_value_to_param -p PH_REVOKE_APPS_ACCESS -v "${PH_APP_USER}'${PH_PARAMS}"
fi
return 0
}

function ph_integrate_app {

declare PH_i=""
declare PH_APP=""
declare PH_APP_CMD=""
declare PH_APP_STATE=""
declare PH_APP_INST_STATE=""
declare PH_APP_USER=""
declare PH_APP_STR_TTY=""
declare PH_OPTION=""
declare PH_PARAMS=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"

OPTIND="1"

while getopts a:t:c:u: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG"
		if [[ "$PH_APP_TTY" -eq "0" ]]
		then
			PH_APP_STR_TTY="-"
		else
			PH_APP_STR_TTY="$PH_APP_TTY"
		fi ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "supported" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Supported -t exact)
	do
		ph_integrate_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		for PH_i in CMD USER TTY
		do
			declare -n PH_VAR="PH_APP_${PH_i}"
			case "$PH_i" in CMD)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-c '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -c '${PH_VAR}'" ;;
					USER)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-u '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -u '${PH_VAR}'" ;;
					TTY)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-t '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -t '${PH_VAR}'" ;;
			esac
			unset -n PH_VAR
		done
		if [[ -n "$PH_PARAMS" ]]
		then
			! PH_APP="$(ph_get_app_name_from_base_conf_file ${PH_PARAMS})" && \
				return 1
		fi
	fi
fi
[[ "$PH_APP" == "Emulationstation" ]] && \
	PH_APP_USER="$(ls -lad "$PH_EMUL_SETUP_DIR" 2>/dev/null | nawk '{ \
			print $3 \
		}')"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
## prompt here if empty
# [[ -z "$PH_APP" ]]
# optional only if other prompt [[ "$PH_APP_TTY" -eq "0" ]]

printf "%8s%s\n" "" "--> Checking application name parameter"
if [[ -z "$PH_APP" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid application name"
	ph_set_result -r 1 -m "A valid name is mandatory for integrating an application"
	return 1
else
	printf "%10s\033[32m%s\033[0m\n" "" "OK ('${PH_APP}')"
	ph_set_result -r 0
	printf "%8s%s\n" "" "--> Checking '${PH_APP}' application state"
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_APP_STATE" in Supported)
			printf "%10s\033[32m%s\033[0m\n" "" "OK ('${PH_APP_STATE}')" ;;
				Integrated|Halted|Running)
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid application state"
			ph_set_result -r 0 -w -m "'${PH_APP}' already integrated"
			return 0 ;;
				*)
			printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid application state"
			ph_set_result -r 1 -m "Prior support is mandatory for integrating '${PH_APP}'"
			return 1 ;;
	esac
fi
ph_set_result -r 0
if [[ -n "$PH_APP_STR_TTY" ]]
then
	printf "%8s%s\n" "" "--> Checking the tty parameter"
	ph_set_result -r 0
	if [[ "$PH_APP" == "PieHelper" ]]
	then
		if [[ "$PH_APP_TTY" -ne "2" ]]
		then
			PH_APP_TTY="2"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid TTY -> Setting to 'tty${PH_APP_TTY}'"
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK ('tty${PH_APP_TTY}')"
		fi
	else
		if [[ "$PH_APP_TTY" -lt "3" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" ]]
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid tty -> Allocating new tty"
			ph_allocate_new_tty "$PH_APP"
			PH_APP_TTY="$?"
			[[ "$PH_APP_TTY" -eq "1" ]] && \
				return 1
		else
			if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_TTY}$" >/dev/null
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid tty -> Allocating new tty"
				ph_allocate_new_tty "$PH_APP"
				PH_APP_TTY="$?"
				[[ "$PH_APP_TTY" -eq "1" ]] && \
					return 1
			else
				printf "%10s\033[32m%s\033[0m\n" "" "OK ('tty${PH_APP_TTY}')"
			fi
		fi
	fi
else
	[[ "$PH_APP" == "PieHelper" ]] && \
		PH_APP_TTY="2"
fi
ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t integrate" || \
	return 1
if [[ "$PH_APP_TTY" -ne "0" ]]
then
	ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" || \
		return 1
else
	ph_run_with_rollback -c "ph_add_app_to_integration_file -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" || \
		return 1
fi
[[ "$PH_APP" == "PieHelper" ]] && \
	PH_RUN_USER="$PH_APP_USER"
ph_run_with_rollback -c "ph_secure_pieh -t delayed" || \
	return 1
ph_add_value_to_param -p PH_UNINT_APPS -v "$PH_APP"
return 0
}

function ph_get_app_tty {

declare PH_APP="$1"
declare PH_APP_USER=""
declare -i PH_APP_TTY="0"

[[ -z "$PH_APP" ]] && \
	echo -n "1" && \
	return 1

printf "%8s%s\n" "" "--> Checking the tty of ${PH_APP}"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
if [[ "$PH_APP_TTY" -eq "0" ]]
then 
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine TTY -> Allocating new TTY"
	ph_set_result -r 0
	ph_allocate_new_tty "$PH_APP"
	PH_APP_TTY="$?"
	if [[ "$PH_APP_TTY" -ne "1" ]]
	then
		ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -t '${PH_APP_TTY}' -u '${PH_APP_USER}'" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "tty${PH_APP_TTY}"
fi
return "$PH_APP_TTY"
}

function ph_undo_setup_tty {

declare PH_APP=""
declare PH_APP_USER=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"

OPTIND="1"

while getopts a:u:t: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP_TTY" -eq "0" ]] && \
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
[[ -z "$PH_APP_USER" ]] && \
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Deallocating " "'tty${PH_APP_TTY}'"
if ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\t${PH_APP_USER}\t${PH_APP_TTY}'"
then
	if ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\\t${PH_APP_USER}\\t-'"
	then
		ph_run_with_rollback -c true
		printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} LoginScript " "'/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
		if ph_run_with_rollback -c "ph_store_file -r -f '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} autologin configuration " "'/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
			if ph_run_with_rollback -c "ph_store_file -r -f '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
			then
				if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
				then
					ph_add_value_to_param -p PH_SETUP_TTYS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
					ph_run_with_rollback -c true && \
						return "$?"
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			fi
		fi
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi
fi
ph_run_with_rollback -c false -m "Could not deallocate" || \
	return 1
}

function ph_setup_tty {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APP_CMD=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_APP_TTY="0"
declare -i PH_RET_CODE="0"
declare -l PH_APPL=""

OPTIND="1"

while getopts a:u:t: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$PH_APP_TTY" -le "1" || \
	"$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -lt "6" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPL="${PH_APP:0:4}"
PH_APP_CMD="${PH_SCRIPTS_DIR}/start${PH_APPL}.sh"
if [[ ! -d "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -r -t directory -d '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d'" || \
		return 1
fi
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Installing ${PH_APP} autologin configuration as " "'/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
if ph_run_with_rollback -c "ph_create_empty_file -q -r -t file -d '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
then
	for PH_i in "[Service]" "ExecStart=" "ExecStart=-/sbin/agetty --autologin ${PH_APP_USER} --noclear tty${PH_APP_TTY} \$TERM"
	do
		if ! ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf' -l '${PH_i}'"
		then
			ph_run_with_rollback -c false -m "Could not install" || \
				return 1
		fi
	done
	if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
	then
		ph_run_with_rollback -c true
		if [[ "$PH_FILE_SUFFIX" == "_GL" && "$PH_APP" == "Kodi" ]]
		then
			ph_run_with_rollback -c "ph_modify_app_script -a '${PH_APP}' -t '${PH_APP_TTY}'" || \
				return 1
		fi
		if ph_run_with_rollback -c "ph_copy_file -s '${PH_TEMPLATES_DIR}/LoginScript.template' -d '${PH_CONF_DIR}/LoginScript.conf'"
		then
			ph_run_with_rollback -c "ph_set_option_to_value LoginScript -r \"PH_APP_TTY'tty${PH_APP_TTY}\" -r \"PH_APP_USER'${PH_APP_USER}\" -r \"PH_APP_CMD'${PH_APP_CMD}\"" || \
				return 1
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Installing ${PH_APP} LoginScript as " "'/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
			if ph_run_with_rollback -c "ph_copy_file -q -r -m -s '${PH_CONF_DIR}/LoginScript.conf' -d '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
			then
				if "$PH_SUDO" chown "${PH_APP_USER}:$(id -gn "$PH_APP_USER" 2>/dev/null)" "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" 2>/dev/null
				then
					ph_run_with_rollback -c true
					ph_run_with_rollback -c "ph_add_app_to_integration_file -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" || \
						return 1
					ph_add_value_to_param -p PH_UNDO_SETUP_TTYS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
					return 0
				else
					ph_set_result -m "An error occurred trying to set ownership of file '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh' to '${PH_APP_USER}:$(id -gn "$PH_APP_USER" 2>/dev/null)'"
				fi
			fi
		fi
	else
		ph_set_result -m "An error occurred trying to reload systemd configuration"
	fi
fi
ph_run_with_rollback -c false -m "Could not install" || \
	return 1
}

function ph_set_app_for_start {

declare PH_APP="$1"
declare PH_OLD_STARTAPP=""
declare -i PH_COLUMNS="$(tput cols 2>/dev/null)"
declare -i PH_APP_TTY="0"
declare -i PH_COUNT="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Checking current StartApp"
ph_run_with_rollback -c true -m "$PH_PIEH_STARTAPP"
PH_OLD_STARTAPP="$PH_PIEH_STARTAPP"
if [[ "$PH_APP" == "prompt" ]]
then
	printf "%8s%s\n" "" "--> Please choose the application to start on system boot"
	declare -a PH_APP_READ=($(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null))
	while true
	do
		[[ "$PH_COUNT" -gt "0" ]] && \
			printf "\n%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Invalid response"
		nawk '{
			printf "%10s%s\033[32m%s\033[0m\n", "", NR ". ", $1
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null
		printf "%10s%s\033[32m%s\033[0m\n" "" "${#PH_APP_READ[@]}. " "none"
		printf "%10s%s\033[32m%s\033[0m\n\n" "" "$(("${#PH_APP_READ[@]}"+1)). " "Keep the current StartApp : '${PH_PIEH_STARTAPP}'"
		printf "%8s%s" "" "Your choice : "
		read -r PH_APP_READ[0] 2>/dev/null
		((PH_COUNT++))
		ph_screen_input "${PH_APP_READ[0]}"
		case "${PH_APP_READ[0]}" in $(cat -n "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | nawk '{ \
				print $1 \
			}' | paste -d "|" -s))
			PH_APP="$(nawk -v line="${PH_APP_READ[0]}" '{ \
					if (NR == line) { \
						print $1 \
					} \
				}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)" ;;
					    "${#PH_APP_READ[@]}")
			PH_APP="none" ;;
					    "$(("${#PH_APP_READ[@]}"+1))")
			unset PH_APP_READ 2>/dev/null
			ph_run_with_rollback -c true -m "Skipping" && \
				return "$?" ;;
		esac
		if [[ -n "$PH_APP" ]]
		then
			unset PH_APP_READ
			ph_run_with_rollback -c true -m "$PH_APP"
			break
		fi
	done
fi
printf "%8s%s\n" "" "--> Comparing old and new values for StartApp"
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
else
	ph_run_with_rollback -c true
fi
if [[ "$PH_APP" != "none" ]]
then
	ph_get_app_tty "$PH_APP"
	PH_APP_TTY="$?"
	[[ "$PH_APP_TTY" -eq "1" ]] && \
		return 1
fi
ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_TTY}'" || \
	return 1
ph_run_with_rollback -c "ph_set_option_to_value PieHelper -r \"PH_PIEH_STARTAPP'${PH_APP}\"" || \
	return 1
ph_add_value_to_param -p PH_STARTAPP -v "$PH_OLD_STARTAPP"
return 0
}

function ph_get_app_name_from_login_script {

declare PH_APP
declare -l PH_APPL
declare -l PH_COMPAREAPPL
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_COMPAREAPPL="$("$PH_SUDO" nawk -F\' '$1 ~ /^PH_APP_CMD=$/ { \
		print substr($2,index($2,"start")+5,index($2,".")-(index($2,"start")+5)) \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" 2>/dev/null)"
for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
do
	PH_APPL="${PH_APP:0:4}"
	[[ "$PH_APPL" == "$PH_COMPAREAPPL" ]] && \
		break
done
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_user_from_autologin {

declare PH_APP_USER
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" nawk '$0 ~ /autologin/ && $1 ~ /^ExecStart=/ { \
		print $3 \
	}' "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_tty_from_autologin {

declare -i PH_APP_TTY
declare -i PH_CUR_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_CUR_APP_TTY="$("$PH_SUDO" nawk '$0 ~ /autologin/ && $1 ~ /^ExecStart=/ { \
		print substr($5,4,length($5)-3) \
	}' "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" 2>/dev/null)"
echo -n "$PH_CUR_APP_TTY"
[[ "$PH_CUR_APP_TTY" -le "1" || "$PH_CUR_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_TTY" -ne "$PH_CUR_APP_TTY" ]] && \
	return 1
return 0
}

function ph_get_app_user_from_app_tty {

declare PH_APP_USER
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(ph_get_app_user_from_app_name "$(ph_get_app_name_from_app_tty "$PH_APP_TTY")")"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_user_from_login_script {

declare PH_APP_USER
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" nawk 'BEGIN { \
		FS = "\x27" \
	} \
	$1 ~ /^PH_APP_USER=/ { \
		printf $2 \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_tty_from_login_script {

declare -i PH_APP_TTY
declare -i PH_CUR_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_CUR_APP_TTY="$("$PH_SUDO" nawk 'BEGIN { \
		FS = "\x27" \
	} \
	$1 ~ /^PH_APP_TTY=/ { \
		printf substr($2,4,length($2)-3) \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" 2>/dev/null)"
echo -n "$PH_CUR_APP_TTY"
[[ "$PH_CUR_APP_TTY" -le "1" || "$PH_CUR_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_TTY" -ne "$PH_CUR_APP_TTY" ]] && \
	return 1
return 0
}

function ph_get_app_user_from_login_script_owner {

declare PH_APP_USER
declare -i PH_APP_TTY

PH_APP_TTY="$1"

[[ "$PH_APP_TTY" -le "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" find /etc/profile.d -mount -name "PieHelper_tty${PH_APP_TTY}.sh" -exec ls -la {} \; 2>/dev/null | nawk '{ \
		print $3 \
	}')"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_check_app_integration_data_validity {

declare PH_APP="$1"
declare PH_APP_USER=""
declare -i PH_APP_TTY="0"
declare -i PH_RET_CODE="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
[[ "$(nawk -v app=^"$PH_APP"$ '$1 ~ app { printf NF ; exit 0 }' "$PH_CONF_DIR/integrated_apps" 2>/dev/null)" -ne "3" ]] && PH_RET_CODE="1"
! ph_check_user_validity "$PH_APP_USER" && PH_RET_CODE="1"
[[ "$PH_APP_TTY" -eq "1" ]] && PH_RET_CODE="1"
return "$PH_RET_CODE"
}

function ph_check_app_support_data_validity {

declare PH_APP="$1"
declare PH_APP_INST_STATE=""
declare PH_APP_CMD=""
declare -i PH_RET_CODE="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
[[ "$(nawk -v app=^"$PH_APP"$ '$1 ~ app { printf NF ; exit 0 }' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)" -lt "3" ]] && \
	PH_RET_CODE="1"
[[ "$PH_APP_INST_STATE" != @(Absent|Package@(d|less)) ]] && \
	PH_RET_CODE="1"
[[ ! -f "$(echo -n "$PH_APP_CMD" | nawk -v app="$PH_APP" -v xinit=^"/usr/bin/xinit"$ -v startx=^"/usr/bin/startx"$ '$1 ~ xinit || ($1 ~ startx && app !~ /^X11$/) { printf $2 ; exit 0 } { printf $1 ; exit 0 }')" ]] && \
	PH_RET_CODE="1"
return "$PH_RET_CODE"
}

function ph_show_report {

[[ "$#" -gt "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "\n\033[36m%s\033[0m\n" "- Verifying 'PieHelper' configurations"
printf "\n%2s\033[31m%s\033[0m\n\n" "" "FAILED : Critical configuration issues detected"
nawk '$1 ~ /^OR$/ {
		printf "\n%s\033[36m%s\033[0m\n\n", "", $0 ;
		next
	} {
		printf "%s%s\n", "", $0
	}' "${PH_TMP_DIR}/reported_issues" 2>/dev/null
printf "\n%2s\033[31m%s\033[0m\n" "" "They need to be resolved for normal operation to continue"
printf "%2s\033[31m%s\033[0m\n\n" "" "Fix issues manually or run '${PH_SUDO} ${PH_SCRIPTS_DIR}/confpieh_ph.sh -v' to attempt automatic repair"
exit 1
}

function ph_repair_pieh {

declare PH_i=""
declare PH_APP=""
declare PH_APP_USER=""
declare PH_APPS=""
declare PH_APP2=""
declare PH_ANSWER=""
declare PH_INTAPPS=""
declare PH_SUPAPPS=""
declare PH_NEED_BOOT="no"
declare PH_MOVE_SCRIPTS_REGEX=""
declare -l PH_APPL=""
declare -l PH_APPL2=""
declare -u PH_APPU=""
declare -i PH_APP_TTY="0"

printf "\n\033[36m%s\033[0m\n\n" "- Verifying PieHelper configurations"
printf "%2s%s\n\n" "" "This will :"
printf "%4s%s\n" "" "- Verify the existence of all 'Unique' files and exit with an error if any are missing"
printf "%4s%s\n" "" "- Verify the existence of all 'Optional' files and display a warning if any are missing"
printf "%4s%s\n" "" "- Attempt to stop all 'Running' applications and exit with an error if unsuccessful"
printf "%4s%s\n" "" "- Verify the integrity of the base configuration files and repair any anomalies found (User input may be required)"
printf "%4s%s\n" "" "- Unallocate and clear configurations of all TTYs used by PieHelper ('2'->'$PH_PIEH_MAX_TTYS')"
printf "%4s%s\n" "" "- Generate new 'Derivate' files based on base configuration file content (Option values will be preserved)"
printf "%4s%s\n" "" "- Allocate 'TTY2' to 'PieHelper'"
printf "%4s%s\n" "" "- Recursively remove all files and directories under your installation directory not related to PieHelper"
printf "%4s%s\n" "" "- Reapply default ownership and permissions and reconfigure all required ACLs and sudo rights"
printf "%4s%s\n\n" "" "- Reboot your system if required"
while [[ "$PH_ANSWER" != @(y|n) ]]
do
	[[ "$PH_COUNT" -gt "0" ]] && printf "\n%10s\033[31m%s\033[0m\n\n" "" "ERROR : Invalid response"
	printf "%8s%s" "" "--> Continue verification of PieHelper (y/n) ? "
	read PH_ANSWER 2>/dev/null
	ph_screen_input "$PH_ANSWER"
	((PH_COUNT++))
done
printf "%10s\033[32m%s\033[0m\n" "" "OK"
ph_set_result -r 0
if [[ "$PH_ANSWER" == "n" ]]
then
	ph_set_result -w -m "Quit at user request"
	ph_show_result
	return "$?"
fi
"$PH_SUDO" rm "${PH_TMP_DIR}/.first_run" 2>/dev/null
for PH_i in "$PH_SCRIPTS_DIR" "${PH_SCRIPTS_DIR}/../app/expect" "$PH_FILES_DIR" "$PH_MENUS_DIR" "$PH_CONF_DIR" "${PH_CONF_DIR}/distros" \
	"${PH_MAIN_DIR}" "${PH_MAIN_DIR}/distros" "${PH_SCRIPTS_DIR}/app/post_cmds" "${PH_SCRIPTS_DIR}/app/pre_cmds" "$PH_MNT_DIR" \
	"$PH_TMP_DIR" "$PH_BUILD_DIR" "$PH_SNAPSHOT_DIR" "$PH_TEMPLATES_DIR" "$PH_EXCLUDES_DIR" "${PH_FILES_DIR}/stored"
do
	ph_check_object_existence -o "$PH_i" || \
		return 1
done
for PH_i in LoginScript StartScript StopScript RestartScript StartScriptPieH StopScriptPieH RestartScriptPieH MovetoPieHScript \
	MovefromPieHScript MoveScript Kodi_conf Moonlight_conf PieHelper_conf Emulationstation_conf Bash_conf X11_conf Ctrls_conf \
	OOSapp_conf
do
	ph_check_object_existence -o "${PH_TEMPLATES_DIR}/${PH_i}.template" || \
		return 1
done
for PH_i in default_apps_X default_apps_GL
do
	ph_check_object_existence -o "${PH_FILES_DIR}/${PH_i}" || \
		return 1
done
for PH_i in Advanced Controllers Main PieHelper OptsManagement_PieHelper AppManagement_PieHelper TTYManagement_PieHelper OS PS3 \
	PS4 OSdefaults Settings XBOX360
do
	ph_check_object_existence -o "${PH_MENUS_DIR}/${PH_i}.lst" || \
		return 1
done
for PH_i in confopts_ph confoper_ph confapps_ph confctrl_ph listblue_ph listmoon_ph confgena_ph confpieh_ph app/post_cmds/Kodi-POST \
	app/post_cmds/PieHelper-POST app/pre_cmds/PieHelper-PRE app/pre_cmds/Kodi-PRE
do
	ph_check_object_existence -o "${PH_SCRIPTS_DIR}/${PH_i}.sh" || \
		return 1
done
for PH_i in "${PH_CHECK_SUPPORTED[@]}"
do
	ph_check_object_existence -o "${PH_CONF_DIR}/distros/${PH_i}.conf" || \
		return 1
done
for PH_i in "${PH_SUPPORTED_DISTROS[@]}"
do
	ph_check_object_existence -o "${PH_MAIN_DIR}/distros/functions.${PH_i}" || \
		return 1
done
for PH_i in functions functions.update functions.user
do
	ph_check_object_existence -o "${PH_MAIN_DIR}/${PH_i}" || \
		return 1
done
ph_check_object_existence -o "${PH_SCRIPTS_DIR}/../app/expect/confctrls.expect" || \
	return 1
for PH_i in README.md TODO CODE_OF_CONDUCT.md INSTALL LICENSE
do
	ph_check_object_existence -o "${PH_BASE_DIR}/${PH_i}"
done
PH_MOVE_SCRIPTS_REGEX="$(ph_get_move_scripts_regex)"
"$PH_SUDO" rm "${PH_BASE_DIR}/"!(@(README.md|TODO|CODE_OF_CONDUCT.md|INSTALL|HOWTO|LICENSE|builds|snapshots|tmp|mnt|main|conf|files|.git|.github|scripts)) 2>/dev/null
"$PH_SUDO" rm "${PH_SCRIPTS_DIR}/"!(@(conf*_ph|list_ph|@(re|)start*|stop*|${PH_MOVE_SCRIPTS_REGEX})\.sh) 2>/dev/null
"$PH_SUDO" rm "${PH_SCRIPTS_DIR}/../"!(@(app|user)) 2>/dev/null
"$PH_SUDO" rm "${PH_SCRIPTS_DIR}/../app/"!(@(expect|@(pre|post)_cmds)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_SCRIPTS_DIR}/../app/expect/"!(confctrls\.expect) 2>/dev/null
"$PH_SUDO" rm -r "${PH_SCRIPTS_DIR}/../app/pre_cmds/"!(@(Kodi|PieHelper)-PRE\.sh) 2>/dev/null
"$PH_SUDO" rm -r "${PH_SCRIPTS_DIR}/../app/post_cmds/"!(@(Kodi|PieHelper)-POST\.sh) 2>/dev/null
"$PH_SUDO" rm "${PH_MAIN_DIR}/"!(@(distros|functions@(|\.@(user|update)))) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MAIN_DIR}/distros/"!(functions\.@($(sed 's/ /\|/g'<<<"${PH_SUPPORTED_DISTROS[@]}"))) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/"!(@(menus|excludes|templates|stored|VERSIONS|default_apps_@(X|GL))) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/stored/"!(@(autologin|logind)_conf|10-retropie_sh) 2>/dev/null
"$PH_SUDO" rm -r "${PH_EXCLUDES_DIR}/"!(@(tar|kodi)\.excludes) 2>/dev/null
"$PH_SUDO" rm -r "${PH_TEMPLATES_DIR}/"!(@(@(Login|@(S|Res)tart|Stop|Move@(to|from)PieH|Move)Script|@(@(Res|S)tart|Stop)ScriptPieH|@(Kodi|Moonlight|PieHelper|Emulationstation|Bash|X11|Ctrls|OOSapp)_conf)\.template) 2>/dev/null
"$PH_SUDO" rm "${PH_CONF_DIR}/"!(@(distros|@(supported|integrated)_apps|OS.defaults|VERSION|controller_cli_ids)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_CONF_DIR}/distros/"!(@($(sed 's/ /\|/g'<<<${PH_CHECK_SUPPORTED[@]})).conf) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MENUS_DIR}/"!(*.lst) 2>/dev/null
"$PH_SUDO" rm -r "${PH_TMP_DIR}/"!(.@(first_run|gitignore)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_BUILD_DIR}/"!(@(PieHelper*.tar|.gitignore)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_SNAPSHOT_DIR}/"!(@(PieHelper*.tar|.gitignore)) 2>/dev/null
"$PH_SUDO" rm "${PH_MNT_DIR}/"!(.gitignore) 2>/dev/null
if ! ph_check_object_existence -o sup
then
	ph_create_default_base_conf_file sup
	ph_support_app -a PieHelper
else
	printf "%8s%s\n" "" "--> Checking support for application 'PieHelper'"
	if ! nawk -v app="^PieHelper$" '$1 ~ app { exit 1 } { next }' "$PH_CONF_DIR/supported_apps" 2>/dev/null
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n" "" "--> Checking 'PieHelper' support data integrity"
		if ph_check_app_support_data_validity PieHelper
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
			ph_support_app -a PieHelper
		fi
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Supporting"
		ph_support_app -a PieHelper
	fi
fi
. "$PH_CONF_DIR"/PieHelper.conf >/dev/null 2>&1
if ! ph_check_object_existence -o int
then
	ph_create_default_base_conf_file int
	ph_integrate_app -a PieHelper
else
	printf "%8s%s\n" "" "--> Checking integration for application 'PieHelper'"
	if ! nawk -v app=^"PieHelper"$ '$1 ~ app { exit 1 } { next }' "$PH_CONF_DIR"/integrated_apps 2>/dev/null
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n" "" "--> Checking 'PieHelper' integration data integrity"
		if ph_check_app_integration_data_validity PieHelper
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted integration data found -> Reintegrating"
			ph_integrate_app -a PieHelper
		fi
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Integrating"
		ph_integrate_app -a PieHelper
	fi
fi
PH_RUN_USER="$(ph_get_app_user_from_app_name PieHelper)"
printf "%8s%s\n" "" "--> Checking PieHelper path extension"
if [[ ! -f "/etc/profile.d/PieHelper-path.sh" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning (Not found) -> Creating"
	ph_pieh_configured_path_conf || return 1
	. /etc/profile.d/PieHelper-path.sh >/dev/null 2>&1
	PH_NEED_BOOT="yes"
else
	printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
fi
PH_INTAPPS="$(nawk 'BEGIN { ORS =  " " } $1 !~ /^PieHelper$/ { print $1 }' "$PH_CONF_DIR/integrated_apps" 2>/dev/null)"
PH_SUPAPPS="$(nawk 'BEGIN { ORS =  " " } $1 !~ /^PieHelper$/ { print $1 }' "$PH_CONF_DIR/supported_apps" 2>/dev/null)"
for PH_APP in $(echo -n "$PH_INTAPPS")
do
        printf "%8s%s\n" "" "--> Checking support for integrated application '$PH_APP'"
        for PH_APP2 in $(echo -n "$PH_SUPAPPS")
        do
                if [[ "$PH_APP" == "$PH_APP2" ]]
                then
                        printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
                        printf "%8s%s\n" "" "--> Checking integrated application '$PH_APP' support data integrity"
			if ph_check_app_support_data_validity "$PH_APP"
			then
                        	printf "%10s\033[32m%s\033[0m\n" "" "OK"
			else
                                printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
				ph_support_app -a "$PH_APP"
				. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
                        fi
                        continue 2
                fi
        done
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Supporting"
	ph_support_app -a "$PH_APP"
	. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
	[[ -z "$PH_APPS" ]] && PH_APPS="$PH_APP" || PH_APPS="$PH_APPS $PH_APP"
done
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
	for PH_APP2 in $(echo -n "$PH_INTAPPS")
	do
		[[ "$PH_APP" == "$PH_APP2" ]] && continue 2
	done
        printf "%8s%s\n" "" "--> Checking unintegrated application '$PH_APP' support data integrity"
	if ph_check_app_support_data_validity "$PH_APP"
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
		ph_support_app -a "$PH_APP"
		. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
	fi
done
[[ -n "$PH_APPS" ]] && PH_SUPAPPS="$PH_SUPAPPS $PH_APPS"
if ! ph_stop_all_running_apps
then
	ph_show_result
	return "$?"
fi
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
        printf "%8s%s\n" "" "--> Checking integration for supported application '$PH_APP'"
        for PH_APP2 in $(echo -n "$PH_INTAPPS")
        do
                if [[ "$PH_APP" == "$PH_APP2" ]]
                then
                        printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
                        printf "%8s%s\n" "" "--> Checking supported application '$PH_APP' integration data integrity"
			if ph_check_app_integration_data_validity "$PH_APP"
			then
                        	printf "%10s\033[32m%s\033[0m\n" "" "OK"
			else
                                printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted integration data found -> Reintegrating"
				ph_integrate_app -a "$PH_APP"
                        fi
                        continue 2
                fi
        done
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Skipping"
done
printf "%8s%s\n" "" "--> Clearing 'TTY2' -> 'TTY$PH_PIEH_MAX_TTYS' configurations"
for ((PH_i=2;PH_i<="$PH_PIEH_MAX_TTYS";PH_i++))
do
        rm -r /etc/systemd/system/getty@tty"$PH_i".service.d 2>/dev/null
        rm -r /etc/profile.d/PieHelper_tty"$PH_i".sh 2>/dev/null
done
for PH_APP in "PieHelper" $(echo -n "$PH_INTAPPS")
do
	nawk -v app=^"$PH_APP"$ '$1 ~ app { print $1 "\t" $2 "\t" "-" ; next } { print }' "$PH_CONF_DIR/integrated_apps" >/tmp/integrated_apps_tmp 2>/dev/null
	[[ "$?" -eq "0" ]] && mv /tmp/integrated_apps_tmp "$PH_CONF_DIR/integrated_apps" 2>/dev/null
done
printf "%10s\033[32m%s\033[0m\n" "" "OK"
ph_run_with_rollback -c "ph_store_all_options"
for PH_APP in "Ctrls" "PieHelper" ${PH_SUPAPPS}
do
	ph_create_app_conf_file "$PH_APP"
	. "${PH_CONF_DIR}/${PH_APP}.conf"
	mv "${PH_CONF_DIR}/${PH_APP}.conf" "${PH_CONF_DIR}/temp" 2>/dev/null
done
if [[ "$PH_DISTRO" == "Debian" ]]
then
        PH_DISTRO_REL="$(lsb_release -a 2>/dev/null | nawk '$1 ~ /^Codename:/ { printf $2 }')"
	if [[ ! -L "$PH_CONF_DIR/distros/$PH_DISTRO.conf" ]]
	then
		ph_create_empty_file -t link -s "$PH_CONF_DIR/distros/$PH_DISTRO_REL.conf" -d "$PH_CONF_DIR/distros/$PH_DISTRO.conf"
	fi
fi
for PH_i in cont os defaults alloweds
do
	ph_create_default_base_conf_file "$PH_i"
done
for PH_APP in "PieHelper" "Ctrls" $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_alloweds "$PH_APP"
done
for PH_APP in "PieHelper" "Ctrls" $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_defaults "$PH_APP"
done
ph_run_with_rollback -c "ph_retrieve_stored_options"
ph_setup_tty -a "PieHelper" -u "$PH_RUN_USER" -t "2"
printf "%8s%s\n" "" "--> Generating 'Derivate' miscellaneous files"
"$PH_SUDO" rm "${PH_EXCLUDES_DIR}/"* 2>/dev/null
cat >"${PH_EXCLUDES_DIR}/tar.excludes" <<EOF
./.git
./.github
./builds/PieHelper*
./snapshots/PieHelper*
./files/stored/autologin_conf
./files/stored_options
./files/stored/logind_conf
./files/stored/10-retropie_sh
./tmp/*
./mnt/*/*
EOF
cat >"${PH_EXCLUDES_DIR}/kodi.excludes" <<EOF
./.kodi/temp/*
./.kodi/addons/temp/*
EOF
rm -r "${PH_EXCLUDES_DIR}/"!(@(tar|kodi).excludes) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/"!(@(exclude|template)s) 2>/dev/null
mkdir "$PH_TEMPLATES_DIR}/temp" 2>/dev/null
mv "${PH_TEMPLATES_DIR}/"+(LoginScript|StartScript|StopScript|RestartScript|StartScriptPieH|StopScriptPieH|RestartScriptPieH|MovetoPieHScript|MovefromPieHScript|MoveScript|Kodi_conf|Moonlight_conf|PieHelper_conf|Emulationstation_conf|Bash_conf|X11_conf|Ctrls_conf|OOSapp_conf)".template" "${PH_TEMPLATES_DIR}/temp" 2>/dev/null
"$PH_SUDO" rm -r "${PH_TEMPLATES_DIR}/"!(temp) 2>/dev/null
mv "${PH_TEMPLATES_DIR}/temp/"* "$PH_TEMPLATES_DIR" 2>/dev/null
rmdir "${PH_TEMPLATES_DIR}/temp" 2>/dev/null
printf "%10s\033[32m%s\033[0m\n" "" "OK"
mkdir "$PH_SCRIPTS_DIR/temp" 2>/dev/null
mv "${PH_SCRIPTS_DIR}/"@(conf|list)*.sh "${PH_SCRIPTS_DIR}/temp" 2>/dev/null
for PH_APP in "PieHelper" $(echo -n "$PH_INTAPPS")
do
        ph_create_app_scripts "$PH_APP"
        PH_APPL="${PH_APP:0:4}"
        mv "$PH_SCRIPTS_DIR/start$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        mv "$PH_SCRIPTS_DIR/stop$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        mv "$PH_SCRIPTS_DIR/restart$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        for PH_APP2 in $(echo -n "$PH_INTAPPS")
	do
		PH_APPL2="${PH_APP2:0:4}"
		if [[ "$PH_APP" != "$PH_APP2" ]]
		then
			mv "$PH_SCRIPTS_DIR/$PH_APPL""to$PH_APPL2.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
			mv "$PH_SCRIPTS_DIR/$PH_APPL2""to$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
		fi
	done
done
rm -r "$PH_SCRIPTS_DIR/"!(temp) 2>/dev/null
mv "$PH_SCRIPTS_DIR/temp/"* "$PH_SCRIPTS_DIR" 2>/dev/null
rmdir "$PH_SCRIPTS_DIR/temp" 2>/dev/null
mkdir -p "$PH_MENUS_DIR/temp" 2>/dev/null
mv "$PH_MENUS_DIR/"@(Advanced.lst|Controllers.lst|Main.lst|PieHelper.lst|OptsManagement_PieHelper.lst|AppManagement_PieHelper.lst|TTYManagement_PieHelper.lst|OS.lst|PS3.lst|PS4.lst|XBOX360.lst|OSdefaults.lst|Settings.lst) "$PH_MENUS_DIR/temp" 2>/dev/null
rm -r "$PH_MENUS_DIR/"!(temp) 2>/dev/null
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_menus "$PH_APP"
done
mv "$PH_MENUS_DIR/temp/"* "$PH_MENUS_DIR/" 2>/dev/null
ph_link_app_to_menu "PieHelper"
rmdir "$PH_MENUS_DIR/temp" 2>/dev/null
ph_set_app_for_start PieHelper
rm /etc/sudoers.d/020_pieh-* 2>/dev/null
ph_secure_pieh -t never
if [[ "$PH_NEED_BOOT" == "yes" ]]
then
	ph_show_result
	printf "\n%s\n\n" "" "A reboot is required since the PATH and LD_LIBRARY_PATH extension was reinstalled"
	printf "%s" "Press 'Enter' to reboot and continue"
	read 2>/dev/null
	chvt 1
	init 6
fi
ph_show_result
return "$?"
}

function ph_enable_app_tty {

declare PH_TTYS="$*"
declare -i PH_APP_TTY="0"

[[ "$#" -lt "1" || "$#" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP_TTY in ${PH_TTYS}
do
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Enabling " "'tty${PH_APP_TTY}'"
	if systemctl is-enabled getty@tty1 >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
        	if ! "$PH_SUDO" systemctl enable "getty@tty${PH_APP_TTY}" >/dev/null 2>&1
		then
			ph_run_with_rollback -c false -m "Could not enable" || \
				return 1
		fi
		ph_add_value_to_param -p PH_DISABLE_TTYS -v "$PH_APP_TTY"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_pieh_configured_path_conf {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Creating the PATH and LD_LIBRARY_PATH extension for PieHelper"
if [[ ! -f /etc/profile.d/PieHelper-path.sh ]]
then
	if ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/profile.d/PieHelper-path.sh'"
	then
		if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/profile.d/PieHelper-path.sh' -l 'export \"LD_LIBRARY_PATH=/usr/local/lib:\${LD_LIBRARY_PATH}\"'"
		then
			if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/profile.d/PieHelper-path.sh' -l 'export \"PATH=/usr/local/bin:${PH_SCRIPTS_DIR}:\${PATH}\"'"
			then
				ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v "path"
				ph_run_with_rollback -c true && \
					return "$?"
			fi
		fi
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_set_user_group_membership {

declare PH_i=""
declare PH_APP_USER=""
declare PH_APP_USER_GROUPS=""
declare PH_APP_USER_CUR_GROUPS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts u:g: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in u)
                PH_APP_USER="$OPTARG" ;;
			     g)
		PH_APP_USER_GROUPS="$OPTARG" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Setting secondary groups for user " "'${PH_APP_USER}'"
PH_APP_USER_CUR_GROUPS="$(groups "$PH_APP_USER" 2>/dev/null | nawk 'BEGIN { \
		OFS = "," \
	} { \
		for (i=3;i<=NF;i++) { \
			if (NF==i) { \
				printf $i \
			} else { \
				printf "%s", $i "," \
			} \
		} \
	}')"
if [[ "$( (for PH_i in ${PH_APP_USER_CUR_GROUPS//,/ }; \
do \
	echo "$PH_i"; \
done) | sort -u)" != "$( (for PH_i in ${PH_APP_USER_GROUPS//,/ } ${PH_APP_USER_CUR_GROUPS//,/ }; \
	do \
		echo "$PH_i"; \
	done) | sort -u)" ]]
then
	PH_APP_USER_GROUPS="$( (for PH_i in ${PH_APP_USER_GROUPS//,/ } ${PH_APP_USER_CUR_GROUPS//,/ }; \
	do \
		echo "$PH_i"; \
	done) | sort -u)"
	if "$PH_SUDO" usermod -G "$PH_APP_USER_GROUPS" "$PH_APP_USER" >/dev/null 2>&1
	then
		ph_add_value_to_param -p PH_GROUPS -v "${PH_APP_USER}'${PH_APP_USER_CUR_GROUPS}"
		ph_run_with_rollback -c true -m "${PH_APP_USER_GROUPS}"
	else
		ph_run_with_rollback -c false -m "Could not set" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_unblacklist_kernel_module {

declare PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Unblacklisting kernel module " "'${PH_MODULE}'"
if "$PH_SUDO" grep -E "^blacklist ${PH_MODULE}$" /etc/modprobe.d/xboxdrv-blacklist.conf >/dev/null 2>&1
then
	if ! ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/modprobe.d/xboxdrv-blacklist.conf' -l 'blacklist ${PH_MODULE}'"
	then
		ph_run_with_rollback -c false -m "Could not unblacklist" || \
			return 1
	else
		ph_add_value_to_param -p PH_BLACKLIST_MODULES -v "$PH_MODULE"
		ph_run_with_rollback -c true && \
			return "$?"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
}

function ph_blacklist_kernel_module {

declare PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	ph_run_with_rollback -c "ph_unload_kernel_module '${PH_MODULE}'" || \
		return 1
fi
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Blacklisting kernel module " "'${PH_MODULE}'"
if [[ ! -f /etc/modprobe.d/xboxdrv-blacklist.conf ]]
then
	if ! ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/modprobe.d/xboxdrv-blacklist.conf'"
	then
		ph_run_with_rollback -c false -m "Could not blacklist" || \
			return 1
	fi
fi
if ! "$PH_SUDO" grep -E "^blacklist ${PH_MODULE}$" /etc/modprobe.d/xboxdrv-blacklist.conf >/dev/null 2>&1
then
	if ph_run_with_rollback -c "ph_add_line_to_file -r -f /etc/modprobe.d/xboxdrv-blacklist.conf -l 'blacklist ${PH_MODULE}'"
	then
		ph_add_value_to_param -p PH_UNBLACKLIST_MODULES -v "$PH_MODULE"
		ph_run_with_rollback -c true && \
			return "$?"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return 0
fi
ph_run_with_rollback -c false -m "Could not blacklist" || \
	return 1
}

function ph_load_kernel_module {

declare PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Loading kernel module " "'${PH_MODULE}'"
if ! grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	if ! "$PH_SUDO" modprobe "$PH_MODULE" >/dev/null 2>&1
	then
		ph_run_with_rollback -c false -m "Could not load" || \
			 return 1
	fi
	ph_add_value_to_param -p PH_UNLOAD_MODULES -v "$PH_MODULE"
	ph_run_with_rollback -c true
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_unload_kernel_module {

declare PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[32m%s\033[0m\n" "" "--> Unloading kernel module " "'${PH_MODULE}'"
if grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	if ! "$PH_SUDO" rmmod "$PH_MODULE" >/dev/null 2>&1
	then
		ph_run_with_rollback -c false -m "Could not unload" || \
			return 1
	fi
	ph_add_value_to_param -p PH_LOAD_MODULES -v "$PH_MODULE"
	ph_run_with_rollback -c true
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_get_app_list_by_state {

declare PH_i=""
declare PH_APP=""
declare PH_REQ_APP_STATE=""
declare PH_STATE_MATCH_TYPE=""
declare PH_REQ_APP_STATE_PARAM=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_PIEH_ADDED_FLAG="1"

OPTIND="1"

while getopts s:t: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in s)
		[[ -n "$PH_REQ_APP_STATE" || "$OPTARG" != @(Integrated|Supported|Default|Running|Halted|Unknown|Reserved) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_REQ_APP_STATE="$OPTARG" ;;
			     t)
		[[ -n "$PH_STATE_MATCH_TYPE" || "$OPTARG" != @(exact|minimum) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_STATE_MATCH_TYPE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_REQ_APP_STATE" || -z "$PH_STATE_MATCH_TYPE" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -a PH_APP_LIST
case "$PH_REQ_APP_STATE" in Integrated)
	PH_REQ_APP_STATE_PARAM="-i" ;;
			    Supported)
	PH_REQ_APP_STATE_PARAM="-s" ;;
			    Default)
	PH_REQ_APP_STATE_PARAM="-d" ;;
			    Halted)
	PH_REQ_APP_STATE_PARAM="-h" ;;
			    Running)
	PH_REQ_APP_STATE_PARAM="-r" ;;
			    Unknown)
	PH_REQ_APP_STATE_PARAM="-u" ;;
			    Reserved)
	PH_REQ_APP_STATE_PARAM="-v" ;;
esac
for PH_APP in $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $1 \
	}' "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}" 2>/dev/null)
do
	for PH_i in "${PH_APP_LIST[@]}"
	do
		[[ "$PH_i" == "$PH_APP" ]] && \
			continue 2
	done
	if [[ "$PH_STATE_MATCH_TYPE" == "exact" ]]
	then
		if [[ "$(ph_get_app_state_from_app_name "$PH_APP")" == "$PH_REQ_APP_STATE" ]]
		then
			PH_APP_LIST+=("$PH_APP")
		fi
	else
		if ph_check_app_state_validity -a "$PH_APP" -q ${PH_REQ_APP_STATE_PARAM}
		then
			PH_APP_LIST+=("$PH_APP")
		fi
	fi
done
for PH_i in "${PH_APP_LIST[@]}"
do
	[[ "$PH_i" == "PieHelper" ]] && \
		PH_PIEH_ADDED_FLAG="0" && \
		break
		
done
if [[ "$PH_PIEH_ADDED_FLAG" -eq "0" ]]
then
	echo -n PieHelper $(sed 's/PieHelper//g'<<<${PH_APP_LIST[@]})
else
	echo -n ${PH_APP_LIST[@]}
fi
unset PH_APP_LIST
return 0
}

function ph_configure_pieh {

declare PH_ANSWER=""
declare PH_i=""
declare PH_CONF_STATE=""
declare -i PH_COUNT="0"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_ROLLBACK_USED="yes"
PH_CONF_STATE="$(ph_get_pieh_conf_state -q)"
if [[ "$PH_CONF_STATE" == "configured" ]]
then
	ph_set_result -r 0 -w -m "PieHelper is already ${PH_CONF_STATE}"
	return 0
fi
[[ -z "$PH_RUN_USER" ]] && \
	export PH_RUN_USER="$(whoami 2>/dev/null)"
printf "%2s%s\n\n" "" "This will :"
printf "%4s%s\n" "" "- Configure '${PH_RUN_USER}' as the user account for the PieHelper application"
printf "%4s%s\n" "" "- Install all required packages"
printf "%4s%s\n" "" "- Detect and backup existing StartApp configurations made by Emulationstation (RetroPie)"
printf "%4s%s\n" "" "- Create all base configuration files"
printf "%4s%s\n" "" "- Install the PATH and LD_LIBRARY_PATH extension for PieHelper"
printf "%4s%s\n" "" "- Setup PieHelper as a 'Supported' application"
printf "%4s%s\n" "" "- Create the controller settings"
printf "%4s%s\n" "" "- Change a few system related settings"
printf "%4s%s\n" "" "- Setup PieHelper as an 'Integrated' application"
printf "%4s%s\n" "" "- Configure PieHelper as the system's StartApp"
printf "%4s%s\n" "" "- Disable the graphical environment"
printf "%4s%s\n" "" "- Allow you to update your system"
printf "%4s%s\n\n" "" "- Reboot the system into the PieHelper menu"
while [[ "$PH_ANSWER" != @(y@(es|)|n@(o|)) ]]
do
	[[ "$PH_COUNT" -gt "0" ]] && \
		printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Invalid response"
	printf "%8s%s\033[32m%s\033[0m%s" "" "--> Continue configuring PieHelper under account " "'${PH_RUN_USER}'" " (y/n) ? "
	read PH_ANSWER 2>/dev/null
	ph_screen_input "$PH_ANSWER"
	((PH_COUNT++))
done
ph_run_with_rollback -c true -m "$PH_ANSWER"
if [[ "$PH_ANSWER" == n@(o|) ]]
then
	ph_set_result -w -m "Quitting at user request"
	ph_show_result
	return "$?"
fi
if [[ "$PH_RUN_USER" != "root" ]]
then
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Checking privilege elevation rights of user " "'${PH_RUN_USER}'"
	if [[ -n "$PH_SUDO" ]]
	then
		ph_run_with_rollback -c true
	else
		ph_set_result -m "Run PieHelper as root or manually configure full sudo rights for user '${PH_RUN_USER}' as '/etc/sudoers.d/020_pieh-${PH_RUN_USER}' prior to installation"
		ph_run_with_rollback -c false -m "Not found" || \
			return 1
	fi
fi
if [[ "$PH_DISTRO" == "Debian" ]]
then
	ph_update_pkg_index || \
		return 1
fi
ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.configure_in_progress'" || \
	return 1
ph_run_with_rollback -c "ph_install_pkg lsb-release" || \
	return 1
if [[ "$PH_DISTRO" == "Debian" ]]
then
	printf "%8s%s\n" "" "--> Determining currently installed ${PH_DISTRO} release"
        PH_DISTRO_REL="$(lsb_release -a 2>/dev/null | nawk '$1 ~ /^Codename:/ { \
			printf $2 \
		}')"
	if [[ -z "$PH_DISTRO_REL" ]]
	then
		ph_set_result -m "Unable to determine the currently installed ${PH_DISTRO} release"
		ph_run_with_rollback -c false -m "Could not determine" || \
			return 1
	fi
	if [[ ! -f "${PH_CONF_DIR}/distros/${PH_DISTRO_REL}.conf" ]]
	then
		ph_set_result -m "${PH_DISTRO} release '${PH_DISTRO_REL}' is currently not supported"
		ph_run_with_rollback -c false -m "$PH_DISTRO_REL" || \
			return 1
	else
		ph_run_with_rollback -c true -m "${PH_DISTRO_REL}"
	fi
	if [[ ! -L "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" ]]
	then
		ph_run_with_rollback -c "ph_create_empty_file -t link -s '${PH_CONF_DIR}/distros/${PH_DISTRO_REL}.conf' -d '${PH_CONF_DIR}/distros/${PH_DISTRO}.conf'" || \
			return 1
	fi
	printf "%8s%s\n" "" "--> Loading release-dependent codebase"
	if source "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" 2>/dev/null
	then
		ph_run_with_rollback -c true
	else
		ph_set_result -m "An error occured trying to load codebase file '${PH_CONF_DIR}/distros/${PH_DISTRO}.conf'"
		ph_run_with_rollback -c false -m "Could not load" || \
			return 1
	fi
fi
printf "%8s%s\n" "" "--> Checking parent directory"
if [[ "$PH_BASE_DIR" == "${PH_INST_DIR}/PieHelper" ]]
then
	if "$PH_SUDO" chmod -R 750 "$PH_BASE_DIR" >/dev/null 2>&1
	then
		if "$PH_SUDO" chown -R "${PH_RUN_USER}:$("$PH_SUDO" id -gn "$PH_RUN_USER" 2>/dev/null)" "$PH_BASE_DIR" >/dev/null 2>&1
		then
			ph_run_with_rollback -c true
			ph_run_with_rollback -c "ph_set_user_group_membership -u '${PH_RUN_USER}' -g 'tty,audio,video,input'" || \
				return 1
			for PH_i in acl xboxdrv git make bluez bluez-tools expect less ${PH_DISTRO_PKGS}
			do
				ph_run_with_rollback -c "ph_install_pkg '${PH_i}'" || \
					return 1
			done
			printf "%8s%s\n" "" "--> Checking for Emulationstation (RetroPie)"
			if [[ -f /usr/bin/emulationstation ]]
			then
				ph_run_with_rollback -c true -m "Found"
				ph_run_with_rollback -c "ph_pieh_configured_emul_conf" || \
					return 1
			else
				ph_run_with_rollback -c true -m "Not found"
			fi
			for PH_i in sup defaults alloweds int os cont
			do
				ph_create_default_base_conf_file "$PH_i" || \
					return 1
			done
			ph_run_with_rollback -c "ph_pieh_configured_path_conf" || \
				return 1
			ph_run_with_rollback -c "ph_support_app -a PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_create_app_items -a Ctrls -t support" || \
				return 1
			ph_run_with_rollback -c "ph_blacklist_kernel_module xpad" || \
				return 1
			for PH_i in uinput joydev
			do
				ph_run_with_rollback -c "ph_load_kernel_module '${PH_i}'" || \
					return 1
			done
			ph_run_with_rollback -c "ph_pieh_configured_logind_conf" || \
				return 1
			for ((PH_COUNT=2;PH_COUNT<="${PH_PIEH_MAX_TTYS}";PH_COUNT++))
			do
				ph_run_with_rollback -c "ph_disable_app_tty '${PH_COUNT}'" || \
					return 1
			done
			ph_run_with_rollback -c "ph_enable_app_tty 1" || \
				return 1
			ph_run_with_rollback -c "ph_integrate_app -a PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_set_app_for_start PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_set_bootenv multi-user.target" || \
				return 1
			ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.first_run'" || \
				return 1
			ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.configure_in_progress'" || \
				return 1
			PH_ANSWER=""
			PH_COUNT="0"
			while [[ "$PH_ANSWER" != @(y@(es|)|n@(o|)) ]]
			do
				[[ "$PH_COUNT" -gt "0" ]] && \
					printf "\n%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Invalid response"
				printf "%8s%s\n\n" "" "--> Perform full system update before reboot (Recommended)"
				printf "%12s%s\n" "" "- System updates can take a long time depending on the system's current version and configuration"
				printf "%12s%s\n\n" "" "- Please note that system updates are not reversible"
				printf "%12s%s" "" "Perform update (y/n) ? "
				read PH_ANSWER 2>/dev/null
				ph_screen_input "$PH_ANSWER"
				((PH_COUNT++))
			done
			ph_run_with_rollback -c true -m "$PH_ANSWER"
			if [[ "$PH_ANSWER" == y@(es|) ]]
			then
				ph_update_system || \
					return 1
			else
				[[ "$PH_DISTRO" == "Debian" ]] && \
					ph_apt_clean
			fi
			printf "%8s%s\n" "" "--> Displaying the user manual"
			sleep 2
			if less "${PH_SCRIPTS_DIR}/../HOWTO" 2>/dev/null
			then
				ph_run_with_rollback -c true -m "${PH_SCRIPTS_DIR}/../HOWTO"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not display"
				ph_set_result -r 0
			fi
			printf "\n%s" "Press Enter to reboot into the PieHelper menu"
			read 2>/dev/null
			"$PH_SUDO" init 6
		else
			ph_set_result -m "Could not recursively set ownership of directory '${PH_BASE_DIR}' to '${PH_RUN_USER}:$("$PH_SUDO" id -gn "$PH_RUN_USER" 2>/dev/null)'"
		fi
	else
		ph_set_result -m "Could not recursively set permissions for directory '${PH_BASE_DIR}' to '750'"
	fi
else
	ph_set_result -m "The directory that contains PieHelper should be called 'PieHelper' (Correct by running 'sudo mv ${PH_BASE_DIR} ${PH_BASE_DIR%/*}/PieHelper')"
	ph_run_with_rollback -c false -m "Incorrect parent" || \
		return 1
fi
}

function ph_get_filename_from_shortname {

declare PH_SHORTNAME="$1"
declare PH_FILE=""

[[ -z "$PH_SHORTNAME" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "$PH_SHORTNAME" in cont)
		PH_FILE="controller_cli_ids" ;;
			os)
		PH_FILE="OS.defaults" ;;
			int)
		PH_FILE="integrated_apps" ;;
			sup)
		PH_FILE="supported_apps" ;;
			defaults|alloweds)
		PH_FILE="options.${PH_SHORTNAME}" ;;
esac
echo -n "$PH_FILE"
return 0
}

function ph_set_bootenv {

declare PH_ENV="$1"
declare PH_ENV_ACTION=""

[[ -z "$PH_ENV" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_ENV" == "multi-user.target" ]]
then 
	PH_ENV_ACTION="disable"
	printf "%8s%s\n" "" "--> Disabling the graphical environment"
else
	PH_ENV_ACTION="enable"
	printf "%8s%s\n" "" "--> Enabling the graphical environment"
fi
if "$PH_SUDO" systemctl set-default "$PH_ENV" >/dev/null 2>&1
then
	[[ "$PH_ENV" == "graphical.target" ]] && \
		PH_ENV="multi-user.target" || \
		PH_ENV="graphical.target"
	ph_add_value_to_param -p PH_BOOTENV -v "$PH_ENV"
	ph_run_with_rollback -c true && \
		return "$?"
fi
ph_set_result -m "An error occured trying to ${PH_ENV_ACTION} the graphical environment"
ph_run_with_rollback -c false -m "Could not ${PH_ENV_ACTION}" || \
	return 1
}

function ph_do_app_routine {

declare PH_OPTION=""
declare PH_APP=""
declare PH_APP_STATE=""
declare PH_i=""
declare PH_ITEMS=""
declare PH_ROUTINE_OPTS=""
declare PH_LIST=""
declare PH_REQ_APP_STATE=""
declare PH_REQ_APP_STATE_PARAM=""
declare PH_DISP_APP_STATE=""
declare PH_FILE="integrated_apps"
declare PH_KEYWORD=""
declare PH_STRING=""
declare PH_APP_SCOPE=""
declare PH_APP_USER=""
declare PH_APP_INST_STATE=""
declare PH_CMD=""
declare PH_SKIPPING="no"
declare PH_ACTION=""
declare PH_HEADER=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_COUNT="0"
declare -i PH_TOT_LIST_MEMBERS="0"
declare -i PH_SKIP_LIST_MEMBERS="0"
declare -i PH_RET_CODE="0"
declare -i PH_APP_TTY="0"
declare -u PH_APPU=""

OPTIND="1"

while getopts a:p:s:k:l:o:u: PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     p)
		[[ -n "$PH_ACTION" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ACTION="$OPTARG" ;;
			     s) 
		[[ -n "$PH_APP_SCOPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_SCOPE="$OPTARG" ;;
			     k)
		[[ -n "$PH_KEYWORD" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_KEYWORD="$OPTARG" ;;
			     l)
		[[ -n "$PH_LIST" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_LIST="$OPTARG" ;;
			     o)
		[[ -n "$PH_ROUTINE_OPTS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ROUTINE_OPTS="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

if [[ -n "$PH_LIST" ]]
then
	PH_CMD="ph_do_app_routine -p '${PH_ACTION}' -k '${PH_i}' -s '${PH_APP_SCOPE}' -o '${PH_ROUTINE_OPTS}'"
fi
if [[ -n "$PH_APP" ]]
then
	PH_LIST="$PH_APP"
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_ACTION" in list)
			PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
			case "$PH_APP_INST_STATE" in "")
				PH_CMD="printf \"%4s%s\\n\" \"\" \"${PH_APP} : Unknown\"" ;;
						     *)
				PH_CMD="printf \"%4s%s\\n\" \"\" \"${PH_APP} : ${PH_APP_INST_STATE}\"" ;;
			esac ;;
			     tty)
			PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
			if [[ "$PH_APP_TTY" -eq "1" ]]
			then
				PH_CMD="printf \"%4s%s\\n\" \"\" \"${PH_APP} : None\""
			else
				PH_CMD="printf \"%4s%s\\n\" \"\" \"${PH_APP} : tty${PH_APP_TTY}\""
			fi ;;
			     info)
			PH_CMD="ph_show_app_info '${PH_APP}'" ;;
			     sup)
			PH_CMD="ph_support_app -a '${PH_APP}' ${PH_ROUTINE_OPTS}" ;;
			     unsup)
			PH_CMD="ph_unsupport_app -a '${PH_APP}' ${PH_ROUTINE_OPTS}" ;;
			     int)
			PH_CMD="ph_integrate_app -a '${PH_APP}' ${PH_ROUTINE_OPTS}" ;;
			     unint)
			PH_CMD="ph_unintegrate_app -a '${PH_APP}' ${PH_ROUTINE_OPTS}" ;;
			     inst)
			PH_CMD="ph_install_app -a '${PH_APP}' -u '${PH_APP_USER}'" ;;
			     uninst)
			PH_CMD="ph_uninstall_app -a '${PH_APP}'" ;;
			     update)
			PH_CMD="ph_update_app -a '${PH_APP}'" ;;
			     conf)
			PH_CMD="ph_configure_app -a '${PH_APP}'" ;;
			     move)
			PH_CMD="ph_move_app -a '${PH_APP}' ${PH_ROUTINE_OPTS}" ;;
			     start)
			PH_CMD="ph_set_app_for_start '${PH_APP}'" ;;
			     mk_conf)
			PH_CMD="ph_create_app_conf_file '${PH_APP}'" ;;
			     mk_defaults)
			PH_CMD="ph_create_app_defaults '${PH_APP}'" ;;
			     mk_alloweds)
			PH_CMD="ph_create_app_alloweds '${PH_APP}'" ;;
			     mk_menus)
			PH_CMD="ph_create_app_menus '${PH_APP}'" ;;
			     mk_scripts)
			PH_CMD="ph_create_app_scripts '${PH_APP}'" ;;
			     mk_dir)
			PH_CMD="ph_create_app_cifs_mpt '${PH_APP}'" ;;
			     mk_all)
			if [[ "$PH_APP_STATE" == "Integrated" ]]
			then
				PH_ITEMS="conf,defaults,alloweds,menus,scripts,dir"
			else
				PH_ITEMS="conf,defaults,alloweds,menus"
			fi ;;
			     rm_conf)
			PH_CMD="ph_remove_app_conf_file '${PH_APP}'" ;;
			     rm_defaults)
			PH_CMD="ph_remove_app_defaults '${PH_APP}'" ;;
			     rm_alloweds)
			PH_CMD="ph_remove_app_alloweds '${PH_APP}'" ;;
			     rm_menus)
			PH_CMD="ph_remove_app_menus '${PH_APP}'" ;;
			     rm_scripts)
			PH_CMD="ph_remove_app_scripts '${PH_APP}'" ;;
			     rm_dir)
			PH_CMD="ph_remove_app_cifs_mpt '${PH_APP}'" ;;
			     rm_all)
			if [[ "$PH_APP_STATE" == "Integrated" ]]
			then
				PH_ITEMS="dir,scripts,menus,alloweds,defaults,conf"
			else
				PH_ITEMS="menus,alloweds,defaults,conf"
			fi ;;
	esac
fi
if [[ -n "$PH_ITEMS" && -n "$PH_APP" ]]
then
	for PH_i in ${PH_ITEMS//,/ }
	do
		((PH_COUNT++))
		confapps_ph.sh -p "${PH_ACTION:0:3}${PH_i}" -a "$PH_APP"
		ph_set_result -t -r "$?"
	done
	unset PH_ROUTINE_DEPTH PH_ROUTINE_FLAG PH_SKIP_DEPTH_MEMBERS
	ph_show_result -t
	exit "$?"
fi
case "$PH_KEYWORD" in def)
		PH_DISP_APP_STATE="Default"
		PH_FILE="default_apps${PH_FILE_SUFFIX}" ;;
		      sup)
		PH_DISP_APP_STATE="Supported"
		PH_FILE="supported_apps" ;;
		      int)
		PH_DISP_APP_STATE="Integrated" ;;
		      halt)
		PH_DISP_APP_STATE="Halted" ;;
		      run)
		PH_DISP_APP_STATE="Running" ;;
		      start)
		PH_DISP_APP_STATE="StartApp" ;;
		      unk)
		PH_DISP_APP_STATE="Unknown"
		PH_FILE="/dev/null" ;;
esac
case "$PH_ACTION" in list)
	case "$PH_KEYWORD" in int)
		PH_REQ_APP_STATE="Integrated" ;;
			      sup)
		PH_REQ_APP_STATE="Supported" ;;
			      def)
		PH_REQ_APP_STATE="Default" ;;
			      halt)
		PH_REQ_APP_STATE="Halted" ;;
			      run)
		PH_REQ_APP_STATE="Running" ;;
			      start)
		PH_REQ_APP_STATE="Halted" ;;
			      unk)
		PH_REQ_APP_STATE="Unknown" ;;
	esac ;;
		     tty)
	PH_REQ_APP_STATE="Halted" ;;
		     info)
	PH_REQ_APP_STATE="Supported" ;;
		     sup)
	PH_REQ_APP_STATE="Unknown" ;;
		     unsup)
	PH_REQ_APP_STATE="Supported" ;;
		     int)
	PH_REQ_APP_STATE="Supported" ;;
		     unint)
	PH_REQ_APP_STATE="Integrated" ;;
		     inst)
	PH_REQ_APP_STATE="Unknown" ;;
		     uninst)
	PH_REQ_APP_STATE="Unknown" ;;
		     update)
	PH_REQ_APP_STATE="Supported" ;;
		     conf)
	PH_REQ_APP_STATE="Supported" ;;
		     move)
	PH_REQ_APP_STATE="Halted" ;;
		     start)
	PH_REQ_APP_STATE="Integrated" ;;
		     mk_conf|mk_defaults|mk_alloweds|mk_menus)
	PH_REQ_APP_STATE="Unknown" ;;
		     mk_scripts|mk_dir)
	PH_REQ_APP_STATE="Supported" ;;
		     rm_conf|rm_defaults|rm_alloweds|rm_menus)
	PH_REQ_APP_STATE="Supported" ;;
		     rm_scripts|rm_dir)
	PH_REQ_APP_STATE="Integrated" ;;
esac
case "$PH_REQ_APP_STATE" in Integrated)
	PH_REQ_APP_STATE_PARAM="-i" ;;
	    		    Supported)
	PH_REQ_APP_STATE_PARAM="-s" ;;
			    Default)
	PH_REQ_APP_STATE_PARAM="-u" ;;
			    Halted)
	PH_REQ_APP_STATE_PARAM="-h" ;;
			    Running)
	PH_REQ_APP_STATE_PARAM="-r" ;;
			    StartApp)
	PH_REQ_APP_STATE_PARAM="-i" ;;
			    Unknown)
	PH_REQ_APP_STATE_PARAM="-u" ;;
esac
[[ "$PH_KEYWORD" == "start" ]] && \
	PH_LIST="$PH_PIEH_STARTAPP"
if [[ -z "$PH_APP" && -z "$PH_LIST" ]]
then
	case "$PH_KEYWORD" in halt)
		for PH_i in $(ph_get_app_list_by_state -s Halted -t exact)
		do
			[[ -z "$PH_LIST" ]] && \
				PH_LIST="$PH_i" || \
				PH_LIST="${PH_LIST},${PH_i}"
		done ;;
			      run)
		for PH_i in $(ph_get_app_list_by_state -s Running -t exact)
		do
			[[ -z "$PH_LIST" ]] && \
				PH_LIST="$PH_i" || \
				PH_LIST="${PH_LIST},${PH_i}"
		done ;;
	esac
	if [[ -z "$PH_LIST" ]]
	then
		PH_LIST="$(nawk 'BEGIN { \
				ORS = "," \
			} { \
				print $1 \
			}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)"
	fi
fi
if [[ -z "$PH_CMD" ]]
then
	PH_CMD="ph_do_app_routine -a '\${PH_i}' -p '${PH_ACTION}' -k '${PH_KEYWORD}' -s '${PH_APP_SCOPE}' -o '${PH_ROUTINE_OPTS}'"
fi
PH_TOT_LIST_MEMBERS="$(echo ${PH_LIST//,/ } | nawk '{ \
		printf NF \
	}')"
for PH_i in ${PH_LIST//,/ }
do
	PH_HEADER=""
	PH_ROUTINE_FLAG="1"
	PH_SKIPPING="no"
	PH_STRING="'$PH_APP'"
	if [[ "$PH_ACTION" == @(list|tty) ]]
	then
		if [[ -n "$PH_APP" && "$PH_ROUTINE_DEPTH" -eq "0" ]]
		then
			PH_HEADER="-"
		else
			if [[ -z "$PH_APP" && -n "$PH_KEYWORD" && "$PH_COUNT" -eq "0" ]]
			then
				PH_HEADER="-"
				PH_STRING="'${PH_DISP_APP_STATE}' applications"
			fi
		fi
	else
		[[ -n "$PH_APP" ]] && \
			PH_HEADER="-"
	fi
	if [[ -n "$PH_HEADER" ]]
	then
		case "${PH_ACTION:3}" in conf)
				PH_ITEMS="configuration file" ;;
				    menus)
				PH_ITEMS="menu items" ;;
				    scripts)
				PH_ITEMS="management scripts" ;;
				    dir)
				PH_ITEMS="default CIFS mountpoint" ;;
				    defaults|alloweds)
				PH_ITEMS="${PH_ACTION:3:7} option values" ;;
		esac
		case "$PH_ACTION" in list)
			PH_HEADER="${PH_HEADER} Listing ${PH_STRING}" ;;
				     tty)
			PH_HEADER="${PH_HEADER} Displaying ${PH_STRING} tty" ;;
				     info)
			PH_HEADER="${PH_HEADER} Displaying ${PH_STRING} info" ;;
				     sup)
			PH_HEADER="${PH_HEADER} Supporting ${PH_STRING}" ;;
				     unsup)
			PH_HEADER="${PH_HEADER} Unsupporting ${PH_STRING}" ;;
				     int)
			PH_HEADER="${PH_HEADER} Integrating ${PH_STRING}" ;;
				     unint)
			PH_HEADER="${PH_HEADER} Unintegrating ${PH_STRING}" ;;
				     inst)
			PH_HEADER="${PH_HEADER} Installing ${PH_STRING}" ;;
				     uninst)
			PH_HEADER="${PH_HEADER} Uninstalling ${PH_STRING}" ;;
				     update)
			PH_HEADER="${PH_HEADER} Updating ${PH_STRING}" ;;
				     conf)
			clear
			PH_HEADER="${PH_HEADER} Configuring ${PH_STRING}"
			[[ "$PH_APP" == "PieHelper" ]] && \
				PH_HEADER="${PH_HEADER} version '${PH_VERSION}'" ;;
				     move)
			PH_HEADER="${PH_HEADER} Moving ${PH_STRING}" ;;
				     start)
			PH_HEADER="${PH_HEADER} Setting StartApp ${PH_STRING}" ;;
				     mk_*)
			PH_HEADER="${PH_HEADER} Creating ${PH_ITEMS} for ${PH_STRING}" ;;
				     rm_*)
			PH_HEADER="${PH_HEADER} Removing ${PH_ITEMS} for ${PH_STRING}" ;;
		esac
		[[ "$PH_APP_SCOPE" != "all" ]] && \
			PH_HEADER="${PH_HEADER} (Filtering on '${PH_APP_SCOPE}' apps)"
		[[ "$PH_ACTION" == @(mk_|rm_)* ]] && \
			printf "\n"
	fi
	if [[ -n "$PH_HEADER" ]]
	then
		printf "\033[36m%s\033[0m\n" "$PH_HEADER"
		[[ "$PH_ACTION" != @(list|tty) ]] && \
			printf "\n"
	fi
	if [[ -n "$PH_APP" ]]
	then
		if [[ ! ( "$PH_i" == "Ctrls" && ! ( "$PH_ACTION" == "start" && "$PH_i" == "prompt" ) && \
			! ( "$PH_ACTION" == "list" && "$PH_KEYWORD" == "start" && "$PH_i" == "none" )) ]]
		then
			if [[ "$PH_APP_SCOPE" == "Out-of-scope" ]]
			then
				if ph_check_app_state_validity -a "$PH_i" -q -d
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} is not an out-of-scope application -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			if [[ "$PH_APP_SCOPE" == "Default" ]]
			then
				if ! ph_check_app_state_validity -a "$PH_i" -q -d
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} not a default application -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			if ! ph_check_app_state_validity -a "$PH_i" -q ${PH_REQ_APP_STATE_PARAM}
			then
				if [[ "$PH_ACTION" != mk_* && ! ( "$PH_i" == "PieHelper" && "$PH_ACTION" == "conf" ) ]] 
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} is not '${PH_REQ_APP_STATE}' -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_i")"
			case "$PH_ACTION" in conf|move|mk_*|rm_*)
						[[ "$PH_APP_STATE" == "Running" && "$PH_ACTION" != "move" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == @(move|mk_menus|rm_menus) ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
					     unsup|int)
						[[ "$PH_APP_STATE" != "$PH_REQ_APP_STATE" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == "unsup" ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
					     unint|update)
						[[ "$PH_APP_STATE" == "Running" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == "unint" ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
			esac
			PH_APPU="${PH_i:0:4}"
			[[ "$PH_ACTION" == @(mk|rm)_dir && "$(eval "echo -n \"\$PH_${PH_APPU}_CIFS_MPT\"")" == "\${PH_MNT_DIR}/${PH_APP}" ]] && \
				PH_SKIPPING="yes" && \
				PH_APP_STATE="Customized mountpoint"
			if [[ "$PH_SKIPPING" == "yes" ]]
			then
				printf "\n"
				printf "%4s\033[33m%s\033[0m\n" "" "${PH_APP_STATE} -> Skipping"
				[[ "$PH_ACTION" != @(list|tty) ]] && \
					PH_ROUTINE_FLAG="0"
				((PH_SKIP_LIST_MEMBERS++))
				continue
			fi
		fi
	fi
	((PH_COUNT++))
	if [[ "$PH_SKIP_DEPTH_MEMBERS" -ge "1" && -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		printf "\n"
	fi
	[[ "$PH_CMD" == ph_do_app_routine* ]] && \
		((PH_ROUTINE_DEPTH++))
	if [[ "$PH_ACTION" == @(list|tty) && "$PH_COUNT" -eq "1" ]]
	then
		if [[ ( "$PH_CMD" == printf* && "$PH_ROUTINE_DEPTH" -eq "0" ) || -z "$PH_APP" ]]
		then
			printf "\n"
		fi
	fi
	eval "$PH_CMD"
	PH_RET_CODE="$?"
	[[ "$PH_CMD" == printf* ]] && \
		ph_set_result -r "$PH_RET_CODE"
done
if [[ "$PH_ACTION" == @(list|tty) ]]
then
	if [[ -n "$PH_APP" && -n "$PH_KEYWORD" ]]
	then
		PH_SKIP_DEPTH_MEMBERS="$((PH_SKIP_DEPTH_MEMBERS+"${PH_SKIP_LIST_MEMBERS}"))"
		[[ "$PH_TOT_LIST_MEMBERS" -eq "$PH_SKIP_LIST_MEMBERS" ]] && \
			PH_ROUTINE_FLAG="0"
	else
		[[ "$PH_TOT_LIST_MEMBERS" -eq "$PH_SKIP_DEPTH_MEMBERS" ]] && \
			PH_ROUTINE_FLAG="0"
	fi
	if [[ -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		if [[ "$PH_ROUTINE_FLAG" -eq "0" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
		ph_set_result -t -r "$?"
	fi
	if [[ -n "$PH_KEYWORD" && -n "$PH_APP" && "$PH_ROUTINE_DEPTH" -eq "0" ]]
	then
		if [[ "$PH_SKIP_LIST_MEMBERS" -eq "1" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
	fi
	if [[ -z "$PH_KEYWORD" ]]
	then
		if [[ "$PH_COUNT" -gt "1" ]]
		then
			ph_show_result -t
		fi
	fi
else
	if [[ -z "$PH_KEYWORD" ]]
	then
		PH_TOT_LIST_MEMBERS="$PH_ROUTINE_FLAG"
	fi
	if [[ -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		[[ "$PH_ROUTINE_DEPTH" -ne "0" ]] && \
			PH_ROUTINE_FLAG="$((PH_ROUTINE_FLAG+"${PH_TOT_LIST_MEMBERS}"))"
	fi
	if [[ -n "$PH_KEYWORD" && -n "$PH_APP" ]]
	then
		if [[ "$PH_COUNT" -eq "0" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
		if [[ "$?" -eq "0" ]]
		then
			[[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]] && \
				ph_set_result -t -r 0
		else
			[[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]] && \
				ph_set_result -t -r 1
		fi
	fi
	if [[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]]
	then
		[[ "$PH_ROUTINE_DEPTH" -eq "0" && "$PH_TOT_LIST_MEMBERS" -gt "1" ]] && \
			ph_show_result -t
	fi
fi
[[ -z "$PH_APP" ]] && \
	PH_SKIP_DEPTH_MEMBERS="0"
if [[ "$PH_ROUTINE_DEPTH" -ne "0" ]]
then
	((PH_ROUTINE_DEPTH--))
else
	unset PH_ROUTINE_DEPTH PH_ROUTINE_FLAG PH_SKIP_DEPTH_MEMBERS
fi
return "$PH_RET_CODE"
}

function ph_do_app_action {

declare PH_ACTION="$1"
declare PH_APP="$2"
declare PH_APP_USER=""
declare PH_PIEH_USER=""
declare PH_APP_CMD=""
declare PH_APP_CMD_OPTS=""
declare PH_i=""
declare PH_MOON_PATH=""
declare -l PH_APPL=""
declare -u PH_APPU=""
declare -i PH_APP_TTY="0"
declare -i PH_PIEH_TTY="0"
declare -i PH_CTRL_COUNT="0"
declare -i PH_FG_CONSOLE="0"
declare -i PH_RET_CODE="0"

set +o pipefail
PH_APPU="${PH_APP:0:4}"
PH_APPL="${PH_APP:0:4}"
declare -n PH_APPU_POST_CMD="PH_${PH_APPU}_POST_CMD"
declare -n PH_APPU_PRE_CMD="PH_${PH_APPU}_PRE_CMD"
declare -n PH_APPU_CMD_OPTS="PH_${PH_APPU}_CMD_OPTS"
declare -n PH_APPU_NUM_CTRL="PH_${PH_APPU}_NUM_CTRL"
declare -n PH_APPU_USE_CTRL="PH_${PH_APPU}_USE_CTRL"
declare -n PH_APPU_CIFS_SRV="PH_${PH_APPU}_CIFS_SRV"
declare -n PH_APPU_CIFS_SHARE="PH_${PH_APPU}_CIFS_SHARE"
declare -n PH_APPU_CIFS_DIR="PH_${PH_APPU}_CIFS_DIR"
declare -n PH_APPU_CIFS_SUBDIR="PH_${PH_APPU}_CIFS_SUBDIR"
declare -n PH_APPU_PERSISTENT="PH_${PH_APPU}_PERSISTENT"

PH_MOON_PATH="$(nawk '$1 ~ /^Moonlight$/ { \
		printf $3 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_PIEH_USER="$(ph_get_app_user_from_app_name PieHelper)"
PH_PIEH_TTY="$(ph_get_app_tty_from_app_name PieHelper)"
PH_FG_CONSOLE="$("$PH_SUDO" fgconsole 2>/dev/null)"
case "$PH_ACTION" in start)
	if [[ "$PH_FG_CONSOLE" -eq "$PH_APP_TTY" ]]
	then
		printf "%8s%s\n" "" "--> Checking the configuration requirement of ${PH_APP}"
		ph_set_result -r 0
		if [[ "$PH_APP" == "Moonlight" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
			printf "%8s%s\n" "" "--> Checking for '$PH_APP' configuration presence"
			if ! "$PH_SUDO" -E su "$PH_APP_USER" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} list ${PH_MOON_SRV} 2>/dev/null" >/dev/null 2>&1
			then
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Not found"
				ph_set_result -r 1 -m "Configuration is mandatory for '$PH_APP' $PH_ACTION"
				unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
				unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
				return 1
			fi
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
			ph_set_result -r 0
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
		fi
		printf "%8s%s\n" "" "--> Checking for '$PH_APP' CIFS mount requirement"
		ph_set_result -r 0
		if [[ "$PH_APPU_CIFS_SHARE" == "no" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
			printf "%8s%s\n" "" "--> Checking for '$PH_APP' CIFS mount presence"
			ph_set_result -r 0
			if mount 2>/dev/null | nawk -v rempath="^//${PH_APPU_CIFS_SRV}$(eval "echo -n \"${PH_APPU_CIFS_DIR}${PH_APPU_CIFS_SUBDIR}\"")$" -F' on ' '$1 ~ rempath { exit 1 }'
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found -> Mounting"
				if ! ph_mount_cifs_share "$PH_APP"
				then
					ph_set_result -m "CIFS mount '//${PH_APPU_CIFS_SRV}$(eval "echo -n \"${PH_APPU_CIFS_DIR}${PH_APPU_CIFS_SUBDIR}\"")' presence on mountpoint '$(eval echo -n "$PH_APPU_CIFS_MPT")' is mandatory for '$PH_APP' $PH_ACTION"
					unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
					unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
					return 1
				fi
			else
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
			fi
		fi
		printf "%8s%s\n" "" "--> Checking for '$PH_APP' PRE-command requirement"
		ph_set_result -r 0
		if [[ -n "$PH_APPU_PRE_CMD" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes) -> Running PRE-command actions"
			printf "%8s%s\n" "" "--> Checking for '$PH_APP' PRE-command '$(eval echo -n "$PH_APPU_PRE_CMD" | nawk '{ print $1 ; exit 0 }')' presence"
			ph_set_result -r 0
			if [[ -f "$(eval echo -n "$PH_APPU_PRE_CMD" | nawk '{ print $1 ; exit 0 }')" || -L "$(eval echo -n "$PH_APPU_PRE_CMD" | nawk '{ print $1 ; exit 0 }')" ]]
			then
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
				file -b "$(eval echo -n "$PH_APPU_PRE_CMD" | nawk '{ print $1 ; exit 0 }')" 2>/dev/null | nawk 'BEGIN { rc = 0 } $0 ~ /ASCII text executable/ { exit 1 }
									$0 ~ /ASCII text/ { exit 2 }
									$0 ~ /32-bit.*executable/ { exit 3 }
									$0 ~ /32-bit.*shared object/ { exit 3 }
									$0 ~ /64-bit.*executable/ { exit 4 }
									$0 ~ /64-bit.*shared object/ { exit 4 }
									$0 ~ /directory/ { exit 5 }
									{ exit 6 }'
				case "$?" in 1|3|4)
					$(eval echo -n "$PH_APPU_PRE_CMD") 2>/dev/null ;;
				             2)
					. $(eval echo -n "$PH_APPU_PRE_CMD") 2>/dev/null ;;
					     5|6)
					false ;;
				esac
				if [[ "$?" -ne "0" ]]
				then
					printf "%8s%s\n" "" "--> Checking for '$PH_APP' PRE-command '$(eval echo -n "$PH_APPU_PRE_CMD")' validity"
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid command -> Skipping"
					ph_set_result -r 0
				fi
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found -> Skipping"
			fi
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
		fi
		printf "%8s%s\n" "" "--> Checking for '$PH_APP' controller usage requirement"
		if [[ "$PH_APPU_USE_CTRL" == "no" ]]
		then
			PH_APP_CMD_OPTS="$PH_APPU_CMD_OPTS"
			if echo "$PH_APPU_CMD_OPTS" | grep -E "PH_CTRL[1-4]$|PH_CTRL[1-4] " >/dev/null
			then
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid controller usage"
				ph_set_result -r 1 -m "Controller usage set to 'no' though mandatory when option 'PH_${PH_APPU}_CMD_OPTS' contains references to event-based input devices"
				[[ "$PH_APPU_CIFS_SHARE" == "yes" ]] && ph_umount_cifs_share "$PH_APP" >/dev/null
				unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
				unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
				return 1
			else
				printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
				ph_set_result -r 0
			fi
		else
			ph_set_result -r 0
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes) -> Configuring controllers"
			if ! ph_setup_controllers "$PH_APPU_NUM_CTRL"
			then
				ph_set_result -m "An error occurred configuring controller usage '${PH_APPU_NUM_CTRL} x ${PH_CTRL_TYPE} controller(s)' for ${PH_APP} ${PH_ACTION}"
				[[ "$PH_APPU_CIFS_SHARE" == "yes" ]] && ph_umount_cifs_share "$PH_APP" >/dev/null
				unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
				unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
				return 1
			fi
			PH_CTRL_COUNT="$(cat "$PH_CONF_DIR"/controller_cli_ids 2>/dev/null | wc -l)"
			printf "%8s%s\n" "" "--> Checking for event-based input devices in '$PH_APP' command-line options"
			ph_set_result -r 0
			if echo "$PH_APPU_CMD_OPTS" | grep -E "PH_CTRL[1-4]$|PH_CTRL[1-4] " >/dev/null
			then
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
				for ((PH_i=1;PH_i<="$PH_APPU_NUM_CTRL";PH_i++))
				do
					printf "%8s%s\n" "" "--> Retrieving event id for '$PH_CTRL_TYPE' controller with CLI id '$PH_i'"
					if [[ "$PH_CTRL_MAP" == "no" ]]
					then
						eval declare -i PH_EVENT"$PH_i"="$(ph_get_controller_cli_id "$PH_i")"
					else
						eval declare -i PH_EVENT"$PH_i"="$(ph_get_controller_cli_id "$((PH_i+"$((PH_CTRL_COUNT-"$PH_APPU_NUM_CTRL"))"))")"
					fi
					declare -n PH_EVENT=PH_EVENT"$PH_i"
					printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_EVENT')"
					ph_set_result -r 0
					printf "%8s%s\n" "" "--> Checking for event-based input device '$PH_i' in '$PH_APP' command-line options"
					if echo "$PH_APPU_CMD_OPTS" | grep -E "PH_CTRL$PH_i$|PH_CTRL$PH_i " >/dev/null
					then
						printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
						printf "%8s%s\n" "" "--> Assigning event id '$PH_EVENT' to input device with CLI id '$PH_i' in command-line options"
						PH_APP_CMD_OPTS="$(eval echo -n "$(sed 's/PH_CTRL'"$PH_i"'/'"$PH_EVENT"'/g;s/"/\\\"/g' <<<"$PH_APPU_CMD_OPTS" 2>/dev/null)")"
						printf "%10s\033[32m%s\033[0m\n" "" "OK"
						ph_set_result -r 0
					else
						printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Not found"
						ph_set_result -r 1 -m "'$PH_APPU_NUM_CTRL' '$PH_CTRL_TYPE' controllers requested but only '$((PH_i-1))' event-based input devices found in '$PH_APP' command line options"
						[[ "$PH_APPU_CIFS_SHARE" == "yes" ]] && ph_umount_cifs_share "$PH_APP" >/dev/null
						unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
						unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
						unset -n PH_EVENT
						return 1
					fi
					unset -n PH_EVENT
				done
			else
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Not found)"
			fi
		fi
		printf "%8s%s\n" "" "--> Starting ${PH_APP}"
	else
		printf "%8s%s\n" "" "--> Starting the tty allocated to ${PH_APP} : 'tty${PH_APP_TTY}'"
### is this still needed and replace with correct check tty active if so, then continue from here
		if systemctl list-units -t service 2>/dev/null | nawk '$4 ~ /^running$/ { print $1 }' | grep -E ^"getty@tty$PH_APP_TTY.service"$ >/dev/null
		then
			[[ "$PH_APP" == "Bash" ]] && \
				PH_APP_CMD="bash"
			if ! pgrep -t "tty${PH_APP_TTY}" -f "${PH_APP_CMD}" >/dev/null 2>&1
			then
				"$PH_SUDO" systemctl stop "getty@tty${PH_APP_TTY}" >/dev/null 2>&1
				"$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
			fi
			[[ "$PH_APP" == "Bash" ]] && \
				PH_APP_CMD="/bin/bash"
		fi
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		if "$PH_SUDO" chvt "$PH_APP_TTY" 2>/dev/null
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
			ph_set_result -r 0
			return 0
		else
			printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start TTY"
			ph_set_result -r 1 -m "Could not start 'tty${PH_APP_TTY}' allocated to '${PH_APP}'"
			return 1
		fi
	fi
	if [[ "$PH_APP" != "PieHelper" ]]
	then
		ph_umount_cifs_share PieHelper >/dev/null 2>&1
		"$PH_SUDO" systemctl stop "getty@tty$PH_PIEH_TTY" >/dev/null 2>&1
		"$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
	else
		PH_APP_CMD="ph_show_menu"
	fi
	if [[ "$PH_APP_CMD" != "/bin/bash" ]]
	then
		if [[ "$PH_APP" == "Moonlight" && "$PH_APP_USER" != "$(whoami 2>/dev/null)" ]]
		then
			"$PH_SUDO" -E su "$PH_APP_USER" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib eval ${PH_APP_CMD} ${PH_APP_CMD_OPTS}"
		else
			eval "$PH_APP_CMD" "$PH_APP_CMD_OPTS"
		fi
	else
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		true
	fi
	if [[ "$?" -ne "0" ]]
	then
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start application"
		ph_set_result -r 1 -m "An error occurred starting '$PH_APP' on 'TTY$PH_APP_TTY'"
		if [[ "$PH_APPU_CIFS_SHARE" == "yes" ]]
		then
			ph_umount_cifs_share "$PH_APP" >/dev/null
		fi
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		return 1
	else
		ph_add_value_to_param -p PH_STOP_APPS -v "$PH_APP'force"
	fi
	if [[ "$PH_APP" == "PieHelper" ]]
	then
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		return 0
	fi
	ph_run_with_rollback -c "true"
	if [[ "$PH_APP" == "Bash" ]]
	then
		ph_show_result
		ph_set_result -t -r "$?"
		ph_show_result -t
		"$PH_SUDO" rm "${PH_TMP_DIR}/Start.report" 2>/dev/null
		clear
	fi ;;
		     stop)
	printf "%8s%s\n" "" "--> Stopping '$PH_APP'"
	if [[ "$PH_APPU_PERSISTENT" == "yes" && -z "$3" ]]
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Persistent application -> Skipping"
		ph_set_result -r 0 -m "'$PH_APP' was left online due to being marked persistent"
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		return 0
	fi
	if [[ "$PH_APP" == "Moonlight" ]]
	then
		while pgrep moonlight >/dev/null
		do
			"$PH_SUDO" -E su "$PH_APP_USER" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} quit" >/dev/null 2>&1
			sleep 3
		done
	fi
	if [[ "$PH_FG_CONSOLE" -eq "$PH_APP_TTY" ]]
	then
		if [[ ( "$PH_APP" != "PieHelper" ) && ( "$PH_PIEH_TTY" -gt "1" && "$PH_PIEH_TTY" -le "$PH_PIEH_MAX_TTYS" ) ]]
		then
			"$PH_SUDO" chvt "$PH_PIEH_TTY" 2>/dev/null
		else
			"$PH_SUDO" chvt 1 2>/dev/null
		fi
	fi
	if ! "$PH_SUDO" systemctl stop "getty@tty${PH_APP_TTY}" >/dev/null 2>&1
	then
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not stop TTY"
		ph_set_result -r 1 -m "An error occurred stopping 'TTY$PH_APP_TTY' allocated to '$PH_APP'"
		unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
		unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
		return 1
	else
		ph_add_value_to_param -p PH_START_APPS -v "$PH_APP"
		ph_run_with_rollback -c "true"
	fi
	printf "%8s%s\n" "" "--> Checking for '$PH_APP' POST-command requirement"
	ph_set_result -r 0
	if [[ -n "$PH_APPU_POST_CMD" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes) -> Running POST-command actions"
		printf "%8s%s\n" "" "--> Checking for '$PH_APP' POST-command '$(eval echo -n "$PH_APPU_POST_CMD" | nawk '{ print $1 ; exit 0 }')' presence"
		ph_set_result -r 0
		if [[ -f "$(eval echo -n "$PH_APPU_POST_CMD" | nawk '{ print $1 ; exit 0 }')" || -L "$(eval echo -n "$PH_APPU_POST_CMD" | nawk '{ print $1 ; exit 0 }')" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
			file -b "$(eval echo -n "$PH_APPU_POST_CMD" | nawk '{ print $1 ; exit 0 }')" 2>/dev/null | nawk 'BEGIN { rc = 0 } $0 ~ /ASCII text executable/ { exit 1 }
								$0 ~ /ASCII text/ { exit 2 }
								$0 ~ /32-bit.*executable/ { exit 3 }
								$0 ~ /32-bit.*shared object/ { exit 3 }
								$0 ~ /64-bit.*executable/ { exit 4 }
								$0 ~ /64-bit.*shared object/ { exit 4 }
								$0 ~ /directory/ { exit 5 }
								{ exit 6 }'
			case "$?" in 1|3|4)
				$(eval echo -n "$PH_APPU_POST_CMD") 2>/dev/null ;;
			             2)
				. $(eval echo -n "$PH_APPU_POST_CMD") 2>/dev/null ;;
				     5|6)
				false ;;
			esac
			if [[ "$?" -ne "0" ]]
			then
				printf "%8s%s\n" "" "--> Checking for '$PH_APP' POST-command '$(eval echo -n "$PH_APPU_POST_CMD")' validity"
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid command -> Skipping"
				ph_set_result -r 0
			fi
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found -> Skipping"
		fi
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
	fi
	printf "%8s%s\n" "" "--> Checking for '$PH_APP' CIFS mount requirement"
	ph_set_result -r 0
	if [[ "$PH_APPU_CIFS_SHARE" == "no" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n" "" "--> Checking for '$PH_APP' CIFS mount presence"
		ph_set_result -r 0
		if mount 2>/dev/null | nawk -v rempath="^//${PH_APPU_CIFS_SRV}$(eval "echo -n \"${PH_APPU_CIFS_DIR}${PH_APPU_CIFS_SUBDIR}\"")"$ -F' on ' '$1 ~ rempath { exit 1 }'
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Found) -> Unmounting"
			ph_umount_cifs_share "$PH_APP" || PH_RET_CODE="1"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found -> Skipping"
		fi
	fi
	printf "%8s%s\n" "" "--> Checking for '$PH_APP' controller usage requirement"
	ph_set_result -r 0
	if [[ "$PH_APPU_USE_CTRL" == "yes" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Found) -> Cleaning up"
		ph_cleanup_controllers full || PH_RET_CODE="1"
		printf "%8s%s\n\n" "" "--> Displaying reminder for controller usage"
		printf "%12s\033[33m%s\033[0m\n\n" "" "- Please manually turn off your controller(s)"
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		ph_set_result -r 0
		sleep 5
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Not found)"
	fi ;;
esac
unset -n PH_APPU_CMD_OPTS PH_APPU_USE_CTRL PH_APPU_NUM_CTRL PH_APPU_PRE_CMD PH_APPU_POST_CMD
unset -n PH_APPU_CIFS_SHARE PH_APPU_CIFS_DIR PH_APPU_CIFS_SUBDIR PH_APPU_CIFS_SRV PH_APPU_PERSISTENT
return "$PH_RET_CODE"
}
