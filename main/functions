# PieHelper function declarations (By Davy Keppens on 06/10/18)
# Toggle debugstate of a specific function between Enable/Disable by running confpieh_ph.sh -p debug -m 'function_name'

function ph_check_conf_files {

typeset PH_i=""

for PH_i in $@
do
	case $PH_i in supp)
		PH_i="$PH_CONF_DIR/supported_apps" ;;
		      cont)
		PH_i="$PH_CONF_DIR/controller_cli_ids" ;;
	esac
	[[ -f $PH_i ]] || return 1
done
return 0
}

function ph_configure_moon {

typeset PH_ANSWER=""
typeset PH_APP="Moonlight"
typeset -i PH_COUNT=0
typeset -i PH_OPT=0
set -A PH_OPTAR PH_MOON_RES PH_MOON_FPS PH_MOON_BITRATE PH_MOON_PCKTSIZE PH_MOON_USE_CTRL PH_MOON_NUM_CTRL PH_MOON_CMD_OPTS PH_MOON_GAME PH_MOON_SRV

for PH_OPT in {0..$((${#PH_OPTAR[@]}-1))}
do
	printf "\n"
        PH_COUNT=0
        confopts_ph.sh -p get -a Moonlight -o "${PH_OPTAR[$PH_OPT]}" | tail -n +3
	printf "\n"
        confopts_ph.sh -p help -a Moonlight -o "${PH_OPTAR[$PH_OPT]}" | tail -n +3
        printf "%s\n" "- Prompting for requested change"
        while [[ $PH_ANSWER != @(y|n) ]]
        do
                [[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
                printf "%8s%s" "" "--> Do you want the change the value for ${PH_OPTAR[$PH_OPT]} (y/n) ? "
                [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" ]] && (printf "\n\n%12s%s\n" "" "- A value for PH_MOON_SRV is required for further configuration" ; \
                                printf "%12s%s" "" "- An empty value for PH_MOON_SRV will end configuration but it can later be restarted using either 'confapps_ph.sh' or the PieHelper menu : ")
                read PH_ANSWER 2>/dev/null
                if ! ph_screen_input $PH_ANSWER
                then
                        unset PH_OPTAR
                        return 1
                fi
                ((PH_COUNT++))
        done
        [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" ]] && printf "\n%10s%s\n" "" "OK" || printf "%10s%s\n" "" "OK"
        if [[ "$PH_ANSWER" == "y" ]]
        then
                false
                while [[ $? -ne 0 ]]
                do
                        [[ "$PH_ANSWER" != "y" ]] && printf "%s\n" "- Prompting for requested change"
                        PH_ANSWER=""
                        while [[ "$PH_ANSWER" == "" ]]
                        do
                                printf "%8s%s" "" "--> Please enter the new value for ${PH_OPTAR[$PH_OPT]} : "
                                read PH_ANSWER 2>/dev/null
                                [[ "$PH_i" == "PH_MOON_GAME" ]] && break
                        done
                        printf "%10s%s\n" "" "OK"
                        ph_set_option Moonlight -r "${PH_OPTAR[$PH_OPT]}"="$PH_ANSWER" && printf "%2s%s\n" "" "SUCCESS" || printf "%2s%s\n" "" "FAILED"
                done
        else
                printf "%2s%s\n" "" "SUCCESS"
                if [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && -z "$PH_MOON_SRV" ]]
                then
                        unset PH_OPTAR
			printf "\n"
                        return 0
                fi
        fi
        PH_ANSWER=""
done
printf "%8s%s" "" "--> Removing Moonlight cache directory for $PH_RUN_USER"
$PH_SUDO rm -r "$HOME/.cache/moonlight" 2>/dev/null
printf "%10s%s\n" "" "OK"
$PH_SUDO chmod 4755 `which moonlight` >/dev/null 2>&1
printf "%s\n" "- Pairing with $PH_MOON_SRV"
moonlight pair "$PH_MOON_SRV"
unset PH_OPTAR
printf "\n"
return 0
}

function ph_open_tools_location {

clear
printf "%s\n\n" "List of available tools : "
cd $PH_SCRIPTS_DIR >/dev/null 2>&1
ls
printf "\n%s\n\n" "Run any tool with the '-h' parameter to see help"
printf "\n%s\n\n" "Run any tool with supported parameters or without parameters to execute their main function"
printf "%s\n" "You can always return to the PieHelper menu by typing 'startpieh.sh' or use 'startpieh.sh -p' to restart on a pseudo-terminal"
return 0
}

function ph_check_mac_validity {

typeset PH_MAC_ADDR="$1"

if [[ "$PH_MAC_ADDR" != @({5}(@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9])){1}(:))@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9]))|none) ]]
then
	return 1
fi
return 0
}

function ph_check_ip_validity {

typeset PH_IPV4_ADDR="$1"

if [[ "$PH_IPV4_ADDR" != @({3}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9]))\.){1}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9])))|) ]]
then
	return 1
fi
return 0
}

function ph_getstate_pieh {

typeset PH_STATE=""

[[ -f $PH_FILES_DIR/first_run ]] && PH_STATE="unconfigured" || \
                PH_STATE="configured"
printf "%s\n" "- Displaying PieHelper current version and configuration state"
printf "%2s%s\n" "" "PieHelper $PH_VERSION is currently : \"$PH_STATE\""
printf "%2s%s\n\n" "" "SUCCESS"
return 0
}

function ph_print_bannerline {

typeset -i PH_COUNT=0
typeset -i PH_COLUMNS=`tput cols`

while [[ $PH_COUNT -lt $PH_COLUMNS ]]
do
	printf "%s" "*"
	((PH_COUNT ++))
done
printf "\n"
return 0
}

function ph_configure_emul {

typeset -i PH_ALSA_CARD=0
typeset -i PH_ALSA_DEVICE=0

printf "%s\n" "- Configuring Emulationstation"
printf "%8s%s\n" "" "--> Configuring ALSA audio"
PH_ALSA_CARD=`aplay -l | nawk 'BEGIN { ORS = "" } $0 ~ /HDMI/ { for (i=1;i<=NF;i++) { if ($i~/^card$/) { sub(/:/,"",$(i+1)) ; print $(i+1) }}}'`
PH_ALSA_DEVICE=`aplay -l | nawk 'BEGIN { ORS = "" } $0 ~ /HDMI/ { for (i=1;i<=NF;i++) { if ($i~/^device$/) { sub(/:/,"",$(i+1)) ; print $(i+1) }}}'`
nawk -v card=$PH_ALSA_CARD -v dev=$PH_ALSA_DEVICE '$1 ~ /^audio_enable$/ { print "audio_enable = true" ; next }
	$1 ~ /^audio_out_rate$/ { print "audio_out_rate = 44100" ; next }
	$1 ~ /^audio_driver$/ { print "audio_driver = alsa" ; next }
	$1 ~ /^audio_sync$/ { print "audio_sync = true" ; next }
	$1 ~ /^audio_device$/ { print "audio_device = hw:" card "," dev ; next }
	{ print }' /opt/retropie/configs/all/retroarch.cfg >/tmp/retroarch.cfg_tmp
[[ $? -eq 0 ]] && $PH_SUDO mv /tmp/retroarch.cfg_tmp /opt/retropie/configs/all/retroarch.cfg
printf "%10s%s\n" "" "OK"
printf "%2s%s\n\n" "" "SUCCESS"
return 0
}

function ph_configure_x11 {

printf "%s\n" "- Configuring X11"
printf "%2s%s\n\n" "" "SUCCESS : Nothing to configure"
return 0
}

function ph_configure_bash {

printf "%s\n" "- Configuring Bash"
printf "%2s%s\n\n" "" "SUCCESS : Nothing to configure"
return 0
}

function ph_configure_kodi {

printf "%s\n" "- Configuring Kodi"
printf "%2s%s\n\n" "" "SUCCESS : Nothing to configure"
return 0
}

function ph_setup_controllers {

typeset PH_MAP="$PH_CTRL_MAP"
typeset PH_i=""
typeset PH_j=""
typeset PH_ADD=""
typeset PH_PARENT_DEV_PATH=""
typeset -i PH_FLAG=0
typeset -i PH_NUM_CTRL=$1
typeset -i PH_CTRL_CLI_ID=0
typeset -i PH_EVDEVS=0

ph_check_conf_files cont || (printf "%8s%s\n" "" "--> Checking for controller CLI ids' configuration file" ; \
			printf "%10s%s\n" "" "ERROR : Not found" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
ph_cleanup_controllers reset
[[ "$PH_CTRL_TYPE" == "XBOX360" ]] && PH_MAP="no"
PH_EVDEVS=`ls -l /dev/input/event+([[:digit:]]) | wc -l`
[[ $PH_EVDEVS -eq 0 ]] && printf "%8s%s\n" "" "--> Running type verification of input devices" && printf "%10s%s\n" "" "ERROR : (None found)" && return 1 
for PH_i in `ls -l /dev/input/event+([[:digit:]]) | sort -n | nawk 'BEGIN { ORS = " " } { print $NF }'`
do
	printf "%8s%s\n" "" "--> Running type verification of input device ${PH_i##*event}"
	PH_PARENT_DEV_PATH=`udevadm info $PH_i | nawk -F'=' '$0 ~ /.: DEVPATH=/ { print $2 }'`
	PH_PARENT_DEV_PATH="${PH_PARENT_DEV_PATH%/*}"
	[[ "$PH_CTRL_TYPE" == "PS4" ]] && PH_ADD="PS4A"
	for PH_j in $PH_CTRL_TYPE $PH_ADD
	do
		[[ "$PH_j" != @(PS4A) ]] && PH_FLAG=0
## add xboxurecv connection type for wireless XBOX360 USB Receiver
		PH_CTRL_CONN=`udevadm info -q all --path $PH_PARENT_DEV_PATH | nawk -F'=' -v type="$PH_j" 'BEGIN { flag = 0 ; conn="" ; if (type~/^PS4$/) { string = "\"(Sony Interactive Entertainment )*Wireless Controller\"$" }
				else { if (type~/^PS4A$/) { string="\"Sony Interactive Entertainment DUALSHOCK.*4 USB Wireless Adaptor\"$" }
				else { if (type~/^PS3$/) { string="\".*PLAYSTATION\(R\)3 Controller\"$" }
				else { if (type~/^XBOX360$/) { string="\"Microsoft X-Box 360 pad\"$" }}}}}
				$2 ~ string { flag = 1 ; next }
				$1 ~ "^.: ID_BUS$" { if (type~/^PS4A/) { conn = "sonywadapt" } else { conn = $2 } ; next }
				{ next }
				END { if (flag==1) { print conn }}'`
		PH_CTRL_CLI_ID=${PH_i##*event}
		if [[ -n "$PH_CTRL_CONN" ]]
		then
			typeset -n PH_CONN="PH_CTRL_CONN"$PH_CTRL_CLI_ID
			typeset -n PH_CLI_ID="PH_CTRL_CLI_ID"$PH_CTRL_CLI_ID
			[[ "$PH_j" == "PS4" ]] && PH_FLAG=1
			PH_CONN="$PH_CTRL_CONN"
			PH_CLI_ID="$PH_CTRL_CLI_ID"
			printf "%10s%s\n" "" "OK ($PH_CTRL_TYPE:$PH_CONN:id $PH_CLI_ID)"
			echo $PH_CLI_ID >>$PH_CONF_DIR/controller_cli_ids
			unset -n PH_CLI_ID PH_CONN
		else
			[[ "$PH_j" != "PS4" && PH_FLAG -eq 0 ]] && printf "%10s%s\n" "" "OK (Not a $PH_CTRL_TYPE controller)"
		fi
	done
done
printf "%8s%s\n" "" "--> Verifying $PH_CTRL_TYPE controller count"
if [[ `cat $PH_CONF_DIR/controller_cli_ids | wc -l` -eq $PH_NUM_CTRL ]]
then
        printf "%10s%s\n" "" "OK"
else
        [[ `cat $PH_CONF_DIR/controller_cli_ids | wc -l` -lt $PH_NUM_CTRL ]] && \
                printf "%10s%s\n" "" "ERROR : Insufficient number of $PH_CTRL_TYPE controllers connected (`cat $PH_CONF_DIR/controller_cli_ids | wc -l`<->$PH_NUM_CTRL requested)" && return 1
        typeset -n PH_CONN="PH_CTRL_CONN`sed -n '1p' $PH_CONF_DIR/controller_cli_ids`"
        typeset -n PH_CLI_ID="PH_CTRL_CLI_ID`sed -n '1p' $PH_CONF_DIR/controller_cli_ids`"
        printf "%10s%s" "" "Warning : Greater number of $PH_CTRL_TYPE controllers connected than requested (`cat $PH_CONF_DIR/controller_cli_ids | wc -l`<->$PH_NUM_CTRL requested) -> Using '$PH_CONN:CLI id $PH_CLI_ID'"
        if [[ $PH_NUM_CTRL -ne 1 ]]
        then
                for PH_i in {2..$PH_NUM_CTRL}
                do
                        [[ $PH_i -le $PH_NUM_CTRL ]] && printf "%s" ' &&'
                        printf "%s" " '`eval echo "\\$PH_CTRL_CONN\$PH_i"`:CLI id `eval echo "\\$PH_CTRL_CLI_ID\$PH_i"`'"
                done
        fi
        echo ''
	unset -n PH_CONN PH_CLI_ID
fi
[[ $PH_NUM_CTRL -ge 2 ]] && (printf "%8s%s\n" "" "--> Growing udev event queue for multiple controller usage" ; \
		$PH_SUDO udevadm control --children-max 500 ; printf "%10s%s\n" "" "OK")
if [[ "$PH_MAP" == "yes" ]]
then
	ph_cleanup_controllers unmap || return $?
	printf "%8s%s\n" "" "--> Configuring xboxdrv mapping to virtual XBOX360 controller(s)"
	for PH_CTRL_CLI_ID in {1..$PH_NUM_CTRL}
	do
		typeset -n PH_CLI_ID="PH_CTRL_CLI_ID`sed -n ''$PH_CTRL_CLI_ID'p' $PH_CONF_DIR/controller_cli_ids`"
		typeset -n PH_CONN="PH_CTRL_CONN`sed -n ''$PH_CTRL_CLI_ID'p' $PH_CONF_DIR/controller_cli_ids`"
		case $PH_CTRL_TYPE"_"$PH_CONN in PS4_bluetooth)
			($PH_SUDO nice --adjustment="-9" `which xboxdrv` \
				--evdev /dev/`udevadm info -q symlink /dev/input/event$PH_CLI_ID | nawk 'BEGIN { ORS = "" } $1 ~/^input\/by-path/ { print $1 ; exit } { print $2 ; exit }'` \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			! ls /proc/`cat "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" >/dev/null 2>&1` >/dev/null 2>&1 && printf "%10s%s\n" "" "ERROR : Could not start xboxdrv instance" && >$PH_CONF_DIR/controller_cli_ids && return 1
			echo $((PH_EVDEVS+`echo $((PH_CTRL_CLI_ID-1))`)) >>$PH_CONF_DIR/controller_cli_ids ;;
## correct button mappings for the three cases below
				       PS4_@(usb|sonywadapt))
			($PH_SUDO nice --adjustment="-9" `which xboxdrv` \
				--evdev /dev/`udevadm info -q symlink /dev/input/event$PH_CLI_ID | nawk 'BEGIN { ORS = "" } $1 ~/^input\/by-path/ { print $1 ; exit } { print $2 ; exit }'` \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			! ls /proc/`cat "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" >/dev/null 2>&1` >/dev/null 2>&1 && printf "%10s%s\n" "" "ERROR : Could not start xboxdrv instance" && >$PH_CONF_DIR/controller_cli_ids && return 1
			echo $((PH_EVDEVS+`echo $((PH_CTRL_CLI_ID-1))`)) >>$PH_CONF_DIR/controller_cli_ids ;; 
		   			   	 PS3_bluetooth)
			($PH_SUDO nice --adjustment="-9" `which xboxdrv` \
				--evdev /dev/`udevadm info -q symlink /dev/input/event$PH_CLI_ID | nawk 'BEGIN { ORS = "" } $1 ~/^input\/by-path/ { print $1 ; exit } { print $2 ; exit }'` \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			! ls /proc/`cat "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" >/dev/null 2>&1` >/dev/null 2>&1 && printf "%10s%s\n" "" "ERROR : Could not start xboxdrv instance" && >$PH_CONF_DIR/controller_cli_ids && return 1
			echo $((PH_EVDEVS+`echo $((PH_CTRL_CLI_ID-1))`)) >>$PH_CONF_DIR/controller_cli_ids ;;
			   			       PS3_usb)
			($PH_SUDO nice --adjustment="-9" `which xboxdrv` \
				--evdev /dev/`udevadm info -q symlink /dev/input/event$PH_CLI_ID | nawk 'BEGIN { ORS = "" } $1 ~/^input\/by-path/ { print $1 ; exit } { print $2 ; exit }'` \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			! ls /proc/`cat "/tmp/xboxdrv"$PH_CTRL_CLI_ID".pid" >/dev/null 2>&1` >/dev/null 2>&1 && printf "%10s%s\n" "" "ERROR : Could not start xboxdrv instance" && >$PH_CONF_DIR/controller_cli_ids && return 1
			echo $((PH_EVDEVS+`echo $((PH_CTRL_CLI_ID-1))`)) >>$PH_CONF_DIR/controller_cli_ids ;;
		esac
		unset -n PH_CLI_ID PH_CONN
	done
	printf "%10s%s\n" "" "OK"
fi
for PH_i in `cat $PH_CONF_DIR/controller_cli_ids | paste -d" " -s`
do
	[[ $PH_i -lt $PH_EVDEVS ]] && unset -n PH_CTRL_CONN"$PH_i" PH_CTRL_CLI_ID"$PH_i"
done
return 0
}

function ph_get_controller_cli_id {

typeset PH_CTRL_CLI_ID=""

PH_CTRL_CLI_ID=`sed -n ''$1'p' $PH_CONF_DIR/controller_cli_ids`
[[ "$PH_CTRL_CLI_ID" == "" ]] && return 1
echo "$PH_CTRL_CLI_ID"
return 0
}

function ph_cleanup_controllers {

typeset -i PH_RET_CODE=0 

[[ "$1" != @(reset|unmap|full) ]] && (printf "%8s%s\n" "" "--> Running controller(s) cleanup" ; \
		printf "%10s%s\n" "" "ERROR : Unknown option passed" ; return 0) && PH_RET_CODE=1
if [[ "$1" == @(reset|full) ]]
then
	if [[ `cat $PH_CONF_DIR/controller_cli_ids | wc -l` -gt 0 ]]
	then
		printf "%8s%s\n" "" "--> Resetting controller CLI ids"
		>$PH_CONF_DIR/controller_cli_ids
		printf "%10s%s\n" "" "OK"
	fi
fi
if [[ "$1" == @(unmap|full) ]]
then
	if pgrep xboxdrv >/dev/null 2>&1
	then
		printf "%8s%s\n" "" "--> Stopping xboxdrv"
		$PH_SUDO pkill -9 xboxdrv >/dev/null 2>&1
		if [[ $? -eq 0 ]]
		then
			$PH_SUDO rm /tmp/xboxdrv*.pid >/dev/null 2>&1
			printf "%10s%s\n" "" "OK"
			sleep 1
		else
			printf "%10s%s\n" "" "ERROR : Could not disable xboxdrv -> A reboot is required"
			PH_RET_CODE=1
		fi
	fi
fi
return $PH_RET_CODE
}

function ph_check_app_name {

typeset PH_OPTION=""
typeset PH_APP=""
typeset PH_j=""
typeset PH_TYPE=""
typeset PH_STATE=""
typeset PH_OLDOPTARG="$OPTARG"
typeset -i PH_OLDOPTIND=$OPTIND
typeset -l PH_APPL=""

ph_check_conf_files supp || (printf "%s\n" "- Checking for supported applications configuration file" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
while getopts isna: PH_OPTION
do
	case $PH_OPTION in i)
		PH_TYPE="integrated"
		PH_FILE="int" ;;
			   s)
		PH_TYPE="supported"
		PH_FILE="supp" ;;
			   n)
		PH_TYPE="new"
		PH_FILE="new" ;;
			   a)
		PH_APP="$OPTARG"
		PH_APPL=`echo $PH_APP | cut -c1-4` ;;
	esac
done
OPTIND=$PH_OLDOPTIND
OPTARG="$PH_OLDOPTARG"
if [[ "$PH_FILE" == "new" ]]
then
	printf "%s\n" "- Checking validity of $PH_TYPE application's shortname"
	for PH_j in `nawk 'BEGIN { ORS = " " } { print $1 }' $PH_CONF_DIR/supported_apps`
	do
		[[ `echo $PH_j | cut -c1-4 | tr "[:upper:]" "[:lower:]"` == "$PH_APPL" ]] && \
			printf "%2s%s\n\n" "" "FAILED : Application shortname \"$PH_APPL\" already in use" && \
			return 1
	done
	printf "%2s%s\n" "" "SUCCESS"
	return 0
fi
printf "%s\n" "- Determining state of $PH_APP"
if $PH_SCRIPTS_DIR/confapps_ph.sh -p list -l supp | tail -n +2 | nawk '{ print $1 }' | grep ^"$PH_APP"$ >/dev/null
then
	PH_STATE="supported"
fi
if $PH_SCRIPTS_DIR/confapps_ph.sh -p list -l int | tail -n +2 | nawk '{ print $1 }' | grep ^"$PH_APP"$ >/dev/null
then
	PH_STATE="integrated"
fi
if [[ -z "$PH_STATE" ]]
then
	printf "%2s%s\n" "" "FAILED : Application is neither integrated nor supported"
	printf "%11s%s\n" "" "Both the PieHelper menu and the 'confsupp_ph.sh' tool can be used for adding out-of-scope applications"
	return 1
fi
if $PH_SCRIPTS_DIR/confapps_ph.sh -p list -l "$PH_FILE" | tail -n +2 | nawk '{ print $1 }' | grep ^"$PH_APP"$ >/dev/null
then
	printf "%2s%s\n" "" "SUCCESS : $PH_STATE"
else
	printf "%2s%s\n\n" "" "FAILED : $PH_STATE (Needed integrated) :"
	printf "%11s%s\n" "" "- Application is either not yet installed or undiscovered"
	printf "%11s%s\n" "" "- Both the PieHelper menu and the 'confapps_ph.sh' tool can be used for both operations"
	return 1
fi
return 0
}

function ph_change_app_tty {

typeset PH_APP="$2"
typeset PH_APP_CMD=""
typeset -i PH_APP_TTY=0
typeset -i PH_APP_NEWTTY=$1

PH_APP_TTY=`ph_get_tty_for_app $PH_APP`
ph_undo_setup_tty $PH_APP_TTY "$PH_APP"
ph_setup_tty $PH_APP_NEWTTY "$PH_APP"
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	ph_set_tty_for_boot 0
	ph_set_tty_for_boot $PH_APP_NEWTTY
fi
printf "%2s%s\n" "" "SUCCESS"
return 0
}

function ph_set_tty_for_boot {

typeset -i PH_TTY=$1

if [[ ! -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
	[[ $PH_TTY -eq 0 ]] && return 0
	printf "%8s%s\n" "" "--> Setting TTY$PH_TTY as default boot TTY"
	$PH_SUDO mkdir -p /etc/systemd/system/getty@tty1.service.d 2>/dev/null
	cat >/tmp/autostart.conf <<EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noclear tty1 \$TERM
ExecStartPost=+/bin/chvt $PH_TTY
TTYVTDisallocate=no
TTYReset=no
TTYVHangup=no
EOF
        $PH_SUDO mv /tmp/autostart.conf /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
        $PH_SUDO chmod 644 /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
        $PH_SUDO chown root:root /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
	printf "%10s%s\n" "" "OK"
	printf "%8s%s\n" "" "--> Enabling TTY$PH_TTY"
	$PH_SUDO systemctl enable getty@tty$PH_TTY >/dev/null 2>&1
else
	PH_TTY=`nawk '$1 ~ /^ExecStartPost=/ { print $2 }' /etc/systemd/system/getty@tty1.service.d/autostart.conf`
	printf "%8s%s\n" "" "--> Removing TTY$PH_TTY as default boot TTY"
	$PH_SUDO rm -r /etc/systemd/system/getty@tty1.service.d 2>/dev/null
	printf "%10s%s\n" "" "OK"
	printf "%8s%s\n" "" "--> Disabling TTY$PH_TTY"
	$PH_SUDO systemctl disable getty@tty$PH_TTY >/dev/null 2>&1
fi
$PH_SUDO systemctl daemon-reload >/dev/null 2>&1
printf "%10s%s\n" "" "OK"
return 0
}

function ph_get_app_from_option {

typeset PH_OPTION="$1"
typeset PH_APP="$1"

cd $PH_CONF_DIR >/dev/null
PH_APP=`grep -l ^"$PH_OPTION=" * 2>/dev/null`
cd - >/dev/null
echo ${PH_APP%%.conf}
return 0
}

function ph_restore_options {

typeset PH_APP=""
typeset PH_i=""

for PH_i in $PH_REVERSE
do
	typeset -n PH_VALUE=OLD_"$PH_i"
        PH_APP=`ph_get_app_from_option "$PH_i"`
        ph_set_option "$PH_APP" -r $PH_i="$PH_VALUE"
	unset OLD_"$PH_i"
	unset -n PH_VALUE
done
return 0
}

function ph_set_option_to_default {

typeset PH_OPTION="$1"
typeset PH_APP=`ph_get_app_from_option "$PH_OPTION"`
typeset -n PH_VALUE="$1"
export OLD_"$PH_OPTION"="$PH_VALUE"
typeset PH_DEF_VALUE=`nawk -F'=' -v opt=^"$PH_OPTION"$ '$1 ~ opt { gsub("\047", "", $2) ; print $2 }' $PH_FILES_DIR/options.defaults`

if ph_set_option "$PH_APP" -r "$PH_OPTION"="$PH_DEF_VALUE"
then
        PH_REVERSE="$PH_REVERSE $PH_OPTION"
else
        return 1
fi
unset -n PH_VALUE
return 0
}

function ph_set_all_options_to_default {

typeset PH_i

for PH_i in `nawk -F'=' 'BEGIN { ORS = " " } { print $1 }' $PH_FILES_DIR/options.defaults`
do
        ph_set_option_to_default "$PH_i" || (ph_restore_options ; return 1) || return $?
done
return 0
}

function ph_show_menu {

typeset PH_MENU="$1"

[[ "$1" == @(Advanced|Main|Apps|Controllers) ]] && typeset PH_TYPE="menu" || typeset PH_TYPE="submenu"
[[ "$PH_MENU" == "Settings" ]] && typeset PH_HEADER="Welcome to PieHelper $PH_VERSION Controller $PH_MENU $PH_TYPE" || \
	typeset PH_HEADER="Welcome to PieHelper $PH_VERSION $PH_MENU $PH_TYPE"
typeset PH_j=""
typeset -i PH_ANSWER=0
typeset -i PH_i=0
typeset -i PH_COUNT=0
typeset -i PH_COLUMNS=`tput cols`

while true
do
	PH_ANSWER=0
	PH_COUNT=0
	if [[ "$PH_MENU" == "Apps" ]]
	then
		>$PH_FILES_DIR/menus/Apps.lst
		for PH_j in `nawk '{ print $1 }' $PH_CONF_DIR/supported_apps`
		do
			echo "Go to $PH_j submenu:ph_show_menu $PH_j" >>$PH_FILES_DIR/menus/Apps.lst
		done
		echo "Go to AppManagement submenu:ph_show_menu AppManagement" >>$PH_FILES_DIR/menus/Apps.lst
		echo "Go to Main menu:ph_show_menu Main" >>$PH_FILES_DIR/menus/Apps.lst
		echo "Go to Advanced menu:ph_show_menu Advanced" >>$PH_FILES_DIR/menus/Apps.lst
		echo "Go to Controllers menu:ph_show_menu Controllers" >>$PH_FILES_DIR/menus/Apps.lst
		echo "Return to previous screen:return" >>$PH_FILES_DIR/menus/Apps.lst
	fi
	set -A PH_MENU_ITEM ""
	for PH_i in {1..`cat "$PH_FILES_DIR/menus/$PH_MENU.lst" | wc -l`}
	do
		PH_MENU_ITEM+=("`nawk -F':' -v line=$PH_i 'NR == line { print $1 }' $PH_FILES_DIR/menus/$PH_MENU.lst`")
	done
	set -A PH_MENU_CMD ""
	for PH_i in {1..`cat "$PH_FILES_DIR/menus/$PH_MENU.lst" | wc -l`}
	do
		PH_MENU_CMD+=("`nawk -F':' -v line=$PH_i 'NR == line { print $2 }' $PH_FILES_DIR/menus/$PH_MENU.lst`")
	done
	clear
	ph_print_bannerline
	printf "\n"
	printf "%`echo $((PH_COLUMNS/2-${#PH_HEADER}/2))`s%s\n" "" "$PH_HEADER"
	printf "\n"
	ph_print_bannerline
	printf "\n"
	for PH_i in {1..`echo $((${#PH_MENU_ITEM[@]}-1))`}
	do
		printf "%-4s%-30s\n" "$PH_i. " "${PH_MENU_ITEM[$PH_i]}"
	done
	printf "\n"
	while [[ $PH_ANSWER -eq 0 || $PH_ANSWER -gt $((${#PH_MENU_ITEM[@]}-1)) ]]
	do
		[[ $PH_COUNT -gt 0 ]] && printf "\n%2s%s\n\n" "" "ERROR : Invalid response"
		printf "%s" "Your Choice : "
		read PH_ANSWER 2>/dev/null
		((PH_COUNT++))
	done
	if [[ $PH_ANSWER -ne $((${#PH_MENU_ITEM[@]}-1)) ]]
	then
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" == '$PH_SUDO init 6' ]]
		then
			printf "\n"
			ph_print_bannerline
			printf "\n"
			printf "%2s%s\n" "" "Rebooting your system"
			printf "\n"
			ph_print_bannerline
		fi
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" != ph_show_menu* && "${PH_MENU_CMD[$PH_ANSWER]}" != '$PH_SUDO init 6' ]]
		then
			printf "\n"
			printf "%s\n" "Output of running commands :"
			printf "\n"
			ph_print_bannerline
			printf "\n"
		fi
		eval ${PH_MENU_CMD[$PH_ANSWER]}
		PH_ANSWER=$?
		if [[ "${PH_MENU_CMD[$PH_ANSWER]}" != @(ph_show_menu*|return) ]]
		then
			printf "\n"
			ph_print_bannerline
			printf "\n"
		fi
	else
		eval ${PH_MENU_CMD[$PH_ANSWER]} $PH_ANSWER 2>/dev/null
		PH_ANSWER=0
	fi
	[[ $PH_ANSWER -eq 0 || $PH_ANSWER -eq 1 ]] && printf "%s" "Press Enter to continue" && read 2>/dev/null
done
ph_open_tools_location
printf "\n"
exit 0
}

function ph_escape_paths {

echo "$@"| sed 's/\//\\\//g;s/ /\\ /g'
return 0
}

function ph_undo_escape_paths {

echo "$@" | sed 's/\\//g'
return 0
}


function ph_unconfigure_pieh {

typeset PH_j=""
typeset PH_k=""
typeset PH_ANSWER=""
typeset PH_RUNAPP=""
typeset PH_APPSL=""
typeset PH_ACTION="unconfiguration"
typeset PH_OOSAPPS=""
typeset -l PH_RUNAPPL=""
typeset -i PH_RUNAPP_TTY=0
typeset -i PH_COUNT=0
PH_REVERSE=""

[[ "$1" == "remove" ]] && PH_ACTION="removal"
printf "%s" "-"
ph_getstate_pieh | tail -2 | head -1 | cut -c2-
printf "%2s%s\n\n" "" "Starting $PH_ACTION of PieHelper"
printf "%8s%s\n" "" "--> Displaying info"
printf "%10s%s\n" "" "OK"
printf "\n"
ph_print_bannerline
printf "\n"
printf "%12s%s\n" "" "This will - remove all custom configurations made so far"
printf "%22s%s\n" "" "- remove any out-of-scope applications from PieHelper"
printf "%22s%s\n" "" "- set some configurations back to default"
printf "%22s%s\n" "" "- reboot your system"
printf "\n"
ph_print_bannerline
printf "\n"
while [[ "$PH_ANSWER" != @(y|n) ]]
do
	[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
	printf "%8s%s" "" "--> Continue $PH_ACTION of PieHelper (y/n) ? "
	read PH_ANSWER 2>/dev/null
	ph_screen_input $PH_ANSWER || return $?
	((PH_COUNT++))
done
[[ "$PH_ANSWER" == "n" ]] && printf "%10s%s\n" "" "OK" && printf "%2s%s\n\n" "" "USER ABORTED" && return 1
printf "%10s%s\n" "" "OK" && printf "%2s%s\n" "" "SUCCESS"
ph_check_conf_files supp || (printf "%s\n" "- Checking for supported applications configuration file" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
printf "%s\n" "- Deallocating application TTYs"
for PH_RUNAPP in `nawk 'BEGIN { ORS = " " } $4 !~ /^-$/ { print $1 ":" $4 }' $PH_CONF_DIR/installed_apps`
do
	PH_RUNAPP_TTY=${PH_RUNAPP##*:}
	PH_RUNAPP="${PH_RUNAPP%%:*}"
	ph_undo_setup_tty $PH_RUNAPP_TTY "$PH_RUNAPP"
done
printf "%2s%s\n" "" "SUCCESS"
for PH_RUNAPP in `nawk 'BEGIN { ORS = " " } $4 !~ /^-$/ { print $1 }' $PH_CONF_DIR/installed_apps`
do
	if [[ "$PH_RUNAPP" == "PieHelper" ]]
	then
		printf "%s\n" "" "- Disabling PieHelper"
		printf "%2s%s\n" "" "OK (PieHelper) -> Skipping"
		continue
	fi
	PH_RUNAPPL=`echo $PH_RUNAPP | cut -c1-4`
	$PH_SCRIPTS_DIR/stop"$PH_RUNAPPL".sh || (ph_restart_apps "$PH_APPSL" >/dev/null 2>&1 ; return 1) || return $?
	[[ -n "$PH_APPSL" ]] && PH_APPSL="$PH_APPSL $PH_RUNAPPL" || PH_APPSL="$PH_RUNAPPL"
done
ph_set_tty_for_boot 0
printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Going back to system defaults"
ph_set_default_tty_states || (ph_restart_apps "$PH_APPSL" >/dev/null 2>&1 ; printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
ph_set_default_logind_conf || (ph_restart_apps "$PH_APPSL"  >/dev/null 2>&1 ; printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
printf "%2s%s\n" "" "SUCCESS"
for PH_j in `nawk 'BEGIN { ORS = " " } $1 !~ /^PieHelper$/ && $1 !~ /^Moonlight$/ && $1 !~ /^X11$/ && $1 !~ /^Emulationstation$/ && $1 !~ /^Bash$/ && $1 !~ /^Kodi$/ { print $1 }' $PH_CONF_DIR/supported_apps`
do
	$PH_SCRIPTS_DIR/confsupp_ph.sh -p rem -a "$PH_j"
	if [[ $? -ne 0 ]]
	then
		ph_set_pieh_logind_conf >/dev/null 2>&1
		for PH_k in "$PH_OOSAPPS"
		do
			$PH_SCRIPTS_DIR/confsupp_ph.sh -p inst -a "$PH_k" >/dev/null 2>&1
		done
		ph_restart_apps "$PH_APPSL" >/dev/null 2>&1
		return 1
	else
		[[ -n "$PH_OOSAPPS" ]] && PH_OOSAPPS="$PH_OOSAPPS $PH_j" || PH_OOSAPPS="$PH_j"
	fi
done
printf "%s\n" "- Setting PieHelper state to \"unconfigured\""
printf "%8s%s\n" "" "--> Creating first_run file"
touch $PH_FILES_DIR/first_run && printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Resetting supported applications configuration file"
cat >$PH_CONF_DIR/supported_apps <<EOF
PieHelper	$PH_SCRIPTS_DIR/startpieh.sh
Bash	/bin/bash
Moonlight	/usr/local/bin/moonlight stream
Kodi	/usr/bin/xinit /usr/bin/kodi-standalone -- :0 -nolisten tcp vtPH_TTY
X11	/usr/bin/startx -- :1 vtPH_TTY
Emulationstation	/usr/bin/emulationstation
EOF
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Resetting controller CLI ids configuration file"
> $PH_CONF_DIR/controller_cli_ids
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Removing integrated applications configuration file"
rm $PH_CONF_DIR/installed_apps 2>/dev/null && printf "%10s%s\n" "" "OK"
ph_set_all_options_to_default
printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Reenabling X"
$PH_SUDO systemctl set-default graphical.target >/dev/null 2>&1 && printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Cleaning up"
if [[ -f /etc/profile.d/PieHelper-path.sh ]]
then
	printf "%8s%s\n" "" "--> Removing PieHelper PATH extension"
	$PH_SUDO rm /etc/profile.d/PieHelper-path.sh
	printf "%10s%s\n" "" "OK"
fi
ph_restore_emul_conf
rm /tmp/Moonlight.compile 2>/dev/null
printf "%2s%s\n" "" "SUCCESS"
unset PH_REVERSE >/dev/null
if [[ "$1" == "" ]]
then
	printf "%s\n\n" "" "You can configure PieHelper again later by typing \"$PH_SCRIPTS_DIR/confpieh_ph.sh -c\" on the command line"
	printf "%s" "Press Enter to reboot and continue"
	read 2>/dev/null
	$PH_SUDO chvt 1
	$PH_SUDO init 6
fi
return 0
}

function ph_restart_apps {

typeset PH_k=""

for PH_k in $@
do
	$PH_SCRIPTS_DIR/start"$PH_k".sh || return $?
done
return 0
}

function ph_set_pieh_tty_states {

typeset -i PH_j=0

for PH_j in {2..$PH_PIEH_MAX_TTYS}
do
        printf "%8s%s\n" "" "--> Disabling TTY$PH_j"
        $PH_SUDO systemctl disable getty@tty$PH_j >/dev/null 2>&1 && printf "%10s%s\n" "" "OK" || \
                        (printf "%10s%s\n" "" "ERROR : Could not disable TTY$PH_j" ; \
                         return 1) || return $?
done
$PH_SUDO systemctl daemon-reload >/dev/null 2>&1
return 0
}

function ph_set_pieh_logind_conf {

typeset PH_i=""
typeset -i PH_k=0

for PH_i in NAutoVTs ReserveVT
do
        if grep ^"$PH_i" /etc/systemd/logind.conf >/dev/null
        then
                printf "%8s%s\n" "" "--> Changing logind.conf value for existing override of $PH_i"
                [[ "$PH_i" == "NAutoVTs" ]] && PH_k=12 || PH_k=1
                $PH_SUDO sed "s/^\($PH_i=\)\([[:digit:]]*\)/\1$PH_k/g" /etc/systemd/logind.conf >/tmp/logind.conf_tmp 2>/dev/null
                [[ $? -eq 0 ]] && ($PH_SUDO mv /tmp/logind.conf_tmp /etc/systemd/logind.conf ; \
                                        printf "%10s%s\n" "" "OK") || \
                        (printf "%10s%s\n" "" "ERROR : Could not change existing logind.conf override value of $PH_i" ; \
			 return 1) || return $?
        fi
        if grep ^"#$PH_i" /etc/systemd/logind.conf >/dev/null
        then
                printf "%8s%s\n" "" "--> Overriding logind.conf value for $PH_i"
                [[ "$PH_i" == "NAutoVTs" ]] && PH_k=12 || PH_k=1
                $PH_SUDO sed "s/^\(#\)\($PH_i=\)\([[:digit:]]*\)/\2$PH_k/g" /etc/systemd/logind.conf >/tmp/logind.conf_tmp 2>/dev/null
                [[ $? -eq 0 ]] && ($PH_SUDO mv /tmp/logind.conf_tmp /etc/systemd/logind.conf ; \
                                        printf "%10s%s\n" "" "OK") || \
                        (printf "%10s%s\n" "" "ERROR : Could not override logind.conf value for $PH_i" ; \
			 return 1) || return $?
        fi
done
return 0
}

function ph_set_default_logind_conf {

printf "%8s%s\n" "" "--> Setting logind.conf values back to default"
$PH_SUDO sed 's/^\(NAutoVTs=\)\([[:digit:]]*\)/#\16/g;s/^\(ReserveVT=\)\([[:digit:]]*\)/#\16/g' /etc/systemd/logind.conf >/tmp/logind.conf 2>/dev/null
[[ $? -eq 0 ]] && $PH_SUDO mv /tmp/logind.conf /etc/systemd/logind.conf || (printf "%10s%s\n" "" "ERROR: Could not set logind.conf values back to default" ; \
										return 1) || return $?
printf "%10s%s\n" "" "OK"
return 0
}

function ph_remove_pieh {

ph_unconfigure_pieh remove || return $?
cd $PH_MAIN_DIR/..
rm -r PieHelper
printf "%s\n\n" "" "Thank you for using PieHelper !"
printf "%s" "Press Enter to reboot and continue"
read 2>/dev/null
$PH_SUDO chvt 1
$PH_SUDO init 6
}

function ph_set_option {

typeset PH_OPTION=""
typeset PH_APP="$1"
typeset PH_i=""
typeset PH_j=""
typeset PH_SUFFIX=""
typeset PH_OPTARG_VAR=""
typeset PH_OPTARG_VAL=""
typeset PH_MSG_TYPE=""
typeset PH_OLD_WAS_SET=""
typeset PH_NEWVALUE=""
typeset PH_OLDOPTARG="$OPTARG"
typeset PH_OPT_DEFS=""
typeset PH_OPT_REGEX=""
typeset -u PH_APPU=`echo $PH_APP | cut -c1-4`
typeset -i PH_LENGTH=0
typeset -i PH_NOW=0
typeset -i PH_END=0
typeset -i PH_RET_CODE=0
typeset -i PH_OLDOPTIND=$OPTIND
OPTIND=2

[[ "$PH_APP" == "LoginScript" ]] && cp -p $PH_FILES_DIR/LoginScript.template $PH_CONF_DIR/LoginScript.conf
([[ -f $PH_CONF_DIR/$PH_APP.conf && $# -gt 1 ]] ; return $?) || ph_set_option PieHelper -h && while getopts o:r:h PH_OPTION 2>/dev/null
do
	case $PH_OPTION in o)
			export PH_MSG_TYPE="Warning" ;;
			   r)
			export PH_MSG_TYPE="ERROR" ;;
			   *)
                	>&2 printf "%s\n" "Usage : ph_set_option [configfile] -[o|r] [option]='[value]' -[o|r] [option]=[value] ..."
                	>&2 printf "\n"
                	>&2 printf "%3s%s\n" "" "Where - [configfile] is the name of the configfile to edit without the .conf file extension"
                	>&2 printf "%11s%s\n" "" "[configfile] should always be the first argument"
                	>&2 printf "%9s%s\n" "" "- [option] is the exact optionname to change. Option names are case-sensitive"
                	>&2 printf "%9s%s\n" "" "- [value] is the new value to assign to option. Option values are case-sensitive"
                	>&2 printf "%9s%s\n" "" "-o defines the option change as an optional operation"
                	>&2 printf "%11s%s\n" "" "Optional operations may fail and will only generate a warning"
                	>&2 printf "%9s%s\n" "" "-r defines the option change as a required operation"
                	>&2 printf "%11s%s\n" "" "Required operations may not fail and will generate an error"
                	>&2 printf "\n"
			((PH_RET_CODE++))
			break ;;
	esac
	PH_OLD_WAS_SET="no"
	PH_OPTARG_VAR="`echo -n $OPTARG | cut -d'=' -f1`"
	PH_OPTARG_VAL="`echo -n $OPTARG | cut -d'=' -f2`"
	if [[ "$PH_APP" != "LoginScript" ]]
	then
		if ! grep ^"$PH_OPTARG_VAR" $PH_CONF_DIR/$PH_APP.conf >/dev/null
		then
			printf "%8s%s\n" "" "--> Setting read-only option $PH_OPTARG_VAR to value '$PH_OPTARG_VAL' in $PH_CONF_DIR/$PH_APP.conf"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Option is read-only"
			else
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Option is read-only -> Skipping"
			fi
			continue
		fi
	        PH_j=PH_"$PH_APPU"
		PH_LENGTH=`echo -n PH_"$PH_APPU" | wc -c`
		PH_SUFFIX=`echo -n $PH_OPTARG_VAR | cut -c"$((PH_LENGTH+1))"-`
		[[ "$PH_SUFFIX" == @(_CMD_OPTS|_NUM_CTRL|_USE_CTRL) ]] && PH_SUFFIX=""
		for PH_i in _CMD_OPTS _NUM_CTRL _USE_CTRL $PH_SUFFIX
		do
			if [[ -z "`eval echo -n \\$OLD_\"\$PH_j\$PH_i\"`" ]]
			then
				export OLD_$PH_j"$PH_i"="`eval echo -n \"\\$\$PH_j\$PH_i\"`"
			else
				[[ "$PH_OPTARG_VAR" == *"$PH_i" ]] && PH_OLD_WAS_SET="yes"
			fi
			[[ `typeset -p PH_OLDVALUE"$PH_i"` == "typeset -n "* ]] && unset -n PH_OLDVALUE"$PH_i"
			typeset -n PH_OLDVALUE"$PH_i"=OLD_"$PH_j"$PH_i
			[[ `typeset -p PH_CURVALUE"$PH_i"` == "typeset -n "* ]] && unset -n PH_CURVALUE"$PH_i"
			typeset -n PH_CURVALUE"$PH_i"="$PH_j"$PH_i
			if [[ "$PH_OPTARG_VAR" == *"$PH_i" ]]
			then
				[[ `typeset -p PH_OLDVALUE` == "typeset -n "* ]] && unset -n PH_OLDVALUE
				typeset -n PH_OLDVALUE=OLD_"$PH_j"$PH_i
				[[ `typeset -p PH_CURVALUE` == "typeset -n "* ]] && unset -n PH_CURVALUE
				typeset -n PH_CURVALUE="$PH_j"$PH_i
			fi
		done
		if [[ "$PH_OPTARG_VAL" == `echo $PH_CURVALUE` ]]
		then
			printf "%8s%s\n" "" "--> Setting read-write option $PH_OPTARG_VAR to value '$PH_OPTARG_VAL' in $PH_CONF_DIR/$PH_APP.conf"
			printf "%10s%s\n" "" "OK (Nothing to do)"
			continue
		fi
		if (([[ "$PH_OPTARG_VAR" == "PH_MOON_USE_CTRL" ]]) && ([[ "$PH_OPTARG_VAL" == "no" ]]))
		then
			printf "%8s%s\n" "" "--> Attempting to remove controller usage for $PH_APP"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Controller usage is required for $PH_APP"
			else
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Controller usage is required for $PH_APP -> Skipping"
			fi
			continue
		fi
		if (([[ "$PH_OPTARG_VAR" == "PH_MOON_CMD_OPTS" ]]) && (! echo "$PH_OPTARG_VAL" | grep ' /dev/input/eventPH_CTRL' >/dev/null))
		then
			printf "%8s%s\n" "" "--> Attempting to remove controller CLI ids from $PH_APP command options"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Controller CLI ids are required command options for $PH_APP"
			else
				printf "%10s%s\n" "" "$PH_MSG_TYPE : Controller CLI ids are required command options for $PH_APP -> Skipping"
			fi
			continue
		fi
		if grep ^"$PH_OPTARG_VAR:" $PH_FILES_DIR/options.allowed >/dev/null
		then
			printf "%8s%s\n" "" "--> Checking new value for $PH_OPTARG_VAR against allowed defaults"
			PH_OPT_DEFS=`grep ^"$PH_OPTARG_VAR:" $PH_FILES_DIR/options.allowed | nawk -F':' '{ print $2 }'`
			PH_OPT_REGEX=`grep ^"$PH_OPTARG_VAR:" $PH_FILES_DIR/options.allowed | nawk -F':' '{ print $3 }'`
			eval [[ $PH_OPT_REGEX ]] \
					&& true || false
       				if [[ $? -ne 0 ]]
				then
					if [[ "$PH_MSG_TYPE" == "ERROR" ]]
					then
						((PH_RET_CODE++))
						printf "%10s%s\n" "" "$PH_MSG_TYPE : Trying to set an unallowed value for $PH_OPTARG_VAR ($PH_OPTARG_VAL is not \"$PH_OPT_DEFS\")"
					else
						printf "%10s%s\n" "" "$PH_MSG_TYPE : Trying to set an unallowed value for $PH_OPTARG_VAR ($PH_OPTARG_VAL is not \"$PH_OPT_DEFS\") -> Skipping"
					fi
					continue
				else
       					printf "%10s%s\n" "" "OK"
				fi
		fi
	fi
	printf "%8s%s\n" "" "--> Setting read-write option $PH_OPTARG_VAR to value '$PH_OPTARG_VAL' in $PH_CONF_DIR/$PH_APP.conf"
	PH_OPTARG_VAL="`ph_escape_paths $PH_OPTARG_VAL`"
	if sed 's/^\('$PH_OPTARG_VAR'=\)\([^\t]*\)\(\t*#.*\)/\1'\'"$PH_OPTARG_VAL"\''\3/' $PH_CONF_DIR/$PH_APP.conf >/tmp/$PH_APP.conf_tmp 2>/dev/null
	then
		PH_OPTARG_VAL="`ph_undo_escape_paths $PH_OPTARG_VAL`"
		eval export $PH_OPTARG_VAR=\'$PH_OPTARG_VAL\'
	else
		PH_OPTARG_VAL="`ph_undo_escape_paths $PH_OPTARG_VAL`"
		(printf "%10s%s%s\n" "" "$PH_MSG_TYPE" " : Could not set read-write option $PH_OPTARG_VAR to value '$PH_OPTARG_VAL' in $PH_CONF_DIR/$PH_APP.conf" ; \
		rm /tmp/$1.conf_tmp 2>/dev/null ; return 1)
	fi
	case $?_"$PH_OPTION" in !(0)_r)
			((PH_RET_CODE++))
			break ;;
				!(0)_o)
			continue ;;
				0_[or])
			printf "%10s%s\n" "" "OK" ; mv /tmp/$PH_APP.conf_tmp $PH_CONF_DIR/$PH_APP.conf
			if (([[ "$PH_OPTARG_VAR" == PH_"$PH_APPU"_NUM_CTRL ]]) && (echo $PH_CURVALUE_CMD_OPTS | grep ' /dev/input/eventPH_CTRL' >/dev/null))
			then
				PH_END=$PH_OPTARG_VAL
				PH_NOW=`echo $PH_CURVALUE_CMD_OPTS | nawk 'BEGIN { count=0 } { for (i=1;i<=NF;i++) { if ($i ~ "/dev/input/eventPH_CTRL.") { count++ }}} END { print count }'`
				if [[ $PH_END -ne $PH_NOW ]]
				then
					if [[ $PH_NOW -gt $PH_END ]]
					then
						PH_NEWVALUE="`echo $PH_CURVALUE_CMD_OPTS | nawk -v curval=$PH_NOW 'BEGIN { ORS = \"\" ; compare = "/dev/input/eventPH_CTRL"curval } \
							{ for (i=1;i<=NF;i++) { if ($(i+1) !~ compare && $i !~ compare) { print $i ; if (i<(NF-2)) { print \" \" }}}}'`"
						while [[ $((PH_NOW-1)) -gt $PH_END ]]
						do
							PH_NOW=`echo $PH_NEWVALUE | nawk 'BEGIN { count=0 } { for (i=1;i<=NF;i++) { if ($i ~ "/dev/input/eventPH_CTRL.") { count++ }}} END { print count }'`
							PH_NEWVALUE="`echo $PH_NEWVALUE | nawk -v curval=$PH_NOW 'BEGIN { ORS = \"\" ; compval = "/dev/input/eventPH_CTRL"curval } \
								{ for (i=1;i<=NF;i++) { if ($(i+1) !~ compval && $i !~ compval) { print $i ; if (i<(NF-2)) { print \" \" }}}}'`"
						done
					else
						PH_NEWVALUE="`echo $PH_CURVALUE_CMD_OPTS | nawk -v curval=$PH_NOW 'BEGIN { ORS = \"\" ; ind = 0 ; compval = "/dev/input/eventPH_CTRL"curval ; printval = "/dev/input/eventPH_CTRL"(curval+1) } \
							{ for (i=1;i<=NF;i++) { if ($(i+1) ~ compval) { param = $i ; ind = i ; print $i \" \" } \
								else { if (i==NF) { if (i==(ind+1)) { print $i \" \" param \" \" printval } else { print $i }} \
									else { if (i==(ind+1) && ind>0) { print $i \" \" param \" \" printval \" \" } \
										else { print $i \" \" }}}}}'`"
						while [[ $((PH_NOW+1)) -lt $PH_END ]]
						do
							PH_NOW=`echo $PH_NEWVALUE | nawk 'BEGIN { count=0 } { for (i=1;i<=NF;i++) { if ($i ~ "/dev/input/eventPH_CTRL.") { count++ }}} END { print count }'`
							PH_NEWVALUE="`echo $PH_NEWVALUE | nawk -v curval=$PH_NOW 'BEGIN { ORS = \"\" ; ind = 0 ; compval = "/dev/input/eventPH_CTRL"curval ; printval = "/dev/input/eventPH_CTRL"(curval+1) } \
								{ for (i=1;i<=NF;i++) { if ($(i+1) ~ compval) { param = $i ; ind = i ; print $i \" \" } \
									else { if (i==NF) { if (i==(ind+1)) { print $i \" \" param \" \" printval } else { print $i }} \
										else { if (i==(ind+1) && ind>0) { print $i \" \" param \" \" printval \" \" } \
											else { print $i \" \" }}}}}'`"
						done
					fi
					if ! ph_set_option "$PH_APP" -r PH_"$PH_APPU"_CMD_OPTS="$PH_NEWVALUE"
					then
						ph_set_option "$PH_APP" -r PH_"$PH_APPU"_NUM_CTRL="`echo $PH_OLDVALUE`"
						((PH_RET_CODE++))
					fi
				fi
			fi
                        if (([[ "$PH_OPTARG_VAR" == PH_"$PH_APPU"_CMD_OPTS ]]) && (echo "$PH_OPTARG_VAL" | grep ' /dev/input/eventPH_CTRL' >/dev/null))
                        then
                                PH_NEWVALUE="`echo $PH_OPTARG_VAL | nawk 'BEGIN { count=0 } { for (i=1;i<=NF;i++) { if ($i ~ "/dev/input/eventPH_CTRL.") { count++ }}} END { print count }'`"
                                if [[ `echo $PH_CURVALUE_NUM_CTRL` != "$PH_NEWVALUE" ]]
                                then
					if ! ph_set_option "$PH_APP" -r PH_"$PH_APPU"_NUM_CTRL="$PH_NEWVALUE"
					then
						ph_set_option "$PH_APP" -r PH_"$PH_APPU"_CMD_OPTS="`echo $PH_OLDVALUE`"
						((PH_RET_CODE++))
					fi
				fi
                        fi
			[[ "$PH_OLD_WAS_SET" == "no" && "$PH_APP" != "LoginScript" ]] && eval export OLD_"$PH_OPTARG_VAR"=\'$PH_OPTARG_VAL\' ;;
	esac
done
[[ $OPTIND -eq 2 ]] && PH_RET_CODE=1
OPTIND=$PH_OLDOPTIND
OPTARG="$PH_OLDOPTARG"
if [[ "$PH_APP" != "LoginScript" ]]
then
	if [[ "$PH_OLD_WAS_SET" == "no" ]]
	then
		unset OLD_"$PH_OPTARG_VAR" OLD_PH_"$PH_APPU"_NUM_CTRL OLD_PH_"$PH_APPU"_USE_CTRL OLD_PH_"$PH_APPU"_CMD_OPTS
	fi
	unset -n PH_OLDVALUE PH_CURVALUE PH_OLDVALUE_CMD_OPTS PH_OLDVALUE_USE_CTRL PH_OLDVALUE_NUM_CTRL PH_CURVALUE_CMD_OPTS PH_CURVALUE_USE_CTRL PH_CURVALUE_NUM_CTRL
	[[ "$PH_SUFFIX" != "" ]] && unset -n PH_OLDVALUE"$PH_SUFFIX" PH_CURVALUE"$PH_SUFFIX"
fi
return $PH_RET_CODE
}

function ph_mount_cifs_share {

typeset PH_i=""
typeset -u PH_APPU=`echo $1 | cut -c1-4`
typeset -i PH_LENGTH=`echo $PH_APPU | wc -c`
typeset -i PH_RET_CODE=0
for PH_i in PH_"$PH_APPU"_CIFS_USER PH_"$PH_APPU"_CIFS_PASS PH_"$PH_APPU"_CIFS_SRV PH_"$PH_APPU"_CIFS_DIR PH_"$PH_APPU"_CIFS_SUBDIR PH_"$PH_APPU"_CIFS_MPT
do
	eval [[ -n \$OLD_$PH_i ]] && typeset -n TMP_`echo $PH_i | cut -c$((PH_LENGTH+4))-`=OLD_"$PH_i" || \
					typeset -n TMP_`echo $PH_i | cut -c$((PH_LENGTH+4))-`="$PH_i"
done

printf "%8s%s\n" "" "--> Mounting cifs share"
for PH_i in _CIFS_USER _CIFS_PASS _CIFS_SRV _CIFS_DIR _CIFS_SUBDIR _CIFS_MPT
do
	eval [[ -z \"\$TMP$PH_i\" ]] && printf "%10s%s\n" "" "ERROR : Required variable PH_$PH_APPU$PH_i is unset" && PH_RET_CODE=1 && break
done
if [[ $PH_RET_CODE -eq 0 ]]
then
	$PH_SUDO `which mount` -t cifs -o username="$TMP_CIFS_USER" -o password="$TMP_CIFS_PASS" -o rw,uid="$TMP_CIFS_USER" \
					"//$TMP_CIFS_SRV$TMP_CIFS_DIR$TMP_CIFS_SUBDIR" `eval echo -n "$TMP_CIFS_MPT"` 2>/dev/null
	[[ $? -ne 0 ]] && printf "%10s%s\n" "" "ERROR : Could not mount \"$TMP_CIFS_DIR$TMP_CIFS_SUBDIR\" from server $TMP_CIFS_SRV to `eval echo -n \"$TMP_CIFS_MPT\"`" && PH_RET_CODE=1 || \
			printf "%10s%s\n" "" "OK"
fi
unset -n TMP_CIFS_USER TMP_CIFS_PASS TMP_CIFS_SRV TMP_CIFS_DIR TMP_CIFS_SUBDIR TMP_CIFS_MPT
return $PH_RET_CODE
}

function ph_umount_cifs_share {

typeset -u PH_APPU=`echo $1 | cut -c1-4`
typeset -n PH_CIFS_MPT=PH_"$PH_APPU"_CIFS_MPT

printf "%8s%s\n" "" "--> Unmounting cifs share"
$PH_SUDO `which umount` -f `eval echo -n "$PH_CIFS_MPT"` 2>/dev/null || (printf "%10s%s\n" "" "ERROR : Could not unmount `eval echo -n \"$PH_CIFS_MPT\"`" ; return 1) || return $?
printf "%10s%s\n" "" "OK"
unset -n PH_CIFS_MPT
return 0
}

function ph_screen_input {

if [[ `echo "$*" | sed 's/[ ,/.]//g'` == *+([![:word:]])* ]] 2>/dev/null
then
	printf "%2s%s\n\n" "" "ABORT : Invalid input characters detected"
	return 1
fi
return 0
}

function ph_restore_emul_conf {

if [[ -f $PH_FILES_DIR/autologin.conf ]]
then
	printf "%8s%s\n" "" "--> Restoring Emulationstation autologin configuration"
	$PH_SUDO mv $PH_FILES_DIR/10-retropie.sh /etc/profile.d
	$PH_SUDO mkdir /etc/systemd/system/getty@tty1.service.d
	$PH_SUDO mv $PH_FILES_DIR/autologin.conf /etc/systemd/system/getty@tty1.service.d
	printf "%10s%s\n" "" "OK"
fi
return 0
}

function ph_move_emul_conf {

printf "%8s%s\n" "" "--> Moving Emulationstation autologin configuration"
$PH_SUDO mv /etc/profile.d/10-retropie.sh $PH_FILES_DIR/10-retropie.sh
$PH_SUDO mv /etc/systemd/system/getty@tty1.service.d/autologin.conf $PH_FILES_DIR/autologin.conf
$PH_SUDO rm -r /etc/systemd/system/getty@tty1.service.d >/dev/null 2>&1
printf "%10s%s\n" "" "OK"
return 0
}

function ph_show_emul_info {

printf "%8s%s\n" "" "--> Displaying Emulationstation ROMS info"
printf "%10s%s\n" "" "OK"
printf "\n"
ph_print_bannerline
printf "\n"
printf "%8s%s\n\n" "" "Emulationstation ROMS can either :"
printf "%10s%s\n" "" "- be copied locally under $PH_EMUL_SETUP_DIR/roms"
printf "%10s%s\n" "" "- OR be provided over CIFS by setting the appropriate options for Emulationstation"
printf "%12s%s\n" "" "using either 'confopts_ph.sh' or the PieHelper menu"
printf "\n"
ph_print_bannerline
printf "\n"
return 0
}

function ph_install_app {

typeset PH_APP="$1"
typeset PH_EMUL_SETUP_DIR_INIT=""
typeset PH_EMUL_DIR_INIT=""
typeset -u PH_APPU=`echo $PH_APP | cut -c1-4`
typeset -l PH_APPL=`echo $PH_APP | cut -c1-4`

printf "%s\n" "- Running some checks"
printf "%8s%s\n" "" "--> Checking for out-of-scope applications"
[[ "$PH_APP" != @(Moonlight|Emulationstation|Bash|X11|Kodi) ]] && printf "%10s%s\n" "" "ERROR : Out-of-scope applications should be managed with confsupp_ph.sh" && \
		printf "%2s%s\n\n" "" "FAILED" && return 1
printf "%10s%s\n" "" "OK (No)"
printf "%8s%s\n" "" "--> Checking for $PH_APP integration"
ph_check_app_name -i -a "$PH_APP" >/dev/null && printf "%10s%s\n" "" "Warning : $PH_APP already integrated" && \
				printf "%2s%s\n\n" "" "SUCCESS" && return 0
printf "%10s%s\n" "" "OK (Not integrated)"
printf "%8s%s\n" "" "--> Checking dependencies"
if [[ "$PH_APP" == "Kodi" ]]
then
	printf "%10s%s\n" "" "OK (X11)"
	printf "%8s%s\n" "" "--> Checking X11 install status"
	if ! ph_get_pkg_inststate $PH_X11_PKG_NAME
	then
		printf "%10s%s\n" "" "Warning : X11 not found -> Installing"
		printf "%2s%s\n" "" "SUCCESS"
		ph_install_app X11 || (printf "%s\n" "- Integrating $PH_APP" ; \
			printf "%2s%s\n\n" "" "FAILED" ; return 1) || return $?
	else
		printf "%10s%s\n" "" "OK (Found)"
	fi
else
	printf "%10s%s\n" "" "OK (None)"
fi
printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Integrating $PH_APP"
printf "%8s%s\n" "" "--> Checking for a package name"
if [[ -n `eval echo \\$PH_"$PH_APPU"_PKG_NAME` ]]
then
	printf "%10s%s\n" "" "OK (Found)"
	printf "%8s%s\n" "" "--> Installing `eval echo \\$PH_"$PH_APPU"_PKG_NAME` package (This may take a while)"
	if ! ph_install_pkg `eval echo \\$PH_"$PH_APPU"_PKG_NAME`
	then
		printf "%10s%s\n" "" "Warning : Could not locate or install `eval echo \\$PH_"$PH_APPU"_PKG_NAME` package"
	else
		printf "%10s%s\n" "" "OK"
		printf "%2s%s\n" "" "SUCCESS"
		ph_generate_installed_apps "$PH_APP"
		eval ph_configure_"$PH_APPL"
		return 0
	fi
else
	printf "%10s%s\n" "" "OK (Not found)"
fi
printf "%8s%s\n" "" "--> Attempting packageless integration"
case $PH_APP in Moonlight)
		printf "%10s%s\n" "" "OK ($PH_APP)"
		cd >/dev/null
		$PH_SUDO rm -r moonlight-embedded 2>/dev/null
		rm /tmp/"$PH_APP".compile /tmp/"$PH_APP".generate 2>/dev/null
		printf "%8s%s\n" "" "--> Downloading $PH_APP source"
		git clone https://github.com/irtimmer/moonlight-embedded.git >/dev/null 2>&1
		[[ $? -eq 0 ]] && printf "%10s%s\n" "" "OK" || (printf "%10s%s\n" "" "ERROR : Could not download Moonlight source" ; \
				printf "%2s%s\n\n" "" "FAILED" ; return 1) || return $?
		cd moonlight-embedded
		git submodule update --init >/dev/null 2>&1
		mkdir build
		cd build/
		printf "%8s%s\n" "" "--> Attempting to generate build for $PH_APP source (This may take a while)"
		cmake ../ >/tmp/"$PH_APP".generate 2>&1
		if [[ $? -ne 0 ]]
		then
			printf "%10s%s\n" "" "ERROR : Could not compile $PH_APP source (Logfile /tmp/$PH_APP.generate)"
			printf "%8s%s\n" "" "--> Displaying build generation logfile (Press 'q' to quit)"
			printf "%10s%s\n\n" "" "OK"
			ph_print_bannerline
			printf "\n"
			less /tmp/"$PH_APP".generate
			printf "\n"
			ph_print_bannerline
			printf "\n"
			printf "%2s%s\n\n" "" "FAILED"
			return 1
		fi
		printf "%10s%s\n" "" "OK (build location is $HOME/moonlight-embedded)"
		printf "%8s%s\n" "" "--> Attempting to compile $PH_APP source (This may take a while)"
		make >/tmp/"$PH_APP".compile 2>&1
		if [[ $? -ne 0 ]]
		then
			printf "%10s%s\n" "" "ERROR : Could not compile $PH_APP source (Logfile /tmp/$PH_APP.compile)"
			printf "%8s%s\n" "" "--> Displaying compilation logfile (Press 'q' to quit)"
			printf "%10s%s\n\n" "" "OK"
			ph_print_bannerline
			printf "\n"
			less /tmp/"$PH_APP".compile
			printf "\n"
			ph_print_bannerline
			printf "\n"
			printf "%2s%s\n\n" "" "FAILED"
			return 1
		fi
		printf "%10s%s\n" "" "OK"
		rm /tmp/"$PH_APP".compile /tmp/"$PH_APP".generate 2>/dev/null
		printf "%8s%s\n" "" "--> Copying files to final locations"
		$PH_SUDO make install >/dev/null
		printf "%10s%s\n" "" "OK" ;;
	 Emulationstation)
		printf "%10s%s\n" "" "OK ($PH_APP)"
		cd >/dev/null
		$PH_SUDO rm -r RetroPie-Setup 2>/dev/null
		printf "%8s%s\n" "" "--> Downloading $PH_APP setup script"
		git clone --depth=1 https://github.com/RetroPie/RetroPie-Setup.git >/dev/null 2>&1
		[[ $? -eq 0 ]] && printf "%10s%s\n" "" "OK" || (printf "%10s%s\n" "" "ERROR : Could not download $PH_APP setup script" ; \
				printf "%2s%s\n\n" "" "FAILED" ; return 1) || return $?
		cd RetroPie-Setup
		$PH_SUDO chmod +x retropie_setup.sh
		printf "%8s%s\n\n" "" "--> Executing $PH_APP setup script"
		printf "%12s%s\n" "" "- Use this setup script to do a basic install of $PH_APP"
		printf "%14s%s\n" "" "Note that running basic install could take up to 30 minutes depending on your current system configuration"
		printf "%12s%s\n" "" "- Settings for autostart configured with this script will be overridden by PieHelper"
		printf "%12s%s\n\n" "" "- Exit the script normally after it finishes and PieHelper integration will resume"
		printf "%12s%s" "" "Press Enter to continue"
		read 2>/dev/null
		printf "%10s%s\n" "" "OK"
		printf "%2s%s\n" "" "SUCCESS"
		clear
		$PH_SUDO ./retropie_setup.sh
		printf "%s\n"  "- Resuming PieHelper integration for $PH_APP"
		printf "%8s%s\n" "" "--> Attempting to determine $PH_APP base directory"
		if [[ -f /etc/profile.d/10-retropie.sh ]]
		then
			PH_EMUL_DIR_INIT=`nawk -F'"' '$1 ~ /bash/ { print $2 }' /etc/profile.d/10-retropie.sh 2>/dev/null`
			if [[ -n "$PH_EMUL_DIR_INIT" ]]
			then
				PH_EMUL_DIR_INIT=${PH_EMUL_DIR_INIT%%/configs*}
				printf "%10s%s\n" "" "OK"
			fi
		else
			[[ -d /opt/retropie ]] && PH_EMUL_DIR_INIT="/opt/retropie" && printf "%10s%s\n" "" "OK"
		fi
		PH_EMUL_SETUP_DIR_INIT="$HOME/RetroPie"
		! ph_set_option $PH_APP -r PH_EMUL_DIR="$PH_EMUL_DIR_INIT" && printf "%2s%s\n\n" "" "FAILED" && return 1
		[[ -z "$PH_EMUL_DIR" ]] && (printf "%10s%s\n" "" "Warning : Could not determine $PH_APP base directory" ; \
					printf "%20s%s\n" "" "Try manually setting PH_EMUL_DIR to the correct value using 'confopts_ph.sh' or the PieHelper menu" ; \
					printf "%2s%s\n\n" "" "FAILED" ; return 0) && return 1
		! ph_set_option $PH_APP -r PH_EMUL_SETUP_DIR="$PH_EMUL_SETUP_DIR_INIT" && printf "%2s%s\n\n" "" "FAILED" && return 1
		ph_show_emul_info
		[[ -f /etc/profile.d/10-retropie.sh ]] && ph_move_emul_conf ;;
			*)
		printf "%10s%s\n" "" "ERROR : Could not integrate $PH_APP without a valid packagename"
		printf "%18s%s\n" "" "Try manually setting PH_`echo $PH_APPU`_PKG_NAME to the correct value using 'confopts_ph.sh' or the PieHelper menu"
		printf "%2s%s\n\n" "" "FAILED"
		return 1 ;;
esac
printf "%2s%s\n" "" "SUCCESS"
ph_generate_installed_apps "$PH_APP"
eval ph_configure_"$PH_APPL"
return 0
}

function ph_remove_app {

typeset PH_APP="$1"
typeset PH_PATH=""
typeset PH_i=""
typeset PH_RESULT="SUCCESS"
typeset PH_APP_CMD=""
typeset PH_APP_USER=""
typeset -l PH_APPL=`echo $PH_APP | cut -c1-4`
typeset -u PH_APPU=`echo $PH_APP | cut -c1-4`
typeset -i PH_APP_TTY=0

PH_APP_TTY=`nawk -v app=^"$PH_APP"$ '$1 ~ app && $4 !~ /^-$/ { print $4 }' $PH_CONF_DIR/installed_apps`
PH_APP_USER=`nawk -v app=^"$PH_APP"$ '$1 ~ app { print $2 }' $PH_CONF_DIR/installed_apps`
PH_APP_CMD=`nawk -v app=^"$PH_APP"$ 'BEGIN { ORS=" " } $1 ~ app { for (i=2;i<=NF;i++) { if (i==NF) { ORS="" ; print $i } else { print $i }}}' $PH_CONF_DIR/supported_apps`
PH_APP_CMD=`sed "s/PH_TTY/$PH_APP_TTY/" <<<$PH_APP_CMD`
if pgrep -t tty$PH_APP_TTY -f "$PH_APP_CMD" >/dev/null
then
	$PH_SCRIPTS_DIR/stop"$PH_APPL".sh
fi
printf "%s\n" "- Running some checks"
printf "%8s%s\n" "" "--> Checking for Bash"
[[ "$PH_APP" == "Bash" ]] && printf "%10s%s\n" "" "ERROR : Bash cannot be removed from PieHelper" && \
		printf "%2s%s\n\n" "" "FAILED" && return 1
printf "%10s%s\n" "" "OK (No)"
printf "%8s%s\n" "" "--> Checking for out-of-scope applications"
[[ "$PH_APP" != @(Moonlight|Emulationstation|X11|Kodi) ]] && printf "%10s%s\n" "" "ERROR : Out-of-scope applications should be managed with confsupp_ph.sh" && \
		printf "%2s%s\n\n" "" "FAILED" && return 1
printf "%10s%s\n" "" "OK (No)"
printf "%8s%s\n" "" "--> Checking dependencies"
if ([[ "$PH_APP" == "X11" ]] && ph_check_app_name -i -a Kodi >/dev/null ]])
then
	printf "%10s%s\n" "" "ERROR : Could not remove X11 from PieHelper (Kodi is dependent)"
	printf "%2s%s\n\n" "" "FAILED"
	return 1
else
	printf "%10s%s\n" "" "OK (None)"
fi
printf "%8s%s\n" "" "--> Checking if configured as the default application to start on system boot"
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	printf "%10s%s\n" "" "Warning : Yes -> Unconfiguring"
	printf "%2s%s\n" "SUCCESS"
	! ph_set_app_for_start none && printf "%2s%s\n\n" "" "FAILED" && return 1
else
	printf "%10s%s\n" "" "OK (No)"
	printf "%2s%s\n" "" "SUCCESS"
fi
printf "%s\n" "- Removing $PH_APP from PieHelper"
printf "%8s%s\n" "" "--> Checking if installed as a package"
if [[ `nawk -v app=^"$PH_APP"$ '$1 ~ app { print $3 }' $PH_CONF_DIR/installed_apps` == "yes" ]]
then
	printf "%10s%s\n" "" "OK (Yes)"
	printf "%8s%s\n" "" "--> Uninstalling `eval echo \\$PH_"$PH_APPU"_PKG_NAME` package (This may take a while)"
	if ! ph_remove_pkg `eval echo \\$PH_"$PH_APPU"_PKG_NAME`
	then
		printf "%10s%s\n" "" "ERROR : Could not uninstall package `eval echo \\$PH_"$PH_APPU"_PKG_NAME`"
		printf "%2s%s\n\n" "" "FAILED"
		return 1
	else
		printf "%10s%s\n" "" "OK"
		printf "%s\n" "- Cleaning up"
	fi
else
	printf "%10s%s\n" "" "OK (No)"
	printf "%8s%s\n" "" "--> Attempting packageless removal"
	case $PH_APP in Moonlight)
		printf "%10s%s\n" "" "OK ($PH_APP)"
		printf "%8s%s\n" "" "--> Checking for $PH_APP build repository at default location"
		if [[ ! -d $HOME/moonlight-embedded ]]
		then
			printf "%10s%s\n" "" "Warning : Not found"
			printf "%8s%s\n" "" "--> Trying to locate $PH_APP build repository"
			PH_PATH=`$PH_SUDO find / -type d ! -fstype nfs -name moonlight-embedded 2>/dev/null`
			[[ $? -ne 0 ]] && printf "%10s%s\n" "" "ERROR : Could not locate $PH_APP build repository" && return 1
		else
			printf "%10s%s\n" "" "OK (Found)"
			PH_PATH="$HOME/moonlight-embedded"
		fi
		cd $PH_PATH/build
		printf "%8s%s\n" "" "--> Removing files from final location"
		cat install_manifest.txt | $PH_SUDO xargs rm >/dev/null 2>&1
		printf "%10s%s\n" "" "OK"
		cd $HOME
		printf "%8s%s\n" "" "--> Removing build repository"
		$PH_SUDO rm -r $PH_PATH 2>/dev/null
		printf "%10s%s\n" "" "OK" ;;
		 Emulationstation)
		printf "%10s%s\n" "" "OK ($PH_APP)"
		printf "%8s%s\n" "" "--> Checking for $PH_APP setup script at default location"
		if [[ ! -f $PH_EMUL_SETUP_DIR-Setup/retropie_setup.sh ]]
		then
			printf "%10s%s\n" "" "Warning : Not found"
			printf "%8s%s\n" "" "--> Trying to locate $PH_APP setup script"
			PH_PATH=`$PH_SUDO find / -type f -perm -o=x ! -fstype nfs -name retropie_setup.sh 2>/dev/null`
			[[ $? -ne 0 ]] && printf "%10s%s\n" "" "ERROR : Could not locate $PH_APP setup script" && return 1
			printf "%10s%s\n" "" "OK (Found)"
			PH_PATH=${PH_PATH%/*}
		else
			printf "%10s%s\n" "" "OK (Found)"
			PH_PATH="$PH_EMUL_SETUP_DIR"-Setup
		fi
		ph_set_option $PH_APP -r PH_EMUL_DIR='' -r PH_EMUL_SETUP_DIR='' || (printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
		printf "%8s%s\n\n" "" "--> Executing $PH_APP setup script"
		printf "%12s%s\n" "" "- Use this setup script to do an uninstall of $PH_APP"
		printf "%12s%s\n\n" "" "- Exit the script normally after it finishes and removal from PieHelper will resume"
		printf "%12s%s" "" "Press Enter to continue"
		read 2>/dev/null
		printf "%10s%s\n" "" "OK"
		printf "%2s%s\n" "" "SUCCESS"
		clear
		$PH_SUDO $PH_PATH/retropie_setup.sh
		printf "%s\n" "- Cleaning up"
		$PH_SUDO rm -r $PH_PATH 2>/dev/null ;;
	esac
fi
case $PH_APP in Kodi)
	printf "%8s%s\n" "" "--> Removing Kodi preferences directory"
	$PH_SUDO rm -r `eval echo ~$PH_APP_USER`/.kodi 2>/dev/null
	printf "%10s%s\n" "" "OK" ;;
	   Moonlight)
	for PH_i in PH_MOON_RES PH_MOON_FPS PH_MOON_BITRATE PH_MOON_PCKTSIZE PH_MOON_USE_CTRL PH_MOON_CMD_OPTS PH_MOON_NUM_CTRL PH_MOON_GAME PH_MOON_SRV
	do
		ph_set_option_to_default "$PH_i" || PH_RESULT="PARTIALLY FAILED"
	done ;;
esac
[[ $PH_APP_TTY -ne 0 ]] && ph_undo_setup_tty $PH_APP_TTY "$PH_APP"
printf "%8s%s\n" "" "--> Removing $PH_APP as an integrated application"
nawk -v app=^"$PH_APP"$ '$1 ~ app { next } { print }' $PH_CONF_DIR/installed_apps >/tmp/installed_apps_tmp 2>/dev/null
[[ $? -eq 0 ]] && mv /tmp/installed_apps_tmp $PH_CONF_DIR/installed_apps
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Removing default mountpoint for CIFS mounts ($PH_CONF_DIR/../mnt/$PH_APP)"
rm -r $PH_CONF_DIR/../mnt/$PH_APP >/dev/null 2>&1
printf "%10s%s\n" "" "OK"
if nawk -v user=^"$PH_APP_USER"$ '$2 ~ user { exit 1 } { next }' $PH_CONF_DIR/installed_apps >/dev/null 2>&1
then
	if [[ "$PH_RUN_USER" != "$PH_APP_USER" ]]
	then
		ph_revoke_pieh_access "$PH_APP_USER"
	fi
fi
printf "%2s%s\n\n" "" "$PH_RESULT"
return 0
}

function ph_check_pkg_run_user {

typeset PH_APP_USER=""
typeset PH_PACKAGED="yes"
typeset -u PH_APPU=`echo "${PH_APP_READ[$PH_i]}" | cut -c1-4`
typeset -i PH_COUNT=0

printf "%8s%s\n" "" "--> Checking if ${PH_APP_READ[$PH_i]} is installed as a package"
eval ph_get_pkg_inststate \$PH_"$PH_APPU"_PKG_NAME
if [[ $? -eq 0 ]]
then
	printf "%10s%s\n" "" "OK (Found)"
	printf "%8s%s\n" "" "--> Attempting to determine run account for ${PH_APP_READ[$PH_i]}"
	if [[ "$PH_APP" == "kodi-standalone" ]]
	then 
		PH_APP_USER=`systemctl show kodi 2>/dev/null | nawk -F'=' '$1 ~ /^User$/ { print $2 }'`
	else
		PH_APP_USER=`systemctl show $PH_APP 2>/dev/null | nawk -F'=' '$1 ~ /^User$/ { print $2 }'`
	fi
	[[ -n "$PH_APP_USER" ]] && printf "%10s%s\n" "" "OK" || \
			printf "%10s%s\n" "" "Warning : Could not determine run account for ${PH_APP_READ[$PH_i]}"
else
	printf "%10s%s\n" "" "OK (Not found)"
	PH_PACKAGED="no"
fi
if [[ -z "$PH_APP_USER" ]]
then
	while true
	do
		[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid input characters detected"
		printf "%8s%s\n\n" "" "--> Please specify a run account for ${PH_APP_READ[$PH_i]}"
		printf "%12s%s\n" "" "- Press Enter for the default ($PH_RUN_USER)"
		printf "%12s%s" "" "- Specifying an unexisting account will force user creation : "
		read PH_APP_USER 2>/dev/null
		((PH_COUNT++))
		ph_screen_input "$PH_APP_USER" >/dev/null || continue
		[[ -z "$PH_APP_USER" ]] && PH_APP_USER="$PH_RUN_USER"
		printf "\n%10s%s\n" "" "OK ($PH_APP_USER)"
		id $PH_APP_USER >/dev/null 2>&1
		if [[ $? -ne 0 ]]
		then
			printf "%8s%s\n" "" "Warning : User $PH_APP_USER does not exist -> Creating"
			printf "%10s%s\n" "" "OK"
			printf "%8s%s\n" "" "--> Creating group $PH_APP_USER"
			$PH_SUDO groupadd -f $PH_APP_USER >/dev/null
			printf "%10s%s\n" "" "OK"
			printf "%8s%s\n" "" "--> Creating user $PH_APP_USER"
			$PH_SUDO useradd -d /home/$PH_APP_USER -m -c "${PH_APP_READ[$PH_i]} application" -g $PH_APP_USER \
							-G tty,audio,video,input -s /bin/bash $PH_APP_USER >/dev/null 2>&1
			printf "%10s%s\n" "" "OK"
		fi
		break
	done
fi
if nawk -v user=^"$PH_APP_USER"$ '$2 ~ user { exit 1 } { next }' $PH_CONF_DIR/installed_apps >/dev/null 2>&1
then
	if [[ "$PH_APP_USER" != "$PH_RUN_USER" ]]
	then
		ph_grant_pieh_access "$PH_APP_USER"
	fi
fi
printf "%8s%s\n" "" "--> Adding ${PH_APP_READ[$PH_i]} to integrated applications configuration file"
echo -e "${PH_APP_READ[$PH_i]}\t$PH_APP_USER\t$PH_PACKAGED\t-" >>$PH_CONF_DIR/installed_apps
if [[ "${PH_APP_GRAPH[$PH_i]}" == "yes" ]]
then
	PH_APP_CMD=`echo "$PH_APP_CMD" | nawk -v path="${PH_PATH_READ[$PH_i]}" 'BEGIN { ORS = " " } { print $1 " " path ; if (NF>=3) { \
											for (i=3;i<=NF;i++) { if (i==NF) { ORS="" ; print $i } else { print $i }}}}'`
else
	PH_APP_CMD=`echo "$PH_APP_CMD" | nawk -v path="${PH_PATH_READ[$PH_i]}" 'BEGIN { ORS = " " } { print path ; if (NF>=2) { \
											for (i=2;i<=NF;i++) { if (i==NF) { ORS="" ; print $i } else { print $i }}}}'`
fi
## error handling for below nawk and correct print cmd for newlines
nawk -v app="${PH_APP_READ[$PH_i]}" -v cmd="$PH_APP_CMD" '$1 ~ app { print $1 "\t" cmd ; next } { print }' $PH_CONF_DIR/supported_apps >/tmp/supported_apps 2>/dev/null
[[ $? -eq 0 ]] && mv /tmp/supported_apps $PH_CONF_DIR/supported_apps	
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Creating default mountpoint for CIFS mounts ($PH_CONF_DIR/../mnt/${PH_APP_READ[$PH_i]})"
mkdir -p "$PH_CONF_DIR/../mnt/${PH_APP_READ[$PH_i]}" >/dev/null 2>&1
touch "$PH_CONF_DIR/../mnt/${PH_APP_READ[$PH_i]}/.gitignore"
printf "%10s%s\n" "" "OK"
return 0
}

function ph_revoke_pieh_access {

typeset PH_APP_USER="$1"

printf "%8s%s\n" "" "--> Removing ACLs for user $PH_APP_USER"
$PH_SUDO setfacl -R -x u:"$PH_APP_USER" $PH_SCRIPTS_DIR/../../PieHelper >/dev/null 2>&1
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Removing sudo rules for $PH_APP_USER"
$PH_SUDO rm /etc/sudoers.d/020_pieh-"$PH_APP_USER" 2>/dev/null
printf "%10s%s\n" "" "OK"
return 0
}

function ph_grant_pieh_access {

typeset PH_APP_USER="$1"

printf "%8s%s\n" "" "--> Installing ACLs for $PH_APP_USER"
$PH_SUDO setfacl -R -m u:"$PH_APP_USER":rwx $PH_SCRIPTS_DIR/../../PieHelper >/dev/null 2>&1
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Installing sudo rules for $PH_APP_USER"
echo "$PH_APP_USER ALL=(ALL) NOPASSWD: ALL" >/tmp/020_pieh-"$PH_APP_USER"
$PH_SUDO chown root:root /tmp/020_pieh-"$PH_APP_USER"
$PH_SUDO chmod 440 /tmp/020_pieh-"$PH_APP_USER"
$PH_SUDO mv /tmp/020_pieh-"$PH_APP_USER" /etc/sudoers.d
printf "%10s%s\n" "" "OK"
return 0
}

function ph_generate_installed_apps {

ph_check_conf_files supp || (printf "%s\n" "- Checking for supported applications configuration file" ; \
			printf "%2s%s\n" "" "FAILED : Not found" ; return 1) || return $?
typeset PH_RESULT="OK"
typeset -i PH_ANSWER=0
typeset -i PH_i=0
typeset -i PH_COUNT=0
PH_APP_CMD=""
PH_APP="$1"
if [[ $# -eq 0 ]]
then
	set -A PH_APP_READ `nawk 'BEGIN { ORS = " " } { print $1 }' $PH_CONF_DIR/supported_apps`
	set -A PH_PATH_READ `nawk -v startx=^"/usr/bin/startx"$ -v xinit=^"/usr/bin/xinit"$ '$2~xinit || ($2~startx && $1!~/^X11$/) { print $3 ; next } { print $2 }' $PH_CONF_DIR/supported_apps`
	set -A PH_APP_GRAPH `nawk -v startx=^"/usr/bin/startx"$ -v xinit=^"/usr/bin/xinit"$ '$2~xinit || ($2~startx && $1!~/^X11$/) { print "yes" ; next } { print "no" }' $PH_CONF_DIR/supported_apps`
else
	set -A PH_APP_READ "$PH_APP"
	set -A PH_PATH_READ `nawk -v app=^"$PH_APP"$ -v startx=^"/usr/bin/startx"$ -v xinit=^"/usr/bin/xinit"$ '$1 ~ app { if ($2~xinit || ($2~startx && $1!~/^X11$/)) { print $3 ; next } { print $2 ; exit }} \
							{ next }' $PH_CONF_DIR/supported_apps`
	set -A PH_APP_GRAPH `nawk -v app=^"$PH_APP"$ -v startx=^"/usr/bin/startx"$ -v xinit=^"/usr/bin/xinit"$ '$1 ~ app { if ($2~xinit || ($2~startx && $1!~/^X11$/)) { print "yes" ; exit } { print "no" ; exit }} \
							{ next }' $PH_CONF_DIR/supported_apps`
fi

export PH_i
 
printf "%s\n" "- Discovering supported applications"
for PH_i in {0..`echo $((${#PH_APP_READ[@]}-1))`}
do
	PH_ANSWER=0
	PH_COUNT=0
	PH_APP=`echo ${PH_PATH_READ[$PH_i]} | nawk -F'/' '{ print $NF ; exit }'`
	PH_APP_CMD=`nawk -v app=^"${PH_APP_READ[$PH_i]}"$ 'BEGIN { ORS=" " } $1 ~ app { for (i=2;i<=NF;i++) { if (i==NF) { ORS="" ; print $i } else { print $i }}}' $PH_CONF_DIR/supported_apps`
	printf "%8s%s\n" "" "--> Attempting to find executable $PH_APP at default location"
	`cut -f1 $PH_CONF_DIR/installed_apps | grep ^"${PH_APP_READ[$PH_i]}"$ >/dev/null 2>&1` && \
			printf "%10s%s\n" "" "Warning : ${PH_APP_READ[$PH_i]} already integrated -> Skipping" && continue
	while [[ $PH_ANSWER -eq 0 || $PH_ANSWER -ge 4 ]]
	do
		if [[ ! -f ${PH_PATH_READ[$PH_i]} ]]
		then
			[[ $PH_COUNT -eq 0 ]] && printf "%10s%s\n\n" "" "Warning : Could not find executable $PH_APP at default location"
			[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
			printf "%8s%s\n\n" "" "--> How do you wish to proceed ?"
			printf "%10s%s\n" "" "1. Run a full system scan for ${PH_APP_READ[$PH_i]}"
			printf "%10s%s\n" "" "2. Enter the location for ${PH_APP_READ[$PH_i]} manually"
			printf "%10s%s\n\n" "" "3. Skip ${PH_APP_READ[$PH_i]} for now"
			printf "%8s%s" "" "Your choice : "
			read PH_ANSWER 2>/dev/null
			((PH_COUNT++))
			case $PH_ANSWER in 1)
				printf "%10s%s\n" "" "OK"
				printf "%8s%s\n" "" "--> Attempting to locate executable $PH_APP (This may take a while)"
				PH_PATH_READ[$PH_i]=`$PH_SUDO find / -type f -perm -o=x ! -fstype nfs -name $PH_APP 2>/dev/null`
				if [[ $? -eq 0 ]]
				then
					printf "%10s%s\n\n" "" "OK (Found)"
					case $PH_RESULT in OK)
						: ;;
					    "PARTIALLY FAILED")
						: ;;
						      FAILED)
						PH_RESULT="PARTIALLY FAILED" ;;
							    *)
						PH_RESULT="OK" ;;
					esac
					ph_check_pkg_run_user
				else
					printf "%10s%s\n" "" "Warning : Could not locate executable $PH_APP"
					printf "%20s%s\n" "" "If ${PH_APP_READ[$PH_i]} is still uninstalled, use 'confapps_ph.sh' or the PieHelper menu to install it first"
				fi
				break ;;
					   2)
				printf "%10s%s\n" "" "OK"
				while true
				do
					printf "%8s%s" "" "--> Please enter the full pathname of executable $PH_APP : "
					read PH_PATH_READ[$PH_i] 2>/dev/null
					if [[ ! -f ${PH_PATH_READ[$PH_i]} ]]
					then
						printf "%10s%s\n" "" "ERROR : Could not locate executable $PH_APP"
						case $PH_RESULT in OK)
							PH_RESULT="PARTIALLY FAILED" ;;
						     	      FAILED)
							: ;;
						    "PARTIALLY FAILED")
							: ;;
								    *)
							PH_RESULT="FAILED" ;;
						esac
						break
					else
						printf "%10s%s\n" "" "OK (Found)"
						case $PH_RESULT in OK)
							: ;;
						    "PARTIALLY FAILED")
							: ;;
							      FAILED)
							PH_RESULT="PARTIALLY FAILED" ;;
								    *)
							PH_RESULT="OK" ;;
						esac
						ph_check_pkg_run_user
						break
					fi
				done
				break ;;
					   3)
				printf "%10s%s\n" "" "OK (Skipping)"
				break ;;
			esac
		else
			printf "%10s%s\n" "" "OK (Found)"
			case $PH_RESULT in OK)
				: ;;
			    "PARTIALLY FAILED")
				: ;;
				      FAILED)
				PH_RESULT="PARTIALLY FAILED" ;;
					    *)
				PH_RESULT="OK" ;;
			esac
			ph_check_pkg_run_user
			break
		fi
	done
done
[[ "$PH_RESULT" == "OK" ]] && PH_RESULT="SUCCESS"
printf "%2s%s\n" "" "$PH_RESULT"
unset PH_APP_READ PH_PATH_READ PH_APP_GRAPH PH_APP PH_i PH_APP_CMD
return 0
}

function ph_get_tty_for_app {

typeset -i PH_APP_TTY=0
typeset PH_APP="$1"

nawk -v app=^"$PH_APP"$ '$1 ~ app { if ($4!~/^-$/) { print $4 ; exit 1 } else { exit 0 }}' $PH_CONF_DIR/installed_apps 2>/dev/null
[[ $? -ne 0 ]] && return 1
for PH_APP_TTY in {2..$PH_PIEH_MAX_TTYS}
do
	cut -f4 $PH_CONF_DIR/installed_apps | grep ^$PH_APP_TTY$ >/dev/null || (echo $PH_APP_TTY && return 1) || return 0
done
echo 0
return 1
}

function ph_undo_setup_tty {

typeset PH_RUNAPP="$2"
typeset -i PH_RUNAPP_TTY=$1

printf "%8s%s\n" "" "--> Removing TTY$PH_RUNAPP_TTY autologin configuration"
$PH_SUDO rm -r /etc/systemd/system/getty@tty$PH_RUNAPP_TTY.service.d 2>/dev/null
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Removing login script PieHelper_tty$PH_RUNAPP_TTY.sh"
$PH_SUDO rm /etc/profile.d/PieHelper_tty$PH_RUNAPP_TTY.sh 2>/dev/null
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Removing TTY info from integrated applications configuration file"
nawk -v runapp=^"$PH_RUNAPP"$ -v runapptty=$PH_RUNAPP_TTY '$1 ~ runapp { print $1 "\t" $2 "\t" $3 "\t" "-" ; next } \
								{ print }' $PH_CONF_DIR/installed_apps >/tmp/installed_apps 2>/dev/null
[[ $? -eq 0 ]] && mv /tmp/installed_apps $PH_CONF_DIR/installed_apps
## add error handling for this installed_apps nawk
printf "%10s%s\n" "" "OK"
PH_RUNAPP_USER=`nawk -v runapp=^"$PH_RUNAPP"$ '$1 ~ runapp { print $2 }' $PH_CONF_DIR/installed_apps`
return 0
}

function ph_setup_tty {

typeset PH_RUNAPP="$2"
typeset PH_RUNAPP_USER=""
typeset PH_RUNAPP_CMD=""
typeset -l PH_RUNAPPL=`echo $PH_RUNAPP | cut -c1-4`
typeset -i PH_RUNAPP_TTY=$1

PH_RUNAPP_USER=`nawk -v runapp=^"$PH_RUNAPP"$ '$1 ~ runapp { print $2 }' $PH_CONF_DIR/installed_apps`
PH_RUNAPP_CMD="$PH_SCRIPTS_DIR/start$PH_RUNAPPL.sh" || \
PH_RUNAPP_CMD=`sed "s/PH_TTY/$PH_RUNAPP_TTY/" <<<$PH_RUNAPP_CMD`
ph_set_option LoginScript -r PH_RUNAPP_TTY="tty$PH_RUNAPP_TTY" -r PH_RUNAPP_USER="$PH_RUNAPP_USER" \
	      -r PH_RUNAPP_CMD="$PH_RUNAPP_CMD"
printf "%8s%s\n" "" "--> Installing login script as PieHelper_tty$PH_RUNAPP_TTY.sh"
$PH_SUDO mv $PH_CONF_DIR/LoginScript.conf /etc/profile.d/PieHelper_tty$PH_RUNAPP_TTY.sh
$PH_SUDO chown $PH_RUNAPP_USER:`$PH_SUDO id -gn $PH_RUNAPP_USER` /etc/profile.d/PieHelper_tty$PH_RUNAPP_TTY.sh
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Installing TTY$PH_RUNAPP_TTY autologin configuration"
$PH_SUDO mkdir /etc/systemd/system/getty@tty$PH_RUNAPP_TTY.service.d 2>/dev/null
cat >/tmp/autologin.conf <<EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin $PH_RUNAPP_USER --noclear tty$PH_RUNAPP_TTY \$TERM
EOF
$PH_SUDO chown root:root /tmp/autologin.conf
$PH_SUDO mv /tmp/autologin.conf /etc/systemd/system/getty@tty$PH_RUNAPP_TTY.service.d
printf "%10s%s\n" "" "OK"
$PH_SUDO systemctl daemon-reload >/dev/null 2>&1
printf "%8s%s\n" "" "--> Adding TTY info to integrated applications configuration file"
nawk -v runapp=^"$PH_RUNAPP"$ -v runapptty=$PH_RUNAPP_TTY '$1 ~ runapp { print $1 "\t" $2 "\t" $3 "\t" runapptty ; next } \
								{ print }' $PH_CONF_DIR/installed_apps >/tmp/installed_apps 2>/dev/null
## add error handling for this installed_apps nawk
[[ $? -eq 0 ]] && mv /tmp/installed_apps $PH_CONF_DIR/installed_apps
printf "%10s%s\n" "" "OK"
return 0
}

function ph_undo_app_for_start {

typeset PH_STARTAPP=""

ph_set_tty_for_boot 0
PH_STARTAPP="none"
ph_set_option PieHelper -r PH_PIEH_STARTAPP="$PH_STARTAPP" || \
	(printf "%2s%s\n" "" "FAILED" ; printf "%s\n" "You might want to choose a new startapp" ; return 1) || return $?
return 0
}

function ph_set_app_for_start {

typeset PH_STARTAPP=""
typeset -i PH_COLUMNS=`tput cols`
typeset -i PH_STARTAPP_TTY=0
typeset -i PH_COUNT=0

printf "%s\n" "- Setting the application to start by default on system boot"
printf "%8s%s\n" "" "--> Fetching currently configured application to start by default on system boot"
printf "%10s%s\n" "" "OK ($PH_PIEH_STARTAPP)"
if [[ $# -ne 0 ]]
then
	PH_STARTAPP="$1"
	printf "%8s%s\n" "" "--> Comparing old and new values"
	[[ "$PH_PIEH_STARTAPP" == "$PH_STARTAPP" ]] && printf "%10s%s\n" "" "Warning : Nothing to do (Both $PH_PIEH_STARTAPP)" && \
				printf "%2s%s\n" "" "SUCCESS" && return 0
	printf "%10s%s\n" "" "OK ($PH_STARTAPP)"
	if [[ "$PH_STARTAPP" == "none" ]]
	then
		ph_undo_app_for_start && (printf "%2s%s\n" "" "SUCCESS" ; return 0) && return $? || \
						return $?
	fi
	if [[ "$PH_PIEH_STARTAPP" != "none" ]]
	then
		ph_undo_app_for_start || return $?
	fi
else
	printf "%8s%s\n" "" "--> Listing integrated applications"
	printf "%12s%s\n\n" "" "- Info : This choice overrides equivalent settings made by Emulationstation"
	set -A PH_APP_READ "" `nawk 'BEGIN { ORS = " " } { print $1 }' $PH_CONF_DIR/installed_apps`
	while true
	do
		[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
		nawk '{ printf "%10s", "" ; print NR ". " $1 }' $PH_CONF_DIR/installed_apps
		printf "%10s%s\n\n" "" "${#PH_APP_READ[@]}. none"
		printf "%8s%s" "" "Your choice : "
		read PH_APP_READ[0] 2>/dev/null
		((PH_COUNT++))
		ph_screen_input "${PH_APP_READ[0]}"
		if [[ $? -ne 0 ]]
		then
			unset PH_APP_READ
			return 1
		fi
		case ${PH_APP_READ[0]} in `cat -n $PH_CONF_DIR/installed_apps | nawk '{ print $1 }' | paste -d "|" -s`)
			printf "%10s%s\n" "" "OK"
			PH_STARTAPP=`nawk -v startapp=${PH_APP_READ[0]} '{ if (NR==startapp) { print $1 }}' $PH_CONF_DIR/installed_apps`
			printf "%8s%s\n" "" "--> Comparing old and new values"
			[[ "$PH_PIEH_STARTAPP" == "$PH_STARTAPP" ]] && printf "%10s%s\n" "" "Warning : Nothing to do (Both $PH_PIEH_STARTAPP)" && \
						printf "%2s%s\n" "" "SUCCESS" && unset PH_APP_READ && return 0
			printf "%10s%s\n" "" "OK ($PH_STARTAPP)"
			if [[ "$PH_PIEH_STARTAPP" != "none" ]]
			then
				ph_undo_app_for_start
				[[ $? -ne 0 ]] && unset PH_APP_READ && return 1
			fi
			break ;;
												    ${#PH_APP_READ[@]})
			printf "%10s%s\n" "" "OK"
			PH_STARTAPP="none"
			if [[ "$PH_PIEH_STARTAPP" == "none" ]]
			then
				printf "%8s%s\n" "" "--> Comparing old and new values"
				[[ "$PH_PIEH_STARTAPP" == "$PH_STARTAPP" ]] && printf "%10s%s\n" "" "Warning : Nothing to do (Both $PH_PIEH_STARTAPP)" && \
							printf "%2s%s\n" "" "SUCCESS" && unset PH_APP_READ && return 0
				printf "%10s%s\n" "" "OK ($PH_STARTAPP)"
			fi
			ph_set_option PieHelper -r PH_PIEH_STARTAPP="$PH_STARTAPP" || \
				(printf "%2s%s\n" "" "FAILED" ;  printf "%s\n" "You'll need to manually set PH_PIEH_STARTAPP to \"none\" in $PH_CONF_DIR/PieHelper.conf" ; \
				 return 1) || return $?
			ph_set_tty_for_boot 0
			printf "%2s%s\n" "" "SUCCESS"
			unset PH_APP_READ
			return 0 ;;
		esac
	done
fi
printf "%8s%s\n" "" "--> Attempting to determine $PH_STARTAPP TTY"
PH_STARTAPP_TTY=`ph_get_tty_for_app $PH_STARTAPP`
if [[ $? -eq 0 ]]
then
	printf "%10s%s\n" "" "OK (None)"
	printf "%8s%s\n" "" "--> Allocating TTY$PH_STARTAPP_TTY to $PH_STARTAPP"
	printf "%10s%s\n" "" "OK"
	ph_set_tty_for_boot $PH_STARTAPP_TTY
	ph_setup_tty $PH_STARTAPP_TTY "$PH_STARTAPP"
else
	if [[ $PH_STARTAPP_TTY -eq 0 ]]
	then
		printf "%10s%s\n" "" "ERROR : All TTY's already allocated"
		printf "%2s%s\n" "" "FAILED"
		unset PH_APP_READ
		return 1
	fi
	printf "%10s%s\n" "" "OK (TTY$PH_STARTAPP_TTY)"
	ph_set_tty_for_boot $PH_STARTAPP_TTY
fi
if ! ph_set_option PieHelper -r PH_PIEH_STARTAPP="$PH_STARTAPP"
then
	ph_undo_setup_tty $PH_STARTAPP_TTY "$PH_STARTAPP"
	ph_set_tty_for_boot 0
	printf "%2s%s\n" "" "FAILED"
	printf "%s\n" "You might want to choose a new startapp"
	unset PH_APP_READ
	return 1
fi
printf "%2s%s\n" "" "SUCCESS"
unset PH_APP_READ
return 0
}

function ph_get_app_from_login_script {

typeset PH_RUNAPP=""
typeset -l PH_RUNAPPL=""
typeset -l PH_COMPAREAPPL=""

PH_COMPAREAPPL=`nawk -F\' '$1 ~ /^PH_RUNAPP_CMD=$/ { print substr($2,index($2,"start")+5,index($2,".")-(index($2,"start")+5)) }' /etc/profile.d/PieHelper_tty$PH_i.sh`
for PH_RUNAPP in `nawk 'BEGIN { ORS = " " } { print $1 }' $PH_CONF_DIR/installed_apps`
do
	PH_RUNAPPL=`echo $PH_RUNAPP | cut -c1-4`
	[[ "$PH_RUNAPPL" == "$PH_COMPAREAPPL" ]] && break
done
echo "$PH_RUNAPP"
return 0
}

function ph_repair_pieh {

typeset PH_RUNAPP_USER=""
typeset PH_RUNAPP=""
typeset PH_RESULT="SUCCESS"
typeset -i PH_STARTAPP_TTY=0
typeset -i PH_i=2

export PH_i

printf "%s\n" "- Checking for PieHelper configuration files"
printf "%8s%s\n" "" "--> Checking for supported applications configuration file"
if [[ ! -f $PH_CONF_DIR/supported_apps ]]
then
        printf "%10s%s\n" "" "Warning : Not found -> Creating"
        cat >$PH_CONF_DIR/supported_apps <<EOF
PieHelper       $PH_SCRIPTS_DIR/startpieh.sh
Bash    /bin/bash
Moonlight       /usr/local/bin/moonlight stream
Kodi    `which xinit` /usr/bin/kodi-standalone -- :0 -nolisten tcp vtPH_TTY
X11     /usr/bin/startx -- :1 vtPH_TTY
Emulationstation        /usr/bin/emulationstation
EOF
else
        printf "%10s%s\n" "" "OK (Found)"
fi
printf "%s\n" "- Checking TTY configurations"
printf "%8s%s\n" "" "--> Checking configuration of TTY1"
if [[ -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
        PH_STARTAPP_TTY=`nawk '$0 ~ /^ExecStartPost=/ { print $NF }' /etc/systemd/system/getty@tty1.service.d/autostart.conf`
        PH_RUNAPP=`nawk -v tty=\^$PH_STARTAPP_TTY\$ '$4 ~ tty { print $1 }' $PH_CONF_DIR/installed_apps`
        if [[ "$PH_RUNAPP" != "" ]]
        then
                if [[ "$PH_RUNAPP" != "$PH_PIEH_STARTAPP" ]]
                then
                        printf "%10s%s\n" "" "Warning : Configured startapp differs from PH_PIEH_STARTAPP -> Resetting PH_PIEH_STARTAPP to \"$PH_RUNAPP\""
                        ph_set_option PieHelper -r PH_PIEH_STARTAPP="$PH_RUNAPP" || PH_RESULT="PARTIALLY FAILED"
                else
                        printf "%10s%s\n" "" "OK (TTY1)"
                fi
        else
                if [[ "$PH_PIEH_STARTAPP" != "none" ]]
                then
                        printf "%10s%s\n\n" "" "Warning : Too much missing information for TTY1 -> Setting startapp to \"none\""
                        printf "%20s%s\n" "" "- You might want to choose a new application to start by default on system boot"
                        printf "%22s%s\n" "" "A new startapp can be set with confapps_ph.sh or the PieHelper menu"
                        ph_set_app_for_start none >/dev/null || PH_RESULT="PARTIALLY FAILED"
                        ph_set_pieh_tty_states || PH_RESULT="PARTIALLY FAILED"
                else
                        printf "%10s%s\n\n" "" "Warning : Too much missing information for TTY1 -> Removing remaining configuration"
                        printf "%20s%s\n" "" "- You might want to choose a new application to start by default on system boot"
                        printf "%22s%s\n" "" "A new startapp can be set with confapps_ph.sh or the PieHelper menu"
                        $PH_SUDO rm -r /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
                        ph_set_pieh_tty_states || PH_RESULT="PARTIALLY FAILED"
                fi
        fi
else
        if [[ "$PH_PIEH_STARTAPP" != "none" ]]
        then
                printf "%10s%s\n" "" "Warning : Missing autostart configuration for TTY1 -> Reconfiguring TTY1"
                printf "%8s%s\n" "" "--> Attempting to determine TTY for $PH_PIEH_STARTAPP"
                PH_STARTAPP_TTY=`nawk -v app=^"$PH_PIEH_STARTAPP"$ '$1 ~ app && $4 !~ /^-$/ { print $4 }' $PH_CONF_DIR/installed_apps`
                if [[ $PH_STARTAPP_TTY -eq 0 ]]
                then
                        printf "%10s%s\n" "" "Warning : Could not determine TTY for $PH_PIEH_STARTAPP -> Resetting PH_PIEH_STARTAPP to \"none\""
                        ph_set_option PieHelper -r PH_PIEH_STARTAPP='none' || PH_RESULT="PARTIALLY FAILED"
                else
                        printf "%10s%s\n" "" "OK"
                        ph_set_tty_for_boot $PH_STARTAPP_TTY
                fi
        else
                ph_set_pieh_tty_states >/dev/null || PH_RESULT="PARTIALLY FAILED"
        fi
fi
while [[ $PH_i -le $PH_PIEH_MAX_TTYS ]]
do
        printf "%8s%s\n" "" "--> Checking configuration of TTY$PH_i"
        if cut -f4 $PH_CONF_DIR/installed_apps | grep ^"$PH_i"$ >/dev/null
        then
                PH_RUNAPP=`nawk -v tty=\^$PH_i\$ '$4 ~ tty { print $1 }' $PH_CONF_DIR/installed_apps`
                PH_RUNAPP_USER=`nawk -v tty=\^$PH_i\$ '$4 ~ tty { print $2 }' $PH_CONF_DIR/installed_apps`
                if [[ ! -f /etc/systemd/system/getty@tty$PH_i.service.d/autologin.conf || ! -f /etc/profile.d/PieHelper_tty$PH_i.sh ]]
                then
                        printf "%10s%s\n" "" "Warning : Missing autologin configuration or missing login script for TTY$PH_i -> Reconfiguring TTY$PH_i"
                        ph_setup_tty $PH_i "$PH_RUNAPP"
                else
                        if ([[ "$PH_RUN_USER" != "$PH_RUNAPP_USER" ]] && [[ ! -f /etc/sudoers.d/020_pieh-"$PH_RUNAPP_USER" ]])
                        then
                                printf "%10s%s\n" "" "Warning : Missing sudo rules for user $PH_RUNAPP_USER -> Restoring"
                                ph_grant_pieh_access "$PH_RUNAPP_USER"
                        else
                                printf "%10s%s\n" "" "OK (TTY$PH_i)"
                        fi
                fi
        else
                if [[ -f /etc/systemd/system/getty@tty$PH_i.service.d/autologin.conf ]]
                then
                        if [[ -f /etc/profile.d/PieHelper_tty$PH_i.sh ]]
                        then
                                printf "%10s%s\n" "" "Warning : Missing information in integrated applications configuration file for TTY$PH_i -> Restoring"
                                printf "%8s%s\n" "" "--> Restoring info to integrated applications configuration file"
                                PH_RUNAPP=`ph_get_app_from_login_script`
                                nawk -v runapp=^"$PH_RUNAPP"$ -v runapptty=$PH_i '$1 ~ runapp { print $1 "\t" $2 "\t" $3 "\t" runapptty ; next } \
                                                                                                         { print }' $PH_CONF_DIR/installed_apps >/tmp/installed_apps 2>/dev/null
                                [[ $? -eq 0 ]] && mv /tmp/installed_apps $PH_CONF_DIR/installed_apps
                                printf "%10s%s\n" "" "OK"
                                PH_RUNAPP_USER=`nawk -v tty=\^$PH_i\$ '$4 ~ tty { print $2 }' $PH_CONF_DIR/installed_apps`
                                if [[ "$PH_RUN_USER" != "$PH_RUNAPP_USER" ]]
                                then
                                        printf "%8s%s\n" "" "--> Running additional check on sudo rules"
                                        if [[ -f /etc/sudoers.d/020_pieh-"$PH_RUNAPP_USER" ]]
                                        then
                                                printf "%10s%s\n" "" "OK"
                                        else
                                                printf "%10s%s\n" "" "Warning : Missing sudo rules for user $PH_RUNAPP_USER -> Restoring"
                                                ph_grant_pieh_access "$PH_RUNAPP_USER"
                                        fi
                                fi
                        else
                                printf "%10s%s\n" "" "Warning : Too much missing information for TTY$PH_i -> Removing remaining configuration where possible"
                                printf "%8s%s\n" "" "--> Removing remaining configuration information"
                                $PH_SUDO rm -r /etc/systemd/system/getty@tty$PH_i.service.d
                                printf "%10s%s\n" "" "OK"
                        fi
                else
                        if [[ -f /etc/profile.d/PieHelper_tty$PH_i.sh ]]
                        then
                                printf "%10s%s\n" "" "Warning : Missing autologin configuration for TTY$PH_i -> Reconfiguring TTY$PH_i"
                                PH_RUNAPP=`ph_get_app_from_login_script`
                                ph_setup_tty $PH_i "$PH_RUNAPP"
                                printf "%8s%s\n" "" "--> Running additional check on integrated applications configuration file"
                                printf "%10s%s\n" "" "Warning : Missing information in integrated applications configuration file for TTY$PH_i -> Restoring"
                                printf "%8s%s\n" "" "--> Restoring info to integrated applications configuration file"
                                nawk -v runapp=^"$PH_RUNAPP"$ -v runapptty=$PH_i '$1 ~ runapp { print $1 "\t" $2 "\t" $3 "\t" runapptty ; next } \
                                                                                                         { print }' $PH_CONF_DIR/installed_apps >/tmp/installed_apps 2>/dev/null
                                [[ $? -eq 0 ]] && mv /tmp/installed_apps $PH_CONF_DIR/installed_apps
                                printf "%10s%s\n" "" "OK"
                                PH_RUNAPP_USER=`nawk -v tty=\^$PH_i\$ '$4 ~ tty { print $2 }' $PH_CONF_DIR/installed_apps`
                                if [[ "$PH_RUN_USER" != "$PH_RUNAPP_USER" ]]
                                then
                                        printf "%8s%s\n" "" "--> Running additional check on sudo rules"
                                        if [[ -f /etc/sudoers.d/020_pieh-"$PH_RUNAPP_USER" ]]
                                        then
                                                printf "%10s%s\n" "" "OK"
                                        else
                                                printf "%10s%s\n" "" "Warning : Missing sudo rules for user $PH_RUNAPP_USER -> Restoring"
                                                ph_grant_pieh_access "$PH_RUNAPP_USER"
                                        fi
                                fi
                        else
                                printf "%10s%s\n" "" "OK (TTY$PH_i)"
                        fi
                fi
        fi
        ((PH_i ++))
done
printf "%2s%s\n\n" "" "$PH_RESULT"
unset PH_i
return 0
}

function ph_set_default_tty_states {

typeset -i PH_i=0

for PH_i in {2..6}
do
	printf "%8s%s\n" "" "--> Enabling TTY$PH_i"
	$PH_SUDO systemctl enable getty@tty$PH_i >/dev/null 2>&1 && printf "%10s%s\n" "" "OK" || \
			(printf "%10s%s\n" "" "ERROR : Could not enable TTY$PH_i" ; \
				return 1) || return $?
done
$PH_SUDO systemctl daemon-reload >/dev/null 2>&1
return 0
}

function ph_configure_pieh {

typeset PH_ANSWER=""
typeset PH_i=""
typeset PH_k=""
typeset PH_EMUL_SETUP_DIR_INIT=""
typeset PH_EMUL_DIR_INIT=""
typeset -i PH_j=0
typeset -i PH_COUNT=0
typeset -i PH_COLUMNS=`tput cols`

[[ ! -f $PH_FILES_DIR/first_run ]] && printf "%s\n" "- Starting initial configuration of PieHelper" && \
			printf "%2s%s\n" "" "FAILED : PieHelper already in state \"configured\"" && return 1
ph_check_conf_files supp || (printf "%s\n" "- Checking for supported applications configuration file" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
clear
ph_print_bannerline
printf "\n"
printf "%`echo $((PH_COLUMNS/2+12))`s%s\n" "Welcome to PieHelper $PH_VERSION !"
printf "\n"
ph_print_bannerline
[[ -z "$PH_RUN_USER" ]] && export PH_RUN_USER=`whoami`
printf "\n"
printf "%s" "-"
ph_getstate_pieh | tail -2 | head -1 | cut -c2-
printf "%2s%s\n\n" "" "Starting initial configuration of PieHelper"
printf "%8s%s\n" "" "--> Detecting run account for PieHelper : \"$PH_RUN_USER\""
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Displaying TTY warning"
printf "%10s%s\n\n" "" "OK"
ph_print_bannerline
printf "\n"
printf "%8s%s\n\n" "" "PieHelper works by changing the default configuration of your TTYs"
printf "%8s%s\n" "" "- If you have already made custom changes to your system's TTY setup you should exit now and remove them before configuring PieHelper"
printf "%10s%s\n" "" "Any custom packaged applications you want to autostart can later be integrated into PieHelper"
printf "%8s%s\n\n" "" "- If you have no custom TTY setups or have no idea what TTYs are, you should be safe"
ph_print_bannerline
printf "\n"
while [[ "$PH_ANSWER" != @(y|n) ]]
do
	[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
	printf "%8s%s" "" "--> Continue configuring PieHelper (\"$PH_RUN_USER\" will become the obligatory run account for all PieHelper tools) (y/n) ? "
	read PH_ANSWER 2>/dev/null
	ph_screen_input $PH_ANSWER || return $?
	((PH_COUNT++))
done
[[ "$PH_ANSWER" == "n" ]] && printf "%10s%s\n" "" "OK" && printf "%2s%s\n" "" "USER ABORTED" && return 1
printf "%10s%s\n" "" "OK" && printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Checking prerequisites"
if [[ "$PH_RUN_USER" != "root" ]]
then
	printf "%8s%s\n" "" "--> Checking for sudo rights for user \"$PH_RUN_USER\""
	if [[ -n "$PH_SUDO" ]]
	then
		printf "%10s%s\n" "" "OK"
		printf "%8s%s\n" "" "--> Adding additional secondary groups for user \"$PH_RUN_USER\""
		$PH_SUDO usermod -G tty,audio,video,input "$PH_RUN_USER" >/dev/null 2>&1 || (printf "%10s%s\n" "" "ERROR : Could not add additional secondary groups for $PH_RUN_USER" ; \
					printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
		printf "%10s%s\n" "" "OK"
	else
		printf "%10s%s\n" "" "ERROR : PieHelper needs administrative rights to function"
		printf "%18s%s\n" "" "You can either run PieHelper directly as root or"
		printf "%18s%s\n" "" "manually install and configure sudo for user \"$PH_RUN_USER\""
		printf "%2s%s\n" "" "FAILED"
		return 1
	fi
fi
printf "%8s%s\n" "" "--> Checking location"
[[ `ls -d $PH_SCRIPTS_DIR/../../PieHelper 2>/dev/null` == *PieHelper ]] && \
	($PH_SUDO chmod -R 750 $PH_SCRIPTS_DIR/../../PieHelper ; $PH_SUDO chown -R $PH_RUN_USER:`$PH_SUDO id -gn $PH_RUN_USER` $PH_SCRIPTS_DIR/../../PieHelper) || \
	(printf "%10s%s\n" "" "PieHelper should be not be stored outside it's default directory 'PieHelper'" ; printf "%2s%s\n" "" "FAILED" ; return 1) || exit $?
printf "%10s%s\n" "" "OK"
printf "%8s%s\n" "" "--> Creating supported applications configuration file"
cat >$PH_CONF_DIR/supported_apps <<EOF
PieHelper	$PH_SCRIPTS_DIR/startpieh.sh
Bash	/bin/bash
Moonlight	/usr/local/bin/moonlight stream
Kodi	/usr/bin/xinit /usr/bin/kodi-standalone -- :0 -nolisten tcp vtPH_TTY
X11	/usr/bin/startx -- :1 vtPH_TTY
Emulationstation	/usr/bin/emulationstation
EOF
printf "%10s%s\n" "" "OK"
ph_set_pieh_logind_conf || (printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
ph_set_pieh_tty_states || (ph_set_default_logind_conf ; printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
printf "%8s%s\n" "" "--> Updating package index (This may take a while)"
$PH_SUDO apt-get update >/dev/null 2>&1
[[ $? -eq 0 ]] && printf "%10s%s\n" "" "OK" || (ph_set_default_tty_states ; ph_set_default_logind_conf ; \
			printf "%10s%s\n" "" "ERROR : Issues encountered during index update" ; printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
for PH_i in sudo acl xboxdrv git make bluez bluez-tools lsb-release expect $PH_MOON_PKGS
do
	printf "%8s%s\n" "" "--> Installing required package $PH_i"
	if ! ph_get_pkg_inststate "$PH_i"
	then
		ph_install_pkg "$PH_i" && printf "%10s%s\n" "" "OK" || (printf "%10s%s\n" "" "ERROR : Could not install required package $PH_i" ; \
								ph_set_default_tty_states ; ph_set_default_logind_conf ; \
								printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
	else
		printf "%10s%s\n" "" "OK (Already installed)"
	fi
done
## check if following needed and implement error handling
$PH_SUDO rmmod xpad 2>/dev/null
echo "blacklist xpad" >/tmp/xboxdrv-blacklist.conf_tmp
$PH_SUDO mv /tmp/xboxdrv-blacklist.conf_tmp /etc/modprobe.d/xboxdrv-blacklist.conf
$PH_SUDO modprobe uinput 2>/dev/null
$PH_SUDO modprobe joydev 2>/dev/null
printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Managing pre-existing configurations"
printf "%8s%s\n" "" "--> Checking for Emulationstation"
if [[ -f /usr/bin/emulationstation ]]
then
	printf "%10s%s\n" "" "OK (Found)"
	printf "%8s%s\n" "" "--> Attempting to determine Emulationstation base directory"
	if [[ -f /etc/profile.d/10-retropie.sh ]]
	then
		PH_EMUL_DIR_INIT=`nawk -F'"' '$1 ~ /bash/ { print $2 }' /etc/profile.d/10-retropie.sh 2>/dev/null`
		if [[ -n "$PH_EMUL_DIR_INIT" ]]
		then
			PH_EMUL_DIR_INIT=${PH_EMUL_DIR_INIT%%/configs*}
			printf "%10s%s\n" "" "OK"
			ph_move_emul_conf
		fi
	else
		[[ -d /opt/retropie ]] && PH_EMUL_DIR_INIT="/opt/retropie" && printf "%10s%s\n" "" "OK"
	fi
	if [[ -z "$PH_EMUL_DIR_INIT" ]]
	then
		printf "%10s%s\n" "" "Warning : Could not determine Emulationstation base directory"
		ph_set_default_tty_states
		ph_set_default_logind_conf
		ph_restore_emul_conf
		printf "%2s%s\n" "" "FAILED"
		return 1
	fi
	ph_set_option Emulationstation -r PH_EMUL_DIR="$PH_EMUL_DIR_INIT" || (ph_set_default_tty_states ; \
			ph_set_default_logind_conf ; ph_restore_emul_conf ; printf "%2s%s\n" "" "FAILED" ; \
			return 1) || return $?
	printf "%8s%s\n" "" "--> Attempting to determine Emulationstation setup directory (This may take a while)"
	PH_EMUL_SETUP_DIR_INIT=`$PH_SUDO find / -type d ! -fstype nfs -name RetroPie 2>/dev/null`
	if [[ -n "$PH_EMUL_SETUP_DIR_INIT" ]]
	then
		printf "%10s%s\n" "" "OK"
		ph_set_option Emulationstation -r PH_EMUL_SETUP_DIR="$PH_EMUL_SETUP_DIR_INIT" || \
			(ph_set_option Emulationstation -r PH_EMUL_DIR='' ; ph_set_default_tty_states ; \
			 ph_set_default_logind_conf ; ph_restore_emul_conf ; printf "%2s%s\n" "" "FAILED" ; \
			 return 1) || return $?
	else
		printf "%10s%s\n" "" "ERROR : Could not determine Emulationstation setup directory"
		ph_set_option Emulationstation -r PH_EMUL_DIR=''
		ph_set_default_tty_states
		ph_set_default_logind_conf
		ph_restore_emul_conf
		printf "%2s%s\n" "" "FAILED"
		return 1
	fi
else
	printf "%10s%s\n" "" "OK (Not found)"
fi
printf "%2s%s\n" "" "SUCCESS"
if [[ ! -f /etc/profile.d/PieHelper-path.sh ]]
then
	printf "%s\n" "- Installing PieHelper PATH extension"
	echo "export PATH=/usr/local/bin:$PH_SCRIPTS_DIR:\$PATH" >/tmp/PieHelper-path.sh && \
	($PH_SUDO mv /tmp/PieHelper-path.sh /etc/profile.d/PieHelper-path.sh ; \
	 printf "%2s%s\n" "" "SUCCESS") || \
	printf "%2s%s\n" "" "Warning : Could not install PieHelper PATH extension"
fi
printf "%s\n" "- Creating integrated applications configuration file"
echo -e "PieHelper\t$PH_RUN_USER\tno\t-" >$PH_CONF_DIR/installed_apps
printf "%2s%s\n" "" "SUCCESS"
ph_generate_installed_apps
ph_set_app_for_start PieHelper || (rm $PH_CONF_DIR/installed_apps 2>/dev/null ; $PH_SUDO rm /etc/profile.d/PieHelper-path.sh 2>/dev/null ; \
			ph_set_option Emulationstation -r PH_EMUL_DIR='' -r PH_EMUL_SETUP_DIR='' >/dev/null ; \
			ph_restore_emul_conf >/dev/null ; ph_set_default_tty_states >/dev/null ; ph_set_default_logind_conf >/dev/null ; \
			return 1) || return $?
PH_ANSWER=""
PH_COUNT=0
printf "%s\n" "- Proposing system update"
while [[ "$PH_ANSWER" != @(y|n) ]]
do
	[[ $PH_COUNT -gt 0 ]] && printf "\n%10s%s\n\n" "" "ERROR : Invalid response"
	printf "%8s%s" "" "--> Do you want to perform this update (y/n) ? "
	read PH_ANSWER 2>/dev/null
	ph_screen_input $PH_ANSWER || (ph_set_app_for_start none >/dev/null ; rm $PH_CONF_DIR/installed_apps 2>/dev/null ; $PH_SUDO rm /etc/profile.d/PieHelper-path.sh 2>/dev/null ; \
					ph_set_option Emulationstation -r PH_EMUL_DIR='' -r PH_EMUL_SETUP_DIR='' >/dev/null ; \
					ph_restore_emul_conf >/dev/null ; ph_set_default_tty_states >/dev/null ; ph_set_default_logind_conf >/dev/null ; \
					return 1) || return $?
	((PH_COUNT++))
done
printf "%10s%s\n" "" "OK"
printf "%2s%s\n" "" "SUCCESS"
[[ "$PH_ANSWER" == "y" ]] && ph_update_system
## Test whether problem if this ph_configure_pieh launched from X
printf "%s\n" "- Disabling X"
$PH_SUDO systemctl set-default multi-user.target >/dev/null 2>&1 && printf "%2s%s\n" "" "SUCCESS"
printf "%s\n" "- Displaying usage information"
printf "%8s%s\n" "" "--> Displaying usage info"
printf "%10s%s\n\n" "" "OK"
ph_print_bannerline
printf "\n\n%8s%s\n\n" "" "PieHelper allows easy switching between it's integrated applications"
printf "%8s%s\n" "" "- If you're connected over the network you can use the CLI tools available in $PH_SCRIPTS_DIR"
printf "%8s%s\n" "" "- If you're connected directly you can use the linux built-in keycombo of Ctrl-LeftAlt-Functionkey%TTY"
printf "%10s%s\n\n" "" "For direct control with a mouse and keyboard, the following notes apply : "
printf "%12s%s\n" "" "- Any applications that do not render to the default frame buffer need to be quit first before switching TTYs if"
printf "%14s%s\n" "" "the application that is being switched to is marked as persistent"
printf "%14s%s\n" "" "Neither should these types of applications be marked as persistent themselves"
printf "%14s%s\n" "" "Examples are Moonlight, Kodi and Emulationstation"
printf "%12s%s\n" "" "- Any application that intercepts and interprets the keycombo for TTY switching itself always have to be quit before switching TTYs"
printf "%14s%s\n" "" "Examples are Moonlight and Kodi"
printf "\n"
ph_print_bannerline
printf "\n%2s%s\n" "" "SUCCESS"
rm $PH_FILES_DIR/first_run 2>/dev/null
printf "\n%s" "Press Enter to reboot and continue"
read 2>/dev/null
$PH_SUDO init 6
return 0
}

function ph_run_app_action {

typeset PH_RUNAPP="$2"
typeset PH_i=""
typeset PH_BASH_TTY=""
typeset PH_KODI_HOME=""
typeset PH_KODI_USER=""
typeset -l PH_RUNAPPL=""
typeset -u PH_RUNAPPU=""
typeset -i PH_RUNAPP_TTY=0
typeset -i PH_PIEH_TTY=0
typeset -i PH_CTRL_COUNT=0

ph_check_conf_files supp || (printf "%8s%s\n" "" "--> Checking for supported applications configuration file" ; \
			printf "%10s%s\n" "" "ERROR : Not found" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
ph_check_conf_files cont || (printf "%8s%s\n" "" "--> Checking for controller CLI ids' configuration file" ; \
			printf "%10s%s\n" "" "ERROR : Not found" ; \
			printf "%2s%s\n" "" "FAILED" ; return 1) || return $?
PH_RUNAPPU=`echo "$PH_RUNAPP" | cut -c1-4`
PH_RUNAPPL=`echo "$PH_RUNAPP" | cut -c1-4`

PH_PIEH_TTY=`ph_get_tty_for_app PieHelper`
case $1 in start)
	PH_RUNAPP_TTY=`ph_get_tty_for_app $PH_RUNAPP`
	printf "%8s%s\n" "" "--> Attempting to determine required remote mounts for $PH_RUNAPP"
	if ([[ `eval echo "\\$PH_$PH_RUNAPPU"_CIFS_SHARE` == @(no|) ]] || [[ "$PH_RUNAPP" == "PieHelper" ]])
	then
		printf "%10s%s\n" "" "OK (None)"
	else
		printf "%10s%s\n" "" "OK"
		printf "%8s%s\n" "" "--> Checking for mount"
		mount | nawk -v rempath=^"//`eval echo \\$PH_\"$PH_RUNAPPU\"_CIFS_SRV``eval echo \\$PH_\"$PH_RUNAPPU\"_CIFS_DIR``eval echo \\$PH_\"$PH_RUNAPPU\"_CIFS_SUBDIR`"$ -F' on ' '$1 ~ rempath { exit 1 }'
		if [[ $? -eq 0 ]]
		then
			printf "%10s%s\n" "" "OK (Not found)"
			ph_mount_cifs_share "$PH_RUNAPP" || return 1
		else
			printf "%10s%s\n" "" "OK (found)"
		fi
		if [[ "$PH_RUNAPP" == "Kodi" && `$PH_SUDO fgconsole` -eq $PH_RUNAPP_TTY ]]
		then
			PH_KODI_USER="`nawk -v app=^"Kodi"$ '$1 ~ app { print $2 }' $PH_CONF_DIR/installed_apps`"
			PH_KODI_HOME="`echo -n $(getent passwd $PH_KODI_USER | cut -d':' -f6)`"
			printf "%8s%s\n" "" "--> Restoring last backup of Kodi preferences directory for run account $PH_KODI_USER (This may take a while)"
			cd "$PH_KODI_HOME" >/dev/null 2>&1
			if [[ -f `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar ]]
			then
				$PH_SUDO mv `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" >/dev/null 2>&1
				[[ -d "$PH_KODI_HOME/.kodi" ]] && $PH_SUDO rm -r "$PH_KODI_HOME/.kodi" 2>/dev/null
				$PH_SUDO tar -xf "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" 2>/dev/null
				if [[ $? -ne 0 ]]
				then
					printf "%10s%s\n" "" "Warning : Could not succesfully restore last preferences backup -> Removing"
					$PH_SUDO rm -r "$PH_KODI_HOME/.kodi" 2>/dev/null
					PH_i=NOK
				else
					[[ `ls -ld "$PH_KODI_HOME/.kodi" | nawk '{ print $3 }'` != "$PH_KODI_USER" ]] && $PH_SUDO chown -R "$PH_KODI_USER":`$PH_SUDO id -gn $PH_KODI_USER` ./.kodi >/dev/null 2>&1
					printf "%10s%s\n" "" "OK"
				fi
				$PH_SUDO mv "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar >/dev/null 2>&1
			else
				printf "%10s%s\n" "" "Warning : Not found"
			fi
			cd - >/dev/null 2>&1
		fi
	fi
	typeset -n PH_RUNAPPU_CMD_OPTS=PH_"$PH_RUNAPPU"_CMD_OPTS
	printf "%8s%s\n" "" "--> Checking for controller usage"
	if [[ `eval echo "\\$PH_$PH_RUNAPPU"_USE_CTRL` == @(no|) ]]
	then
		printf "%10s%s\n" "" "OK (No)"
	else
		printf "%10s%s\n" "" "OK (Yes)"
		typeset -n PH_RUNAPPU_NUM_CTRL=PH_"$PH_RUNAPPU"_NUM_CTRL
		ph_setup_controllers $PH_RUNAPPU_NUM_CTRL || return $?
		PH_CTRL_COUNT=`cat $PH_CONF_DIR/controller_cli_ids | wc -l`
		for PH_i in {1..$PH_RUNAPPU_NUM_CTRL}
		do
			printf "%8s%s\n" "" "--> Retrieving event id for $PH_CTRL_TYPE controller with CLI id $PH_i"
			if [[ "$PH_CTRL_MAP" == "no" ]]
			then
				eval typeset -i "PH_EVENT"$PH_i=`ph_get_controller_cli_id $PH_i`
			else
				eval typeset -i "PH_EVENT"$PH_i=`ph_get_controller_cli_id $((PH_i+$(echo $((PH_CTRL_COUNT-`echo $PH_RUNAPPU_NUM_CTRL`)))))`
			fi
			typeset -n PH_EVENT="PH_EVENT"$PH_i
			printf "%10s%s\n" "" "OK"
			printf "%8s%s\n" "" "--> Checking for event-based input device $PH_i in command-line options"
			if echo "$PH_RUNAPPU_CMD_OPTS" | egrep -e "PH_CTRL$PH_i$|PH_CTRL$PH_i " >/dev/null
			then
				printf "%10s%s\n" "" "OK (Found)"
				printf "%8s%s\n" "" "--> Assigning event id $PH_EVENT to input device with CLI id $PH_i in command-line options"
				PH_RUNAPPU_CMD_OPTS="$(eval echo `sed 's/PH_CTRL'$PH_i'/'$PH_EVENT'/g;s/"/\\\"/g' <<<$PH_RUNAPPU_CMD_OPTS`)"
				printf "%10s%s\n" "" "OK"
			else
				printf "%10s%s\n" "" "OK (Not found)"
			fi
			unset -n PH_EVENT
		done
	fi
	PH_RUNAPP_CMD=`nawk -v runapp=^"$PH_RUNAPP"$ 'BEGIN { ORS=" " } $1 ~ runapp { for (i=2;i<=NF;i++) { if (i==NF) { ORS="" ; print $i } else { print $i }}}' $PH_CONF_DIR/supported_apps`
	PH_RUNAPP_CMD=`sed "s/PH_TTY/$PH_RUNAPP_TTY/" <<<$PH_RUNAPP_CMD`
	if [[ `$PH_SUDO fgconsole` -ne $PH_RUNAPP_TTY ]]
	then
		if systemctl list-units -t service | nawk '{ print $1 }' | grep ^"getty@tty$PH_RUNAPP_TTY.service"$ >/dev/null
		then
			if ! pgrep -t tty$PH_RUNAPP_TTY -f "$PH_RUNAPP_CMD" >/dev/null 2>&1
			then
				$PH_SUDO systemctl stop "getty@tty$PH_RUNAPP_TTY" >/dev/null 2>&1
			fi
		fi
	fi
	[[ "$PH_RUNAPP" == "PieHelper" ]] && PH_RUNAPP_CMD="ph_show_menu"
	printf "%8s%s\n" "" "--> Starting $PH_RUNAPP"
	$PH_SUDO systemctl start getty@tty$PH_RUNAPP_TTY >/dev/null 2>&1
	if [[ `$PH_SUDO fgconsole` -eq $PH_RUNAPP_TTY && "$PH_RUNAPP" != "PieHelper" ]]
	then
		$PH_SUDO systemctl stop getty@tty$PH_PIEH_TTY >/dev/null 2>&1
	fi
	if [[ `$PH_SUDO fgconsole` -eq $PH_RUNAPP_TTY && "$PH_RUNAPP_CMD" != "/bin/bash" ]]
	then
		eval "$PH_RUNAPP_CMD $PH_RUNAPPU_CMD_OPTS"
	else
		$PH_SUDO `which chvt` $PH_RUNAPP_TTY
	fi
	[[ $? -ne 0 ]] && unset -n PH_RUNAPPU_CMD_OPTS PH_RUNAPPU_NUM_CTRL && printf "%10s%s\n" "" "ERROR : Could not start $PH_RUNAPP" && return 1
	unset -n PH_RUNAPPU_CMD_OPTS PH_RUNAPPU_NUM_CTRL
	(([[ "$PH_RUNAPP" == "PieHelper" ]]) && ([[ `tty` == /dev/tty* ]])) && exit 0
	printf "%10s%s\n" "" "OK"
	if [[ "$PH_RUNAPP" == "Bash" ]]
	then
		printf "%2s%s\n" "" "SUCCESS"
		PH_BASH_TTY=`tty`
		[[ $PH_RUNAPP_TTY -eq ${PH_BASH_TTY##+([^[:digit:]])} ]] && clear
	fi ;;
	       *)
	printf "%8s%s\n" "" "--> Stopping $PH_RUNAPP"
	if [[ `eval echo "\\$PH_\$PH_RUNAPPU"_PERSISTENT` == "yes" && -z "$3" ]]
	then
		printf "%10s%s\n" "" "Warning : $PH_RUNAPP is marked persistent -> Staying online" && return 0
	fi
	PH_RUNAPP_TTY=`ph_get_tty_for_app $PH_RUNAPP`
	if [[ `$PH_SUDO fgconsole` -eq $PH_RUNAPP_TTY && "$PH_RUNAPP" != "PieHelper" ]]
	then
		pgrep -t tty$PH_PIEH_TTY -f "startpieh.sh" >/dev/null && $PH_SUDO `which chvt` $PH_PIEH_TTY || \
										$PH_SUDO `which chvt` 1
	else
		[[ "$PH_RUNAPP" == "PieHelper" && `$PH_SUDO fgconsole` -eq $PH_RUNAPP_TTY ]] && $PH_SUDO `which chvt` 1
	fi
	printf "%10s%s\n" "" "OK"
	$PH_SUDO systemctl stop getty@tty$PH_RUNAPP_TTY >/dev/null 2>&1
	[[ $? -ne 0 ]] && printf "%10s%s\n" "" "ERROR : Could not stop $PH_RUNAPP" && return 1
	printf "%8s%s\n" "" "--> Attempting to determine mounted shares for $PH_RUNAPP"
	if ([[ `eval echo "\\$PH_$PH_RUNAPPU"_CIFS_SHARE` == @(no|) ]] || [[ "$PH_RUNAPP" == "PieHelper" ]])
	then
		printf "%10s%s\n" "" "OK (Not found)"
	else
		printf "%10s%s\n" "" "OK (Found)"
		if [[ "$PH_RUNAPP" == "Kodi" ]]
		then
			PH_KODI_USER="`nawk -v app=^"Kodi"$ '$1 ~ app { print $2 }' $PH_CONF_DIR/installed_apps`"
			PH_KODI_HOME="`echo -n $(getent passwd $PH_KODI_USER | cut -d':' -f6)`"
			printf "%8s%s\n" "" "--> Backing up latest Kodi preferences directory for run account $PH_KODI_USER (This may take a while)"
			cd "$PH_KODI_HOME" >/dev/null 2>&1
			[[ -f `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar && -d "$PH_KODI_HOME/.kodi" ]] && $PH_SUDO rm `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar 
			$PH_SUDO tar -X "$PH_FILES_DIR/exclude.Kodi" -cf "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" ./.kodi 2>/dev/null || PH_i="NOK"
			if [[ "$PH_i" != "NOK" ]]
			then
				printf "%10s%s\n" "" "OK"
				$PH_SUDO mv "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" `eval echo -n "$PH_KODI_CIFS_MPT"`/Kodi-Prefs.tar >/dev/null 2>&1
			else
				printf "%10s%s\n" "" "Warning : Could not create valid up-to-date preferences backup -> Removing"
				$PH_SUDO rm "$PH_SCRIPTS_DIR/../tmp/Kodi-Prefs.tar" 2>/dev/null
			fi
			cd - >/dev/null 2>&1
		fi
		ph_umount_cifs_share "$PH_RUNAPP"
	fi
	if [[ `eval echo "\\$PH_$PH_RUNAPPU"_USE_CTRL` == "yes" ]]
	then
		printf "%8s%s\n" "" "--> Displaying reminder"
		printf "%10s%s\n" "" "OK"
		printf "\n"
		ph_print_bannerline
		printf "\n"
		printf "%8s%s\n" "" "Important : Do not forget to turn off your controllers !"
		printf "\n"
		ph_print_bannerline
		printf "\n"
		sleep 5
		ph_cleanup_controllers full || (printf "%2s%s\n" "" "PARTIALLY FAILED" ; return 3) || return $?
	fi
esac
return 0
}
