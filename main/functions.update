# PieHelper module declarations shared with the update process (By Davy Keppens on 27/06/19)
# Toggle debugstate of a specific module between Enable/Disable by running 'confpieh_ph.sh -p debug -m module_name'

function ph_clean_tmp_dir {

declare PH_i=""

[[ "$#" -gt "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in $("$PH_SUDO" ls -lA "${PH_TMP_DIR}/" 2>/dev/null | nawk 'NR == "1" { \
                next \
        } \
        $NF !~ /^\.(gitignore|(un|)configure_in_progress|first_run)/ { \
                printf " " $NF \
        }')
do
        ! "$PH_SUDO" rm "${PH_TMP_DIR}/${PH_i}" >/dev/null 2>&1 && \
                ph_set_result -a -m "Could not clean temporary directory (Error trying to remove '${PH_TMP_DIR}/${PH_i}')"
done
return 0
}

function ph_remove_empty_file {

declare PH_OPTION=""
declare PH_PARAMS=""
declare PH_FILE_DEST=""
declare PH_FILE_TYPE=""
declare PH_FILE_SOURCE=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"
declare -i PH_REMOVE_AS_ROOT="1"

OPTIND="1"

while getopts d:t:qr PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in d)
		[[ -n "$PH_FILE_DEST" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_DEST="$OPTARG" ;;
                             t)
		[[ -n "$PH_FILE_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_TYPE="$OPTARG" ;;
                             q)
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-q" || \
			PH_PARAMS="${PH_PARAMS} -q"
		PH_QUIESCE="0" ;;
                             r)
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_REMOVE_AS_ROOT="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE_DEST" || -z "$PH_FILE_TYPE" || \
	( "$PH_FILE_TYPE" == "link" && ! -L "$PH_FILE_DEST" ) || \
	( "$PH_FILE_TYPE" == "directory" && ! -d "$PH_FILE_DEST" ) || \
	( "$PH_FILE_TYPE" == "file" && ( ! -f "$PH_FILE_DEST" || -L "$PH_FILE_DEST" || -s "$PH_FILE_DEST" )) || \
	"$#" -lt "4" || "$#" -gt "6" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_QUIESCE" -eq "1" ]] && \
        printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_FILE_TYPE} " "'${PH_FILE_DEST}'"
if [[ ! -e "$PH_FILE_DEST" ]]
then
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c true -m "Nothing to do"
	return 0
fi
case "$PH_FILE_TYPE" in link)
	PH_FILE_SOURCE="$(ph_get_link_target "$PH_FILE_DEST")"
        [[ "$PH_FILE_SOURCE" != /* ]] && \
                PH_FILE_SOURCE="${PH_FILE_DEST%/*}/${PH_FILE_SOURCE}"
        if [[ "$PH_REMOVE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" unlink "$PH_FILE_DEST" 2>/dev/null
        else
                unlink "$PH_FILE_DEST" 2>/dev/null
        fi ;;
                        directory)
        PH_FILE_SOURCE="$PH_FILE_DEST"
        if [[ "$PH_REMOVE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" rm -r "$PH_FILE_DEST" 2>/dev/null
        else
                rm -r "$PH_FILE_DEST" 2>/dev/null
        fi ;;
                        file)
        PH_FILE_SOURCE="$PH_FILE_DEST"
        if [[ "$PH_REMOVE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" rm "$PH_FILE_DEST" 2>/dev/null
        else
                rm "$PH_FILE_DEST" 2>/dev/null
        fi ;;
esac
if [[ "$?" -eq "0" ]]
then
        ph_add_value_to_param -p PH_CREATE_EMPTY_FILES -v "${PH_FILE_DEST}'${PH_FILE_TYPE}'${PH_FILE_SOURCE}'${PH_PARAMS}"
        [[ "$PH_QUIESCE" -eq "1" ]] && \
                ph_run_with_rollback -c true
        return 0
else
	ph_set_result -m "An error occurred trying to remove ${PH_FILE_TYPE} '${PH_FILE_DEST}'"
        [[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c false -m "Could not remove"
        return 1
fi
}

function ph_create_empty_file {

declare PH_OPTION=""
declare PH_PARAMS=""
declare PH_FILE_DEST=""
declare PH_FILE_SOURCE=""
declare PH_FILE_TYPE=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"
declare -i PH_CREATE_AS_ROOT="1"

OPTIND="1"

while getopts d:s:t:qr PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in d)
		[[ -n "$PH_FILE_DEST" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_DEST="$OPTARG" ;;
                            s)
		[[ -n "$PH_FILE_SOURCE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_SOURCE="$OPTARG" ;;
                            t)
		[[ -n "$PH_FILE_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_TYPE="$OPTARG" ;;
                            q)
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-q" || \
			PH_PARAMS="${PH_PARAMS} -q"
		PH_QUIESCE="0" ;;
                            r)
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_CREATE_AS_ROOT="0" ;;
			    *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE_DEST" || -z "$PH_FILE_TYPE" || ( "$PH_FILE_TYPE" == "link" && -z "$PH_FILE_SOURCE" ) || \
	( -e "$PH_FILE_DEST" && (( "$PH_FILE_TYPE" == "directory" && ! -d "$PH_FILE_DEST" ) || 
	( "$PH_FILE_TYPE" == "link" && ! -L "$PH_FILE_DEST" ) || \
	( "$PH_FILE_TYPE" == "file" && ( ! -f "$PH_FILE_DEST" || -L "$PH_FILE_DEST" )))) || \
	"$#" -lt "4" || "$#" -gt "8" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_QUIESCE" -eq "1" ]] && \
        printf "%8s%s\033[32m%s\033[0m" "" "--> Creating ${PH_FILE_TYPE} " "'${PH_FILE_DEST}'"
if [[ ( "$PH_FILE_TYPE" == "link" && -e "$PH_FILE_DEST" && "$PH_FILE_SOURCE" == "$(ph_get_link_target "$PH_FILE_DEST")" ) || \
	( "$PH_FILE_TYPE" == @(directory|file) && -e "$PH_FILE_DEST" ) ]]
then
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		printf "\n" && \
		ph_run_with_rollback -c true -m "Nothing to do"
	return 0
fi
case "$PH_FILE_TYPE" in link)
	[[ "$PH_QUIESCE" -eq "1" ]] && \
        	printf "%s\n" " to '${PH_FILE_SOURCE}'"
        if [[ "$PH_CREATE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" ln -s "$PH_FILE_SOURCE" "$PH_FILE_DEST" 2>/dev/null
        else
                ln -s "$PH_FILE_SOURCE" "$PH_FILE_DEST" 2>/dev/null
        fi ;;
                        directory)
        [[ "$PH_QUIESCE" -eq "1" ]] && \
                printf "\n"
        if [[ "$PH_CREATE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" mkdir -p "$PH_FILE_DEST" 2>/dev/null
        else
                mkdir -p "$PH_FILE_DEST" 2>/dev/null
        fi ;;
                        file)
        [[ "$PH_QUIESCE" -eq "1" ]] && \
                printf "\n"
        if [[ "$PH_CREATE_AS_ROOT" -eq "0" ]]
        then
                "$PH_SUDO" touch "$PH_FILE_DEST" 2>/dev/null
        else
                touch "$PH_FILE_DEST" 2>/dev/null
        fi ;;
esac
if [[ "$?" -eq "0" ]]
then
        ph_add_value_to_param -p PH_REMOVE_EMPTY_FILES -v "${PH_FILE_DEST}'${PH_FILE_TYPE}'${PH_PARAMS}"
        [[ "$PH_QUIESCE" -eq "1" ]] && \
                ph_run_with_rollback -c true
        return 0
else
	if [[ "$PH_FILE_TYPE" == "link" ]]
	then
		ph_set_result -m "An error occurred creating ${PH_FILE_TYPE} '${PH_FILE_DEST}' to '${PH_FILE_SOURCE}'"
	else
		ph_set_result -m "An error occurred creating ${PH_FILE_TYPE} '${PH_FILE_DEST}'"
	fi
        [[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c false -m "Could not create"
        return 1
fi
}

function ph_initialize_rollback {

[[ "$#" -gt "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_ROLLBACK_USED="no"
PH_OLD_GIT_COMMIT_MSG=""
PH_OLD_VERSION=""
PH_RESULT="SUCCESS"
PH_TOTAL_RESULT="SUCCESS"
PH_RESULT_TYPE_USED="Normal"
PH_SCRIPT_FLAG="1"
PH_RESULT_COUNT="0"
PH_TOTAL_RESULT_COUNT="0"
PH_ROLLBACK_DEPTH="0"
return 0
}

function ph_reset_result {

declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"
PH_RESULT_TYPE_USED="Normal"

while getopts t PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in t)
		[[ -n "$PH_RESULT_TYPE_USED" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_RESULT_TYPE_USED="Total" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ "$#" -gt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_RESULT_TYPE_USED" == "Total" ]]
then
        PH_TOTAL_RESULT="SUCCESS"
        PH_TOTAL_RESULT_COUNT="0"
else
        PH_RESULT="SUCCESS"
        PH_RESULT_COUNT="0"
fi
PH_RESULT_TYPE_USED="Normal"
return 0
}

function ph_set_result {

declare PH_OPTION=""
declare PH_FIRST=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RET_CODE="0"
declare -i PH_RET_CODE_RECVD_FLAG="1"
declare -i PH_RECVD_FLAG="1"

OPTIND="1"
PH_RESULT_TYPE_USED="Normal"

while getopts r:m:taw PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in r)
		[[ "$PH_RET_CODE_RECVD_FLAG" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_RET_CODE_RECVD_FLAG="0"
		PH_RET_CODE="$OPTARG" ;;
			     m)
		PH_RECVD_FLAG="0"
		PH_RESULT_MSG="$OPTARG" ;;
			     a)
		PH_RECVD_FLAG="0"
		PH_RESULT="Abort"
		PH_RESULT_TYPE_USED="$PH_RESULT" ;;
			     w)
		PH_RECVD_FLAG="0"
		PH_RESULT="Warning"
		PH_RESULT_TYPE_USED="$PH_RESULT" ;;
			     t)
		PH_RESULT_TYPE_USED="Total" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		>&2 printf "\n%2s\033[31m%s\033[0m\n\n" "" "ABORT : Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" 
		exit 1 ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( "$PH_RET_CODE_RECVD_FLAG" -eq "1" && "$PH_RECVD_FLAG" -eq "1" )  || "$#" -gt "6" ]] && \
        >&2 printf "\n%2s\033[31m%s\033[0m\n\n" "" "ABORT : Incorrect arguments provided to function '${FUNCNAME[0]}'" && \
	exit 1

case "$PH_RESULT_TYPE_USED" in Warning|Abort|Normal)
		declare -n PH_RESULT_TYPE="PH_RESULT" ;;
			       Total)
		declare -n PH_RESULT_TYPE="PH_TOTAL_RESULT" ;;
esac
if [[ "$PH_RET_CODE_RECVD_FLAG" -eq "0" ]]
then
	if [[ "$PH_RESULT_TYPE_USED" == "Total" ]]
	then
		[[ "$PH_TOTAL_RESULT_COUNT" -eq "0" ]] && \
			PH_FIRST="yes"
		((PH_TOTAL_RESULT_COUNT++))
	else
		[[ "$PH_RESULT_COUNT" -eq "0" ]] && \
			PH_FIRST="yes"
		((PH_RESULT_COUNT++))
	fi
	case "$PH_RET_CODE" in 0)
		[[ "$PH_RESULT_TYPE" == "FAILED" ]] && \
			PH_RESULT_TYPE="PARTIALLY FAILED" ;;
			       *)
		if [[ "$PH_FIRST" == "yes" ]]
		then
			[[ "$PH_RESULT_TYPE" == @(SUCCESS|Warning) ]] && \
				PH_RESULT_TYPE="FAILED"
		else
			[[ "$PH_RESULT_TYPE" == @(SUCCESS|Warning) ]] && \
				PH_RESULT_TYPE="PARTIALLY FAILED"
		fi ;;
	esac
fi
PH_RESULT_TYPE_USED="Normal"
unset -n PH_RESULT_TYPE
if [[ "$PH_RESULT" == "Abort" ]]
then
	ph_clean_tmp_dir
	ph_show_result
	exit 1
fi
return 0
}

function ph_show_result {

declare PH_OPTION=""
declare PH_RESULT_PREFIX="Result > "
declare PH_RESULT_SUFFIX=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RESULT_INDENT="0"

OPTIND="1"

while getopts i:t PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in i)
		[[ "$PH_RESULT_INDENT" -gt "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_RESULT_INDENT="$OPTARG" ;;
                             t)
                PH_RESULT_TYPE_USED="Total" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		>&2 printf "\n%2s\033[31m%s\033[0m\n\n" "" "ABORT : Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" 
		exit 1 ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ "$#" -gt "3" ]] && \
        >&2 printf "\n%2s\033[31m%s\033[0m\n\n" "" "ABORT : Incorrect arguments provided to function '${FUNCNAME[0]}'" && \
	exit 1

if [[ "$PH_RESULT_TYPE_USED" == @(Warning|Abort|Normal) ]]
then
	declare -n PH_RESULT_TYPE="PH_RESULT"
else
	PH_RESULT_PREFIX="##### Total Result > "
	declare -n PH_RESULT_TYPE="PH_TOTAL_RESULT"
fi
[[ "$PH_RESULT_INDENT" -eq "0" ]] && \
	PH_RESULT_INDENT="2"
if [[ -n "$PH_RESULT_MSG" ]]
then
	PH_RESULT_SUFFIX=" : ${PH_RESULT_MSG}"
fi
case "$PH_RESULT_TYPE" in Warning)
	printf "\n%${PH_RESULT_INDENT}s\033[36m%s\033[33m%s%s\033[0m\n\n" "" "$PH_RESULT_PREFIX" "$PH_RESULT_TYPE" "$PH_RESULT_SUFFIX" ;;
			  SUCCESS)
	printf "\n%${PH_RESULT_INDENT}s\033[36m%s\033[32m%s%s\033[0m\n\n" "" "$PH_RESULT_PREFIX" "$PH_RESULT_TYPE" "$PH_RESULT_SUFFIX" ;;
			  *)
	>&2 printf "\n%${PH_RESULT_INDENT}s\033[36m%s\033[31m%s%s\033[0m\n\n" "" "$PH_RESULT_PREFIX" "$PH_RESULT_TYPE" "$PH_RESULT_SUFFIX" ;;
esac
PH_RESULT_MSG=""
unset -n PH_RESULT_TYPE
if [[ "$PH_RESULT_TYPE_USED" == "Total" ]]
then
	if [[ "$PH_TOTAL_RESULT" == "SUCCESS" ]]
	then
		ph_reset_result -t
		return 0
	else
		ph_reset_result -t
		return 1
	fi
else
	if [[ "$PH_RESULT" == @(SUCCESS|Warning) ]]
	then
		ph_reset_result
		return 0
	else
		ph_reset_result
		return 1
	fi
fi
}

function ph_add_value_to_param {

declare PH_PARAM_USED=""
declare PH_VALUE=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts p:v: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in p)
		[[ -n "$PH_PARAM_USED" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAM_USED="$OPTARG" ;;
			     v)
		[[ -n "$PH_VALUE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_VALUE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ "$#" -ne "4" || -z "$PH_PARAM_USED" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_ROLLBACK_USED" == "no" ]] && \
	return 0
eval "$PH_PARAM_USED"+=\("\"\$PH_VALUE\""\)
PH_DEPTH_PARAMS+=("$PH_PARAM_USED")
PH_DEPTH+=("$PH_ROLLBACK_DEPTH")
return 0
}

function ph_get_move_scripts_regex {

declare PH_APP=""
declare PH_APP2=""
declare PH_MOVE_SCRIPTS_REGEX=""
declare -l PH_APPL=""
declare -l PH_APPL2=""

[[ "$#" -gt "0" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		printf $1 \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
do
	PH_APPL="${PH_APP:0:4}"
	for PH_APP2 in $(nawk -v app=^"${PH_APP}"$ 'BEGIN { \
			ORS = " " \
		} \
		$1 !~ app { \
			printf $1 \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
	do
		PH_APPL2="${PH_APP2:0:4}"
		[[ -z "$PH_MOVE_SCRIPTS_REGEX" ]] && \
			PH_MOVE_SCRIPTS_REGEX="|${PH_APPL}to${PH_APPL2}" || \
			PH_MOVE_SCRIPTS_REGEX="${PH_MOVE_SCRIPTS_REGEX}|${PH_APPL}to${PH_APPL2}"
	done
done
echo -n "$PH_MOVE_SCRIPTS_REGEX"
return 0
}

function ph_run_with_rollback {

declare PH_CMD=""
declare PH_CMD_MSG=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_ARRAY_INDEX="0"
declare -i PH_RET_CODE="0"
declare -i PH_COUNT="0"

OPTIND="1"

while getopts c:m: PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in c)
		[[ -n "$PH_CMD" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_CMD="$OPTARG" ;;
			     m)
		[[ -n "$PH_CMD_MSG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_CMD_MSG="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_CMD" || ( "$PH_CMD" == "false" && ( -z "$PH_CMD_MSG" || "$#" -ne "4" )) || \
	"$PH_CMD" != @(ph_*|true|false) || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_ROLLBACK_USED" == "yes" ]] && \
	((PH_ROLLBACK_DEPTH++))
eval "$PH_CMD"
PH_RET_CODE="$?"
if [[ "$PH_CMD" == @(true|false) ]]
then
	ph_set_result -r "$PH_RET_CODE"
	if [[ "$PH_CMD" == "true" ]]
	then
		if [[ -z "$PH_CMD_MSG" ]]
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[32m%s\033[0m%s\n" "" "OK : " "$PH_CMD_MSG"
		fi
	else
		>&2 printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "$PH_CMD_MSG"
	fi
fi
if [[ "$PH_ROLLBACK_USED" == "yes" ]]
then
	if [[ "$PH_RET_CODE" -ne "0" ]]
	then
		if [[ "$PH_ROLLBACK_DEPTH" -eq "1" ]]
		then
			ph_show_result
			for PH_ARRAY_INDEX in "${!PH_DEPTH[@]}"
			do
				unset PH_DEPTH[${PH_ARRAY_INDEX}]
			done
			if [[ "${#PH_DEPTH_PARAMS[@]}" -gt "0" ]]
			then
				printf "\033[36m%s\033[0m\n\n" "- Rolling back changes"
				ph_rollback_changes
				exit "$?"
			fi
		fi
	else
		for PH_ARRAY_INDEX in ${!PH_DEPTH[@]}
		do
			if [[ "${PH_DEPTH["${PH_ARRAY_INDEX}"]}" -gt "$PH_ROLLBACK_DEPTH" ]]
			then
				PH_COUNT="0"
				for PH_COMPARE_INDEX in ${!PH_DEPTH_PARAMS[@]}
				do
					[[ "${PH_DEPTH_PARAMS["${PH_COMPARE_INDEX}"]}" == "${PH_DEPTH_PARAMS["${PH_ARRAY_INDEX}"]}" ]] && \
						((PH_COUNT++))
					[[ "$PH_COMPARE_INDEX" -eq "$PH_ARRAY_INDEX" ]] && \
						break
				done
				declare -n PH_PARAM_ARRAY="${PH_DEPTH_PARAMS["${PH_ARRAY_INDEX}"]}"
				unset PH_PARAM_ARRAY["$(echo ${!PH_PARAM_ARRAY[@]} | nawk -v cnt="$PH_COUNT" '{ printf $cnt ; exit }')"]
				unset PH_DEPTH_PARAMS["${PH_ARRAY_INDEX}"]
				unset PH_DEPTH["${PH_ARRAY_INDEX}"]
				unset -n PH_PARAM_ARRAY
			fi
		done
	fi
	((PH_ROLLBACK_DEPTH--))
fi
return "$PH_RET_CODE"
}

function ph_secure_pieh {

declare PH_i=""
declare PH_FILE=""
declare PH_CMD=""
declare PH_ROLLBACK_TIME=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"
declare -i PH_RET_CODE="0"

OPTIND="1"

while getopts f:t:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in t)
		[[ "$OPTARG" != @(immediate|delayed|never) || -n "$PH_ROLLBACK_TIME" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_ROLLBACK_TIME="$OPTARG" ;;
			     f)
		[[ -n "$PH_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG" ;;
			     q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_QUIESCE="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( -n "$PH_FILE" && ! -f "$PH_FILE" && ! -L "$PH_FILE" && ! -d "$PH_FILE" ) || \
	"$#" -gt "5" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_ROLLBACK_TIME" ]] && \
	PH_ROLLBACK_TIME="delayed"
[[ -z "$PH_FILE" ]] && \
	PH_FILE="$PH_BASE_DIR"
for PH_i in ownership permissions
do
	case "$PH_i" in ownership)
				PH_CMD="${PH_SUDO} chown ${PH_RUN_USER}:$("$PH_SUDO" id -gn "$PH_RUN_USER" 2>/dev/null)" ;;
			permissions)
				PH_CMD="${PH_SUDO} chmod 770" ;;
	esac
	PH_CMD="xargs -I '{}' ${PH_CMD} {}"
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		printf "%8s%s\n" "" "--> Applying default file ${PH_i}"
	! eval "'${PH_SUDO}' find '${PH_FILE}' -mount ! -wholename \"${PH_MNT_DIR}/*\" -print 2>/dev/null | ${PH_CMD}" 2>/dev/null && \
		PH_RET_CODE="1" && \
		break
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c true
done
if [[ "$PH_RET_CODE" -ne "0" ]]
then
	ph_set_result -m "An error occurred trying to apply the default file ${PH_i} to one or more files"
	if [[ "$PH_QUIESCE" -eq "1" ]]
	then
		ph_run_with_rollback -c false -m "Could not apply"
	fi
else
	PH_PARAMS="-p create -o acls"
	[[ "$PH_QUIESCE" -eq "0" ]] && \
		PH_PARAMS="${PH_PARAMS} -q"
	ph_all_users_rights -f "$PH_FILE" ${PH_PARAMS} || \
		return 1
	[[ "$PH_QUIESCE" -eq "0" ]] && \
		PH_PARAMS="-q" || \
		PH_PARAMS=""
	ph_add_value_to_param -p PH_SECURE -v "${PH_ROLLBACK_TIME}'${PH_PARAMS}'${PH_FILE}"
fi
return "$PH_RET_CODE"
}

function ph_all_users_rights {

declare PH_APP_USER=""
declare PH_OPTION=""
declare PH_ACTION=""
declare PH_PARAMS=""
declare PH_FILE=""
declare PH_OBJECT=""
declare PH_ROLLBACK_TIME=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"

OPTIND="1"

while getopts p:t:o:f:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_QUIESCE="0" ;;
		     f)
		[[ -n "$PH_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG" ;;
		     t)
		[[ "$OPTARG" != @(immediate|delayed|never) || -n "$PH_ROLLBACK_TIME" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_ROLLBACK_TIME="$OPTARG" ;;
		     p)
		[[ "$OPTARG" != @(remove|create) || -n "$PH_ACTION" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_ACTION="$OPTARG" ;;
		     o)
		[[ "$OPTARG" != @(acls|sudo_rights) || -n "$PH_OBJECT" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_OBJECT="$OPTARG" ;;
		     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_OBJECT" || -z "$PH_ACTION" || "$#" -lt "4" || ( "$PH_OBJECT" == "sudo_rights" && -n "$PH_FILE" ) || \
	( -n "$PH_FILE" && ! -f "$PH_FILE" && ! -L "$PH_FILE" && ! -d "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_OBJECT" == "acls" ]]
then
	PH_PARAMS="-p ${PH_ACTION}"
	[[ -z "$PH_ROLLBACK_TIME" ]] && \
		PH_ROLLBACK_TIME="delayed"
	PH_PARAMS="${PH_PARAMS} -t ${PH_ROLLBACK_TIME}"
	[[ -z "$PH_FILE" ]] && \
		PH_FILE="$PH_BASE_DIR"
	PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
fi
if [[ "$PH_QUIESCE" -eq "0" ]]
then
	[[ -z "$PH_PARAMS" ]] && \
		PH_PARAMS="-q" || \
		PH_PARAMS="${PH_PARAMS} -q"
fi
for PH_APP_USER in $(nawk -v runuser="^${PH_RUN_USER}$" 'BEGIN { \
		users = "" \
	} \
	$2 !~ runuser && $2 !~ /^root$/ { \
		if (users=="") { \
			users = $2 \
		} else { \
			users = users " " $2 \
		} \
	} END { \
		printf users \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
do
	if [[ "$PH_OBJECT" == "acls" ]]
	then
		ph_run_with_rollback -c "ph_user_${PH_OBJECT} -u '${PH_APP_USER}' ${PH_PARAMS}" || \
			return 1
	else
		ph_run_with_rollback -c "ph_${PH_ACTION}_user_${PH_OBJECT} -u '${PH_APP_USER}' ${PH_PARAMS}" || \
			return 1
	fi
done
return 0
}

function ph_create_user_sudo_rights {

declare PH_APP_USER=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"

OPTIND="1"

while getopts u:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q"
		PH_QUIESCE="0" ;;
		     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
		     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -lt "2" || "$#" -gt "3" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) ]]
then
	if [[ -f "/etc/sudoers.d/020_pieh-${PH_APP_USER}" ]]
	then
		if [[ "$("$PH_SUDO" cat "/etc/sudoers.d/020_pieh-${PH_APP_USER}" 2>/dev/null)" != "${PH_APP_USER} ALL=(ALL) NOPASSWD: ALL" ]]
		then
			ph_run_with_rollback -c "ph_remove_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" || \
				return 1 
		else
			return 0
		fi
	fi
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating sudo rights for user " "'${PH_APP_USER}'"
	if ph_run_with_rollback -c "ph_create_empty_file -r -q -d '/etc/sudoers.d/020_pieh-${PH_APP_USER}'"
	then
		if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/sudoers.d/020_pieh-${PH_APP_USER}' -l '${PH_APP_USER} ALL=(ALL) NOPASSWD: ALL'"
		then
			if "$PH_SUDO" chmod 440 "/etc/sudoers.d/020_pieh-${PH_APP_USER}" 2>/dev/null
			then
				ph_add_value_to_param -p PH_REMOVE_RIGHTS_USERS -v "${PH_PARAMS}'${PH_APP_USER}"
				[[ "$PH_QUIESCE" -eq "1" ]] && \
					ph_run_with_rollback -c true
				return 0
			else
				ph_set_result -m "An error occurred trying to set permissions of file '/etc/sudoers.d/020_pieh-${PH_APP_USER}' to '440'"
			fi
		fi
	fi
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c false -m "Could not create"
	return 1
fi
return 0
}

function ph_remove_user_sudo_rights {

declare PH_APP_USER=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"

OPTIND="1"

while getopts u:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q"
		PH_QUIESCE="0" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -lt "2" || "$#" -gt "3" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) && -f "/etc/sudoers.d/020_pieh-${PH_APP_USER}" ]]
then
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing sudo rights for user " "'${PH_APP_USER}'"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/sudoers.d/020_pieh-${PH_APP_USER}'"
	then
		ph_add_value_to_param -p PH_CREATE_RIGHTS_USERS -v "${PH_PARAMS}'${PH_APP_USER}'"
		[[ "$PH_QUIESCE" -eq "1" ]] && \
			ph_run_with_rollback -c true
		return 0
	fi
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c false -m "Could not remove"
	return 1
fi
return 0
}

function ph_user_acls {

declare PH_APP_USER=""
declare PH_ACTION=""
declare PH_FILE=""
declare PH_CMD=""
declare PH_PARAMS=""
declare PH_ROLLBACK_TIME=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_QUIESCE="1"
declare -u PH_ACTIONU=""

OPTIND="1"

while getopts u:f:t:p:q PH_OPTION 2>/dev/null
do
	case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_QUIESCE="0" ;;
			     p)
		[[ "$OPTARG" != @(remove|create) || -n "$PH_ACTION" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_ACTION="$OPTARG" ;;
			     f)
		[[ -n "$PH_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG" ;;
			     t)
		[[ "$OPTARG" != @(immediate|delayed|never) || -n "$PH_ROLLBACK_TIME" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_ROLLBACK_TIME="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || -z "$PH_ACTION" || "$#" -lt "4" || \
	( -n "$PH_FILE" && ! -f "$PH_FILE" && ! -L "$PH_FILE" && ! -d "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_ROLLBACK_TIME" ]] && \
	PH_ROLLBACK_TIME="delayed"
[[ -z "$PH_FILE" ]] && \
	PH_FILE="$PH_BASE_DIR"
if [[ "$PH_ACTION" == "create" ]]
then
	PH_CMD="${PH_SUDO} setfacl -R -m u:${PH_APP_USER}:rwx"
else
	PH_CMD="${PH_SUDO} setfacl -R -x u:${PH_APP_USER}"
fi
PH_CMD="xargs -I '{}' ${PH_CMD} {}"
if [[ "$PH_QUIESCE" -eq "1" ]]
then
	printf "%8s%s%s%s\n" "" "--> $(echo -n "$PH_ACTIONU" | cut -c1)" "$(echo -n "${PH_ACTION%?}" | cut -c2-)" "ing ACLs for user '${PH_APP_USER}'"
else
	PH_PARAMS="-q"
fi
if "$PH_SUDO" find "$PH_FILE" -mount ! -wholename "${PH_MNT_DIR}/*" -print 2>/dev/null | eval "$PH_CMD" 2>/dev/null
then
	[[ "$PH_ACTION" == "create" ]] && \
		PH_ACTION="remove" || \
		PH_ACTION="create"
	PH_ACTIONU="$PH_ACTION"
	ph_add_value_to_param -p "PH_${PH_ACTIONU}_ACLS_USERS" -v "${PH_ROLLBACK_TIME}'${PH_PARAMS}'${PH_APP_USER}'${PH_FILE}"
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c true
	return 0
fi
ph_set_result -m "An error occurred trying to ${PH_ACTION} ACLs for user '${PH_APP_USER}'"
[[ "$PH_QUIESCE" -eq "1" ]] && \
	ph_run_with_rollback -c false -m "Could not create"
return 1
}

function ph_quit_pieh {

[[ "$#" -gt "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

clear 2>/dev/null
printf "\033[36m%s\033[0m\n\n" "- List of available tools : "
! ls "$PH_SCRIPTS_DIR" 2>/dev/null && \
	printf "\n%2s\033[33m%s\033[0m\n" "" "Warning : Could not list"
printf "\n%s\n" "Type the name of any tool and press 'Enter' to run it"
printf "\n%s\n" "Some tools accept additional arguments to modify their default action"
printf "\n%s\n" "Adding the '-h' parameter will display help"
printf "%s\n\n" "Check the help page of a tool for a list of other possible arguments and their effect"
printf "\033[36m%s" "- Quitting PieHelper -> "
if pgrep -f "${PH_SCRIPTS_DIR}/startpieh.sh" >/dev/null 2>&1
then
	if pgrep -f "${PH_SCRIPTS_DIR}/startpieh.sh.*-p$|${PH_SCRIPTS_DIR}/startpieh.sh[[:space:]]*-p[[:space:]].*$" >/dev/null
        then
                printf "%s\n" "'PieHelper' was last running on a pseudo-terminal"
        else
                printf "%s\n" "'PieHelper' was last running on a TTY"
        fi
fi
printf "\033[0m\n"
printf "%s\n" "Run 'startpieh.sh' to (re)start on a TTY"
printf "%s\n" "Run 'startpieh.sh -p' to (re)start on a pseudo-terminal"
printf "\n"
exit 0
}

function ph_create_app_items {

declare PH_APP=""
declare PH_i=""
declare PH_TYPE=""
declare PH_CIFS_MPT=""
declare PH_ALLOWEDS=""
declare PH_CONF_FILE=""
declare PH_DEFAULTS=""
declare PH_MENUS=""
declare PH_SCRIPTS=""
declare PH_PARAM=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:t:kldcms PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$OPTARG" != @(support|integrate|both) || -n "$PH_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_TYPE="$OPTARG" ;;
                             c)
		[[ -n "$PH_CONF_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_CONF_FILE="yes" ;;
                             l)
		[[ -n "$PH_ALLOWEDS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ALLOWEDS="yes" ;;
                             d)
		[[ -n "$PH_DEFAULTS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_DEFAULTS="yes" ;;
                             m)
		[[ -n "$PH_MENUS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_MENUS="yes" ;;
                             s)
		[[ -n "$PH_SCRIPTS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_SCRIPTS="yes" ;;
                             k)
		[[ -n "$PH_CIFS_MPT" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_CIFS_MPT="yes" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "4" || (( -n "$PH_CIFS_MPT" || -n "$PH_SCRIPTS" || -n "$PH_ALLOWEDS" || -n "$PH_DEFAULTS" || -n "$PH_CONF_FILE" || -n "$PH_MENUS" ) && ( -n "$PH_TYPE" )) || \
	( -z "$PH_CIFS_MPT" && -z "$PH_SCRIPTS" && -z "$PH_ALLOWEDS" && -z "$PH_DEFAULTS" && -z "$PH_CONF_FILE" && -z "$PH_MENUS" && -z "$PH_TYPE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "$PH_TYPE" in support)
	PH_CONF_FILE="yes"
	PH_ALLOWEDS="yes"
	PH_DEFAULTS="yes"
	PH_MENUS="yes" ;;
		   integrate)
	PH_SCRIPTS="yes"
	PH_CIFS_MPT="yes" ;;
		   both)
	PH_CONF_FILE="yes"
	PH_ALLOWEDS="yes"
	PH_DEFAULTS="yes"
	PH_MENUS="yes"
	PH_SCRIPTS="yes"
	PH_CIFS_MPT="yes" ;;
esac
for PH_i in PH_CONF_FILE PH_ALLOWEDS PH_DEFAULTS PH_MENUS PH_SCRIPTS PH_CIFS_MPT
do
	case "$PH_i" in *CONF_FILE)
		PH_PARAM="-c" ;;
			*ALLOWEDS)
		PH_PARAM="-l" ;;
			*DEFAULTS)
		PH_PARAM="-d" ;;
			*MENUS)
		PH_PARAM="-m" ;;
			*SCRIPTS)
		PH_PARAM="-s" ;;
			*CIFS_MPT)
		PH_PARAM="-k" ;;
	esac
	if [[ "$(eval "echo -n \"\$${PH_i}\"")" == "yes" ]]
	then
		ph_run_with_rollback -c "ph_create_app_$(echo -n "${PH_i:3}" | tr "[:upper:]" "[:lower:]") '${PH_APP}'" || \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="$PH_PARAM" || \
			PH_PARAMS="${PH_PARAMS} ${PH_PARAM}"
	fi
done
ph_add_value_to_param -p PH_REMOVE_APPS_ITEMS -v "${PH_APP}'${PH_PARAMS}"
return 0
}

function ph_remove_app_cifs_mpt {

declare PH_APP="$1"
declare PH_APP_MPT=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == @(Ctrls|Moonlight) ]] && \
	return 0
PH_APP_MPT="$(ph_get_app_cifs_mpt -a "$PH_APP" -r)"
if [[ -n "$PH_APP_MPT" ]]
then
	printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Removing CIFS mountpoint " "'${PH_APP_MPT}'" " for ${PH_APP}"
	if [[ -e "$PH_APP_MPT" ]]
	then
		if [[ -d "$PH_APP_MPT" ]]
		then
			if [[ "$("$PH_SUDO" find "$PH_APP_MPT" -maxdepth 1 ! -wholename "$PH_APP_MPT" 2>/dev/null | wc -l)" -eq "0" ]]
			then
				if [[ "$(mount 2>/dev/null | nawk -v mstring="^${PH_APP_MPT}$" '$3 ~ mstring { \
						print \
					} { \
						next \
					}' | wc -l)" -eq "0" ]]
				then
					if ph_run_with_rollback -c "ph_remove_empty_file -r -q -t directory -d '${PH_APP_MPT}'"
					then
						ph_add_value_to_param -p PH_CREATE_APPS_CIFS_MPT -v "$PH_APP"
						ph_run_with_rollback -c true && \
							return "$?"
					else
						ph_set_result -m "An error occurred trying to remove ${PH_APP} mountpoint '${PH_APP_MPT}'"
					fi
				else
					ph_set_result -m "Refusing to remove (Directory is an active mountpoint)"
				fi
			else
				ph_set_result -m "Refusing to remove '$PH_APP_MPT' (Directory is not empty)"
			fi
		else
			ph_set_result -m "Refusing to remove '$PH_APP_MPT' (Not a directory)"
		fi
	else
		ph_run_with_rollback -c true -m "Nothing to do" && \
			return "$?"
	fi
	ph_run_with_rollback -c false -m "Could not remove" || \
		return 1
fi
return 0
}

function ph_get_app_cifs_mpt {

declare PH_APP=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"
declare -i PH_RESOLVE="1"
declare -u PH_APPU=""

OPTIND="1"

while getopts a:r PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             r)
		[[ "$PH_RESOLVE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_RESOLVE="0" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
                ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == @(Moonlight|Ctrls) ]] && \
	return 0
PH_APPU="${PH_APP:0:4}"
declare -n PH_APP_MPT="PH_${PH_APPU}_CIFS_MPT"
if [[ "$PH_RESOLVE" -eq "0" ]]
then
	eval echo -n "$PH_APP_MPT"
else
	echo -n "$PH_APP_MPT"
fi
unset -n PH_APP_MPT
return 0
}

function ph_create_app_cifs_mpt {

declare PH_APP="$1"
declare PH_APP_MPT=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == @(Moonlight|Ctrls) ]] && \
	return 0
PH_APP_MPT="$(ph_get_app_cifs_mpt -a "$PH_APP" -r)"
if [[ -n "$PH_APP_MPT" ]]
then
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating CIFS mountpoint for ${PH_APP} as " "'${PH_APP_MPT}'"
	if [[ -d "$PH_APP_MPT" ]]
	then
		if [[ "$("$PH_SUDO" find "$PH_APP_MPT" -maxdepth 1 ! -wholename "$PH_APP_MPT" 2>/dev/null | wc -l)" -ne "0" ]]
		then
			ph_set_result -m "Could not accept '${PH_APP_MPT}' as a mountpoint (Not an empty directory)"
		else
			if [[ "$(mount 2>/dev/null | nawk -v mstring="^${PH_APP_MPT}$" '$3 ~ mstring { \
					print \
				} { \
					next \
				}' | wc -l)" -gt "0" ]]
			then
				ph_set_result -m "Could not accept '${PH_APP_MPT}' as a mountpoint (Directory is an active mountpoint)"
			else
				ph_run_with_rollback -c true -m "Nothing to do" && \
					return "$?"
			fi
		fi
	else
		if [[ -e "$PH_APP_MPT" ]]
		then
			ph_set_result -m "Refusing to accept '${PH_APP_MPT}' as a mountpoint (Not an empty directory)"
		else
			if ! ph_run_with_rollback -c "ph_create_empty_file -r -q -t directory -d '${PH_APP_MPT}'"
			then
				ph_set_result -m "An error occurred trying to create mountpoint '${PH_APP_MPT}' for ${PH_APP}"
			else
				ph_add_value_to_param -p PH_REMOVE_APPS_CIFS_MPT -v "$PH_APP"
				ph_run_with_rollback -c true && \
					return "$?"
			fi
		fi
	fi
	ph_run_with_rollback -c false -m "Could not create" || \
		return 1
fi
return 0
}

function ph_remove_app_items {

declare PH_i=""
declare PH_APP=""
declare PH_TYPE=""
declare PH_CIFS_MPT=""
declare PH_ALLOWEDS=""
declare PH_CONF_FILE=""
declare PH_DEFAULTS=""
declare PH_MENUS=""
declare PH_SCRIPTS=""
declare PH_PARAM=""
declare PH_PARAMS=""
declare PH_OPTION=""
declare PH_OLDOPTARG="$OPTARG"
declare -i PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts a:t:kldcms PH_OPTION 2>/dev/null
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$OPTARG" != @(unsupport|unintegrate|both) || -n "$PH_TYPE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_TYPE="$OPTARG" ;;
                             c)
		[[ -n "$PH_CONF_FILE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_CONF_FILE="yes" ;;
                             l)
		[[ -n "$PH_ALLOWEDS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ALLOWEDS="yes" ;;
                             d)
		[[ -n "$PH_DEFAULTS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_DEFAULTS="yes" ;;
                             m)
		[[ -n "$PH_MENUS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_MENUS="yes" ;;
                             s)
		[[ -n "$PH_SCRIPTS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_SCRIPTS="yes" ;;
                             k)
		[[ -n "$PH_CIFS_MPT" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_CIFS_MPT="yes" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "4" || (( -n "$PH_CIFS_MPT" || -n "$PH_ALLOWEDS" || -n "$PH_DEFAULTS" || -n "$PH_CONF_FILE" || -n "$PH_MENUS" || -n "$PH_SCRIPTS" ) && ( -n "$PH_TYPE" )) || \
	( -z "$PH_CIFS_MPT" && -z "$PH_ALLOWEDS" && -z "$PH_DEFAULTS" && -z "$PH_CONF_FILE" && -z "$PH_MENUS" && -z "$PH_SCRIPTS" && -z "$PH_TYPE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "$PH_TYPE" in unsupport)
	PH_MENUS="yes"
	PH_DEFAULTS="yes"
	PH_ALLOWEDS="yes"
	PH_CONF_FILE="yes" ;;
		   unintegrate)
	PH_CIFS_MPT="yes"
	PH_SCRIPTS="yes" ;;
		   both)
	PH_CIFS_MPT="yes"
	PH_SCRIPTS="yes"
	PH_MENUS="yes"
	PH_DEFAULTS="yes"
	PH_ALLOWEDS="yes"
	PH_CONF_FILE="yes" ;;
esac
for PH_i in PH_CIFS_MPT PH_SCRIPTS PH_MENUS PH_DEFAULTS PH_ALLOWEDS PH_CONF_FILE
do
	case "$PH_i" in *CIFS_MPT)
		PH_PARAM="-k" ;;
			*SCRIPTS)
		PH_PARAM="-s" ;;
			*MENUS)
		PH_PARAM="-m" ;;
			*DEFAULTS)
		PH_PARAM="-d" ;;
			*ALLOWEDS)
		PH_PARAM="-l" ;;
			*CONF_FILE)
		PH_PARAM="-c" ;;
	esac
	if [[ "$(eval "echo -n \"\$${PH_i}\"")" == "yes" ]]
	then
		ph_run_with_rollback -c "ph_remove_app_$(echo -n "${PH_i:3}" | tr "[:upper:]" "[:lower:]") '${PH_APP}'" || \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="$PH_PARAM" || \
			PH_PARAMS="${PH_PARAMS} ${PH_PARAM}"
	fi
done
ph_add_value_to_param -p PH_CREATE_APPS_ITEMS -v "${PH_APP}'${PH_PARAMS}"
return 0
}

function ph_remove_app_conf_file {

declare PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -f "${PH_CONF_DIR}/${PH_APP}.conf" ]]
then
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} config file " "'${PH_CONF_DIR}/${PH_APP}.conf'"
	if ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/${PH_APP}.conf'"
	then
		ph_add_value_to_param -p PH_CREATE_APPS_CONF_FILE -v "$PH_APP"
		ph_run_with_rollback -c true && \
			return "$?"
	else
		ph_set_result -m "An error occurred trying to remove ${PH_APP} config file '${PH_CONF_DIR}/${PH_APP}.conf'"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
ph_run_with_rollback -c false -m "Could not remove" || \
	return 1
}

function ph_remove_app_scripts {

declare PH_i=""
declare PH_APP="$1"
declare -i PH_COUNT="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == "Ctrls" ]] && \
	return 0
for PH_i in $(nawk -v app="$PH_APP" -v mstring="^${PH_APP}$" 'BEGIN { \
		ORS = " " ; \
		appl = tolower(substr(app,1,4)) ; \
		appl2 = "" \
	} \
	$1 !~ mstring { \
		appl2 = tolower(substr($1,1,4)) ; \
		printf "%s%s", appl "to", appl2 ".sh " ; \
		printf "%s%s", appl2 "to", appl ".sh " ; \
		next \
	} { \
		next \
	} END { \
		printf "%s%s%s%s%s%s", "start" appl, ".sh ", "restart" appl, ".sh ", "stop" appl, ".sh" \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
do
	if [[ -f "${PH_SCRIPTS_DIR}/${PH_i}" ]]
	then
		[[ "$PH_COUNT" -eq "0" ]] && \
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing management scripts for " "'${PH_APP}'"
		((PH_COUNT++))
		if ! ph_run_with_rollback -c "ph_store_file -f '${PH_SCRIPTS_DIR}/${PH_i}'"
		then
			ph_set_result -m "An error occurred trying to remove ${PH_APP} management script '${PH_SCRIPTS_DIR}/${PH_i}'"
			ph_run_with_rollback -c false -m "Could not remove" || \
				return 1
		fi
	fi
done
[[ "$PH_COUNT" -eq "0" ]] && \
	return 0
ph_add_value_to_param -p PH_CREATE_APPS_SCRIPTS -v "$PH_APP"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_remove_app_alloweds {

declare PH_APP="$1"
declare PH_TMP_FILE=""
declare -u PH_APPU=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPU="${PH_APP:0:4}"
if grep -E "^PH_${PH_APPU}_" "${PH_CONF_DIR}/options.alloweds" >/dev/null 2>&1
then
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} option alloweds from file " "'${PH_CONF_DIR}/options.alloweds'"
	if ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/options.alloweds'"
	then
		if PH_TMP_FILE="$("$PH_SUDO" ls -lAt "${PH_TMP_DIR}/options_alloweds_tmp."* 2>/dev/null | nawk '{ \
				printf $NF ; \
				exit \
			}')"
		then
			if nawk -F'=' -v appu="^PH_${PH_APPU}_" '$1 ~ appu { \
					next \
				} { \
					print ; \
					next \
				}' "$PH_TMP_FILE" >"${PH_CONF_DIR}/options.alloweds" 2>/dev/null
			then
				if ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_CONF_DIR}/options.alloweds'"
				then
					ph_add_value_to_param -p PH_CREATE_APPS_ALLOWEDS -v "$PH_APP"
					ph_run_with_rollback -c true && \
						return "$?"
				fi
			else
				ph_set_result -m "An error occurred trying to remove ${PH_APP} option alloweds from file '${PH_CONF_DIR}/options.alloweds'"
			fi
		else
			ph_set_result -m "An error occurred trying to remove ${PH_APP} option alloweds from file '${PH_CONF_DIR}/options.alloweds'"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not remove" || \
		return 1
fi
return 0
}

function ph_remove_app_defaults {

declare PH_APP="$1"
declare PH_TMP_FILE=""
declare -u PH_APPU=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPU="${PH_APP:0:4}"
if grep -E "^PH_${PH_APPU}_" "${PH_CONF_DIR}/options.defaults" >/dev/null 2>&1
then
	printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing ${PH_APP} option defaults from file " "'${PH_CONF_DIR}/options.defaults'"
	if ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/options.defaults'"
	then
		if PH_TMP_FILE="$("$PH_SUDO" ls -lAt "${PH_TMP_DIR}/options_defaults_tmp."* 2>/dev/null | nawk '{ \
				printf $NF ; \
				exit \
			}')"
		then
			if nawk -F'=' -v appu="^PH_${PH_APPU}_" '$1 ~ appu { \
					next \
				} { \
					print ; \
					next \
				}' "$PH_TMP_FILE" >"${PH_CONF_DIR}/options.defaults" 2>/dev/null
			then
				if ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_CONF_DIR}/options.defaults'"
				then
					ph_add_value_to_param -p PH_CREATE_APPS_DEFAULTS -v "$PH_APP"
					ph_run_with_rollback -c true && \
						return "$?"
				fi
			else
				ph_set_result -m "An error occurred trying to remove ${PH_APP} option defaults from file '${PH_CONF_DIR}/options.defaults'"
			fi
		else
			ph_set_result -m "An error occurred trying to remove ${PH_APP} option defaults from file '${PH_CONF_DIR}/options.defaults'"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not remove" || \
		return 1
fi
return 0
}

function ph_get_link_target {

declare PH_TARGET="$1"
declare PH_LINKED_TO=""

[[ -z "$PH_TARGET" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -L "$PH_TARGET" ]]
then
	if PH_LINKED_TO="$("$PH_SUDO" find "${PH_TARGET%/*}" -name "${PH_TARGET##*/}" -exec ls -la {} \; 2>/dev/null | nawk '{ \
			printf $NF \
		}')"
	then
		if [[ "$PH_LINKED_TO" != /* ]]
		then
			PH_LINKED_TO="${PH_TARGET%/*}/${PH_LINKED_TO}"
		fi
		echo -n "$PH_LINKED_TO"
	else
		ph_set_result -m "An error occurred trying to determine the link target of logical link '${PH_TARGET}'"
		return 1
	fi
fi
return 0
}

function ph_get_linked_menu_app {

declare PH_i=""
declare PH_LINKED_MENU_APP=""
declare PH_LINKED_TO
declare -a PH_LINKS

[[ "$#" -ne "0" ]] && \
	unset PH_LINKS && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in AppManagement TTYManagement OptsManagement
do
	if PH_LINKED_TO="$(ph_get_link_target "${PH_MENUS_DIR}/${PH_i}.lst")"
	then
		if [[ -n "$PH_LINKED_TO" ]]
		then
			PH_LINKS+="$(sed "s/^${PH_i}_//;s/\.lst$//"<<<"$PH_LINKED_TO")"
		else
			PH_LINKS+=("")
		fi
	else
		unset PH_LINKS
		return 1
	fi
done
unset PH_LINKS
echo -n "$PH_LINKED_MENU_APP"
if [[ "${PH_LINKS[0]}" == "${PH_LINKS[1]}" && "${PH_LINKS[0]}" == "${PH_LINKS[2]}" ]]
then
	return 0
else
	return 1
fi
}

function ph_unlink_app_from_menu {

declare PH_i=""
declare PH_UNLINK_APP="$1"
declare PH_LINKED_MENU_APP=""

[[ ( -z "$PH_LINKED_MENU_APP" && "$#" -ne "0" ) || \
	( -n "$PH_LINKED_MENU_APP" && "$#" -ne "1" )  ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Determining the application currently linked to the menu"
if PH_LINKED_MENU_APP="$(ph_get_linked_menu_app)"
then
	if [[ -n "$PH_LINKED_MENU_APP" ]]
	then
		ph_run_with_rollback -c true -m "$PH_LINKED_MENU_APP"
	else
		ph_run_with_rollback -c true -m "Nothing to do"
		return 0
	fi
else
	if [[ -n "$PH_LINKED_MENU_APP" ]]
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Inconsistent menu links"
		ph_set_result -r 0
		PH_UNLINK_APP=""
	else
		ph_run_with_rollback -c false -m "Could not determine" || \
			return 1
	fi
fi
if [[ -z "$PH_UNLINK_APP" || "$PH_UNLINK_APP" != "$PH_LINKED_MENU_APP" ]]
then
	PH_UNLINK_APP="$PH_LINKED_MENU_APP"
fi
printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Unlinking " "'${PH_UNLINK_APP}'" " from menu"
for PH_i in AppManagement TTYManagement OptsManagement
do
	if [[ -L "${PH_MENUS_DIR}/${PH_i}.lst" ]]
	then
		if ! ph_run_with_rollback -c "ph_remove_empty_file -q -t link -d '${PH_MENUS_DIR}/${PH_i}.lst'"
		then
			ph_run_with_rollback -c false -m "Could not unlink" || \
				return 1
		fi
	fi
done
ph_add_value_to_param -p PH_LINK_MENUS -v "$PH_UNLINK_APP"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_link_app_to_menu {

declare PH_i=""
declare PH_LINK_APP_TO_MENU="$1"
declare PH_LINKED_MENU_APP=""

[[ -z "$PH_LINK_APP_TO_MENU" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -L "${PH_MENUS_DIR}/TTYManagement.lst" || -L "${PH_MENUS_DIR}/AppManagement.lst" || -L "${PH_MENUS_DIR}/OptsManagement.lst" ]]
then
	printf "%8s%s\n" "" "--> Determining the application currently linked to the menu"
	if PH_LINKED_MENU_APP="$(ph_get_linked_menu_app)"
	then
		if [[ -n "$PH_LINKED_MENU_APP" ]]
		then
			ph_run_with_rollback -c true -m "$PH_LINKED_MENU_APP"
			if [[ "$PH_LINKED_MENU_APP" != "$PH_LINK_APP_TO_MENU" ]]
			then
				ph_run_with_rollback -c "ph_unlink_app_from_menu '${PH_LINKED_TO_MENU}'" || \
					return 1
				PH_LINKED_MENU_APP=""
			else
				ph_run_with_rollback -c true -m "Nothing to do"
				return 0
			fi
		else
			ph_run_with_rollback -c true -m "Nothing currently linked"
		fi
	else
		if [[ -z "$PH_LINKED_MENU_APP" ]]
		then
			ph_run_with_rollback -c false -m "Could not determine" || \
				return 1
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Inconsistent menu links -> Removing the current links"
			ph_set_result -r 0
			ph_run_with_rollback -c "ph_unlink_app_from_menu '${PH_LINKED_MENU_APP}'" || \
				return 1
			PH_LINKED_MENU_APP=""
		fi
	fi
fi
printf "%8s%s\033[32m%s\033[0m%s\n" "" "--> Linking " "'${PH_LINK_APP_TO_MENU}'" " to menu"
for PH_i in AppManagement TTYManagement OptsManagement
do
	if [[ ! -L "${PH_MENUS_DIR}/${PH_i}.lst" ]]
	then
		if ! ph_run_with_rollback -c "ph_create_empty_file -q -t link -s '${PH_MENUS_DIR}/${PH_i}_${PH_LINK_APP_TO_MENU}.lst' -d '${PH_MENUS_DIR}/${PH_i}.lst'"
		then
			ph_run_with_rollback -c false -m "Could not link" || \
				return 1
		fi
		PH_COUNT="$((PH_COUNT+1))"
	fi
done
ph_add_value_to_param -p PH_UNDO_LINK_MENUS -v "$PH_LINK_APP_TO_MENU"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_remove_app_menus {

declare PH_i=""
declare PH_APP="$1"
declare -i PH_COUNT="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == "Ctrls" ]] && \
	return 0
ph_run_with_rollback -c "ph_unlink_app_from_menu" || \
	return 1
for PH_i in "$PH_APP" "TTYManagement_${PH_APP}" "OptsManagement_${PH_APP}" "AppManagement_${PH_APP}"
do
	if [[ -f "${PH_MENUS_DIR}/${PH_i}.lst" ]]
	then
		[[ "$PH_COUNT" -eq "0" ]] && \
			printf "%8s%s\033[32m%s\033[0m\n" "" "--> Removing menu items for " "'${PH_APP}'"
		((PH_COUNT++))
		if ! ph_run_with_rollback -c "ph_store_file -f '${PH_MENUS_DIR}/${PH_i}.lst'"
		then
			ph_run_with_rollback -c false -m "Could not remove" || \
				return 1
		fi
	fi
done
[[ "$PH_COUNT" -eq "0" ]] && \
	return 0
ph_add_value_to_param -p PH_CREATE_APPS_MENUS -v "$PH_APP"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_create_app_scripts {

declare PH_i=""
declare PH_APP="$1"
declare PH_APP2=""
declare PH_SWAP=""
declare PH_SCRIPT_PREFIX=""
declare PH_SCRIPT_SUFFIX=""
declare -l PH_APPL=""
declare -l PH_APPL2=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == "Ctrls" ]] && \
	return 0
ph_run_with_rollback -c "ph_remove_app_scripts '${PH_APP}'" || \
	return 1
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating management scripts for " "'${PH_APP}'"
[[ "$PH_APP" == "PieHelper" ]] && \
	PH_SCRIPT_SUFFIX="PieH"
for PH_i in start stop restart
do
	PH_APPL="${PH_APP:0:4}"
	PH_SCRIPT_PREFIX="$(echo -n "$PH_i" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo -n "$PH_i" | cut -c2-)"
	if ph_run_with_rollback -c "ph_copy_file -q -s '${PH_TEMPLATES_DIR}/${PH_SCRIPT_PREFIX}Script${PH_SCRIPT_SUFFIX}.template' -d '${PH_SCRIPTS_DIR}/${PH_i}${PH_APPL}.sh'"
	then
		if sed -i "s/#PH_APPL#/${PH_APPL}/g;s/#PH_APP#/${PH_APP}/g" "${PH_SCRIPTS_DIR}/${PH_i}${PH_APPL}.sh" 2>/dev/null
		then
			ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_SCRIPTS_DIR}/${PH_i}${PH_APPL}.sh'" && \
				continue
		else
			ph_set_result -m "An error occurred trying to modify management script '${PH_SCRIPTS_DIR}/${PH_i}${PH_APPL}.sh' for ${PH_APP}"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not create" || \
		return 1
done
for PH_APP2 in $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $1 \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
do
	[[ "$PH_APP" == "$PH_APP2" ]] && \
		continue
	[[ "$PH_APP" == "PieHelper" ]] && \
		PH_SCRIPT_SUFFIX="fromPieH" || \
		PH_SCRIPT_SUFFIX=""
	[[ "$PH_APP2" == "PieHelper" ]] && \
		PH_SCRIPT_SUFFIX="toPieH" || \
		PH_SCRIPT_SUFFIX=""
        PH_APPL2="${PH_APP2:0:4}"
        for PH_i in 1 2
        do
		if ph_run_with_rollback -c "ph_copy_file -q -s '${PH_TEMPLATES_DIR}/Move${PH_SCRIPT_SUFFIX}Script.template' -d '${PH_SCRIPTS_DIR}/${PH_APPL}to${PH_APPL2}.sh'"
		then
			if sed -i "s/#PH_APPL#/${PH_APPL}/g;s/#PH_APP#/${PH_APP}/g;s/#PH_APPL2#/${PH_APPL2}/g;s/#PH_APP2#/${PH_APP2}/g" "${PH_SCRIPTS_DIR}/${PH_APPL}to${PH_APPL2}.sh" 2>/dev/null
			then
				ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_SCRIPTS_DIR}/${PH_APPL}to${PH_APPL2}.sh'" && \
					continue
				break
			else
				ph_set_result -m "An error occurred trying to modify management script '${PH_SCRIPTS_DIR}/${PH_APPL}to${PH_APPL2}.sh' for ${PH_APP}"
				break
			fi
		else
			break
		fi
                PH_SWAP="$PH_APP" ; PH_APP="$PH_APP2" ; PH_APP2="$PH_SWAP"
                PH_SWAP="$PH_APPL" ; PH_APPL="$PH_APPL2" ; PH_APPL2="$PH_SWAP"
		[[ "$PH_i" -eq "2" ]] && \
			continue 2
	done
	ph_run_with_rollback -c false -m "Could not create" || \
		return 1
done
ph_add_value_to_param -p PH_REMOVE_APPS_SCRIPTS -v "$PH_APP"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_create_app_conf_file {

declare PH_APP="$1"
declare PH_SOURCE_FILE=""
declare -u PH_APPU=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APPU="${PH_APP:0:4}"
PH_SOURCE_FILE="${PH_APP}_conf"
[[ "$(cut -f1 "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null ; echo "$?")" -ne "0" && \
	"$PH_APP" != "Ctrls" ]] && \
	PH_SOURCE_FILE="OOSapp_conf"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating config file for ${PH_APP} as " "'${PH_CONF_DIR}/${PH_APP}.conf'"
if [[ -f "${PH_CONF_DIR}/${PH_APP}.conf" ]]
then
	if ! ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/${PH_APP}.conf'"
	then
		ph_set_result -m "An error occurred backup existing conf file '${PH_CONF_DIR}/${PH_APP}.conf'"
		ph_run_with_rollback -c false -m "Could not backup" || \
			return 1
	fi
fi
if ph_run_with_rollback -c "ph_copy_file -q -s '${PH_TEMPLATES_DIR}/${PH_SOURCE_FILE}.template' -d '${PH_CONF_DIR}/${PH_APP}.conf'"
then
	if sed -i "s/#PH_APPU#/${PH_APPU}/;s/#PH_APP#/${PH_APP}/" "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null
	then
		if ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_CONF_DIR}/${PH_APP}.conf'"
		then
			ph_add_value_to_param -p PH_REMOVE_APPS_CONF_FILE -v "$PH_APP"
			ph_run_with_rollback -c true && \
				return "$?"
		fi
	else
		ph_set_result -m "An error occurred trying to modify ${PH_APP} conf file '${PH_CONF_DIR}/${PH_APP}.conf'"
	fi
fi
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_create_app_menus {

declare PH_i
declare PH_j
declare PH_APP
declare -l PH_APPL

PH_APP="$1"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "$PH_APP" == "Ctrls" ]] && \
	return 0
ph_run_with_rollback -c "ph_remove_app_menus '${PH_APP}'" || \
	return 1
PH_APPL="${PH_APP:0:4}"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating menu items for " "'${PH_APP}'"
for PH_i in "${PH_MENUS_DIR}/${PH_APP}.lst" "${PH_MENUS_DIR}/OptsManagement_${PH_APP}.lst" "${PH_MENUS_DIR}/TTYManagement_${PH_APP}.lst" "${PH_MENUS_DIR}/AppManagement_${PH_APP}.lst"
do
	ph_run_with_rollback -c "ph_create_empty_file -q -t file -d '${PH_i}'" || \
		break
	case "$PH_i" in "${PH_MENUS_DIR}/${PH_APP}.lst")
		for PH_j in "Go to submenu \"${PH_APP} TTYManagement\":ph_show_menu TTYManagement_${PH_APP}" \
			"Go to submenu \"${PH_APP} AppManagement\":ph_show_menu AppManagement_${PH_APP}" \
			"Go to submenu \"${PH_APP} OptsManagement\":ph_show_menu OptsManagement_${PH_APP}"
		do
			ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
				break 2
		done ;;
			"${PH_MENUS_DIR}/OptsManagement_${PH_APP}.lst")
		for PH_j in "List all ${PH_APP} options:confopts_ph.sh -p list -a \"${PH_APP}\" | more" \
			"List read/write ${PH_APP} options:confopts_ph.sh -p list -a \"${PH_APP}\" -t rw | more" \
			"List read-only ${PH_APP} options:confopts_ph.sh -p list -a \"${PH_APP}\" -t ro | more" \
			"Show ${PH_APP} option values (With variable expansion disabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -g" \
			"Show ${PH_APP} option values (With variable expansion enabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -g -r" \
			"Change the value of selected ${PH_APP} options (With variable expansion disabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -s" \
			"Change the value of selected ${PH_APP} options (With variable expansion enabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -s -r" \
			"Change the value of all ${PH_APP} options:ph_configure_app_options \"${PH_APP}\"" \
			"Reset all ${PH_APP} options to default values:ph_set_app_options_to_default_value \"${PH_APP}\";PH_OPTIONS=\"\"" \
			"Display help about selected ${PH_APP} options (With variable expansion disabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -d" \
			"Display help about selected ${PH_APP} options (With variable expansion enabled):confopts_ph.sh -p prompt -a \"${PH_APP}\" -d -r"
		do
			if [[ "$PH_APP" == "PieHelper" && "$PH_j" == Reset* ]]
			then
				eval "PH_j='Reset all ${PH_APP} options to default values (Debug will not be affected):for PH_k in PH_PIEH_PERSISTENT PH_PIEH_CMD_OPTS PH_PIEH_CIFS_SHARE PH_PIEH_CIFS_USER PH_PIEH_CIFS_PASS PH_PIEH_CIFS_SRV PH_PIEH_CIFS_DIR PH_PIEH_CIFS_SUBDIR PH_PIEH_CIFS_MPT PH_PIEH_PRE_CMD PH_PIEH_POST_CMD PH_PIEH_PKG_NAME PH_PIEH_SANITY;do;ph_set_option_to_default_value \"\$PH_k\";PH_OPTIONS=\"\";unset PH_k;done'"
			fi
			ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
				break 2
		done ;;
			"${PH_MENUS_DIR}/TTYManagement_${PH_APP}.lst")
		for PH_j in "Show the TTY currently allocated to ${PH_APP}:confapps_ph.sh -p tty -a \"${PH_APP}\" | more" \
			"Move the ${PH_APP} app to another TTY:confapps_ph.sh -p move -a \"${PH_APP}\" -t prompt"
		do
			[[ "$PH_APP" == "PieHelper" && "$PH_j" == Move* ]] && \
				continue
			ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
				break 2
		done ;;
			"${PH_MENUS_DIR}/AppManagement_${PH_APP}.lst")
		if [[ "$PH_APP" == "PieHelper" ]]
		then
			for PH_j in "Start PieHelper:echo \"*Sigh* I'm already running ! Stop buggering me...\"" \
				"Update ${PH_APP}:confapps_ph.sh -p update -a \"${PH_APP}\"" \
				"Stop ${PH_APP}:break" \
				"Unconfigure ${PH_APP}:confpieh_ph.sh -u" \
				"Uninstall ${PH_APP}:confpieh_ph.sh -r" \
				"Show the current version of ${PH_APP}:confpieh_ph.sh -g | more" \
				"Show ${PH_APP} info:confapps_ph.sh -p info -a \"${PH_APP}\""
			do
				ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
					break 2
			done
		else
			for PH_j in "Update ${PH_APP}:confapps_ph.sh -p update -a \"${PH_APP}\"" \
				"Start ${PH_APP}:start${PH_APPL}.sh | more" \
				"Stop ${PH_APP}:stop${PH_APPL}.sh -f | more" \
				"Restart ${PH_APP}:restart${PH_APPL}.sh | more" \
				"Configure ${PH_APP}:confapps_ph.sh -p conf -a \"${PH_APP}\"" \
				"Integrate ${PH_APP}:confapps_ph.sh -p int -a \"${PH_APP}\"" \
				"Unsupport ${PH_APP}:confapps_ph.sh -p unsup -a \"${PH_APP}\"" \
				"Unintegrate ${PH_APP}:confapps_ph.sh -p unint -a \${PH_APP}\"" \
				"Show ${PH_APP} info:confapps_ph.sh -p info -a \"${PH_APP}\""
			do
				ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
					break 2
			done
		fi ;;
	esac
	for PH_j in "Go to menu \"${PH_APP}\":ph_show_menu \"${PH_APP}\"" \
		'Go to menu "Main":ph_show_menu Main' \
		'Go to menu "Apps":ph_show_menu Apps' \
		'Open Shell to home directory (Type "CTRL-D" to return):cd;/bin/bash' \
		'Return to previous screen:return'
	do
		[[ "$PH_i" == "${PH_MENUS_DIR}/${PH_APP}.lst" && "$PH_j" == "Go to menu \"${PH_APP}\":ph_show_menu \"${PH_APP}\"" ]] && \
			continue
		ph_run_with_rollback -c "ph_add_line_to_file -l '${PH_j}' -f '${PH_i}'" || \
			break 2
	done
	ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_i}'" || \
		break
	if [[ "$PH_i" == "${PH_MENUS_DIR}/AppManagement_${PH_APP}.lst" ]]
	then
		if [[ "$PH_APP" == "PieHelper" ]]
		then
			ph_run_with_rollback -c "ph_link_app_to_menu '${PH_APP}'" || \
				return 1
		fi
		ph_add_value_to_param -p PH_REMOVE_APPS_MENUS -v "$PH_APP"
		ph_run_with_rollback -c true && \
			return "$?"
	fi
done
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_create_app_alloweds {

declare PH_i=""
declare PH_APP="$1"
declare PH_LINE=""
declare -u PH_APPU="${PH_APP:0:4}"
declare "PH_${PH_APPU}_OPTS=USE_CTRL NUM_CTRL PERSISTENT CIFS_SHARE CIFS_USER CIFS_PASS CIFS_SRV CIFS_DIR CIFS_SUBDIR CIFS_MPT PRE_CMD POST_CMD"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
case "$PH_APP" in Moonlight)
                PH_OPTS="$PH_OPTS RES WIDTH HEIGHT FPS BITRATE PCKETSIZE SRV" ;;
                      Ctrls)
                PH_OPTS="MAP TYPE PIN_PS3 PIN_PS4 BLUE_ADAPT" ;;
		      Emulationstation)
                PH_OPTS="$PH_OPTS DIR SETUP_DIR" ;;
		      PieHelper)
                PH_OPTS="$PH_OPTS STARTAPP SANITY" ;;
esac
unset -n PH_OPTS
ph_run_with_rollback -c "ph_remove_app_alloweds '${PH_APP}'" || \
	return 1
declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating ${PH_APP} option alloweds in file " "'${PH_CONF_DIR}/options.alloweds'"
for PH_i in ${PH_OPTS}
do
	case "$PH_i" in DIR|*_CMD)
		PH_LINE='an empty string, variable or valid pathname:"$PH_OPTARG_VAL" == @(\$*|) || -f "$PH_OPTARG_VAL"' ;;
			CIFS_DIR|CIFS_SUBDIR|CIFS_MPT)
		PH_LINE='an empty string, variable or starting with /:"$PH_OPTARG_VAL" == @(/*|\$*|)' ;;
			CIFS_PASS)
		PH_LINE='an empty string or a string without single quotes:"$("$(ph_check_password_validity "$PH_OPTARG_VAL")" ; echo "$?")" -eq "0"' ;;
			*SRV)
		PH_LINE='a valid ipv4 address or an empty string:"$("$(ph_check_ip_validity "$PH_OPTARG_VAL")" ; echo "$?")" -eq "0"' ;;
			PERSISTENT|MAP|CIFS_SHARE|USE_CTRL|SANITY)
		PH_LINE='yes or no:"$PH_OPTARG_VAL" == @(yes|no)' ;;
			NUM_CTRL)
		PH_LINE='1, 2, 3 or 4:"$PH_OPTARG_VAL" == @(1|2|3|4)' ;;
			RES)
		PH_LINE='720, 1080 or 4k:"$PH_OPTARG_VAL" == @(720|1080|4k)' ;;
			WIDTH|HEIGHT)
		PH_LINE='a whole number:"$PH_OPTARG_VAL" == +(0|1|2|3|4|5|6|7|8|9)' ;;
			FPS)
		PH_LINE='a whole number or -1:"$PH_OPTARG_VAL" == @(+(0|1|2|3|4|5|6|7|8|9)|-1)' ;;
			BITRATE)
		PH_LINE='a multiple of 1024:"$PH_OPTARG_VAL" == +([0-9]) && "$(expr "$PH_OPTARG_VAL" % 1024 2>/dev/null)" -eq "0"' ;;
			PCKTSIZE)
		PH_LINE='a multiple of 16:"$PH_OPTARG_VAL" == +([0-9]) && "$(expr "$PH_OPTARG_VAL" % 16 2>/dev/null)" -eq "0"' ;;
			PIN_PS3|PIN_PS4)
		PH_LINE='a four-character word or an empty string:"$PH_OPTARG_VAL" == @({4}(@([a-Z]|[0-9]))|)' ;;
			BLUE_ADAPT)
		PH_LINE='a valid mac address or none:"$("$(ph_check_mac_validity "$PH_OPTARG_VAL")" ; echo "$?")" -eq "0"' ;;
			TYPE)
		PH_LINE='PS3, PS4 or XBOX360:"$PH_OPTARG_VAL" == @(PS3|PS4|XBOX360)' ;;
			CIFS_USER)
		PH_LINE='a locally existing account or an empty string:"$("$(ph_check_user_validity "$PH_OPTARG_VAL")" ; echo "$?")" -eq "0"' ;;
			STARTAPP)
		PH_LINE='an integrated application or none:"$("$(ph_check_app_state_validity -a "$PH_OPTARG_VAL" -q -i)" ; echo "$?")" -eq "0" || "$PH_OPTARG_VAL" == "none"' ;;
	esac
	unset -n PH_OPTS
	if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/options.alloweds' -l 'PH_${PH_APPU}_${PH_i}:${PH_LINE}'"
	then
		ph_run_with_rollback -c false -m "Could not create" || \
			return 1
	fi
	declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
done
unset -n PH_OPTS
if ! ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_CONF_DIR}/options.alloweds'"
then
	ph_run_with_rollback -c false -m "Could not create" || \
		return 1
fi
ph_add_value_to_param -p PH_REMOVE_APPS_ALLOWEDS -v "$PH_APP"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_create_app_defaults {

declare PH_i=""
declare PH_APP="$1"
declare PH_OPT=""
declare PH_LINE=""
declare -u PH_APPU="${PH_APP:0:4}"
declare "PH_${PH_APPU}_OPTS=USE_CTRL PKG_NAME CMD_OPTS NUM_CTRL PERSISTENT CIFS_PASS CIFS_SHARE CIFS_USER CIFS_SRV CIFS_DIR CIFS_SUBDIR CIFS_MPT PRE_CMD POST_CMD"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
case "$PH_APP" in Moonlight)
                PH_OPTS="${PH_OPTS} RES WIDTH HEIGHT FPS BITRATE PCKTSIZE SRV GAME" ;;
                      Ctrls)
                PH_OPTS="MAP TYPE PS3_PIN PS4_PIN BLUE_ADAPT" ;;
           Emulationstation)
                PH_OPTS="${PH_OPTS} DIR SETUP_DIR" ;;
                  PieHelper)
                PH_OPTS="${PH_OPTS} SANITY" ;;
esac
unset -n PH_OPTS
ph_run_with_rollback -c "ph_remove_app_defaults '${PH_APP}'" || \
	return 1
declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
printf "%8s%s\033[32m%s\033[0m\n" "" "--> Creating ${PH_APP} option defaults in file " "'${PH_CONF_DIR}/options.defaults'"
for PH_i in ${PH_OPTS}
do
        PH_OPT="PH_${PH_APPU}_${PH_i}"
	grep -E "^${PH_OPT}=" "${PH_CONF_DIR}/${PH_APP}.conf" >/dev/null 2>&1 || \
		continue
        case "$PH_i" in PERSISTENT)
		PH_LINE='yes' ;;
			USE_CTRL)
		if [[ "$PH_APP" == @(Emulationstation|Moonlight) ]]
		then
			PH_LINE='yes'
		else
			PH_LINE='no'
		fi ;;
			CIFS_USER)
		PH_LINE='' ;;
			CIFS_DIR)
		PH_LINE='' ;;
			CIFS_SUBDIR)
		PH_LINE='' ;;
			CIFS_SRV)
		PH_LINE='' ;;
			CIFS_PASS)
		PH_LINE='' ;;
			CIFS_SHARE)
		PH_LINE='no' ;;
			NUM_CTRL)
		PH_LINE='1' ;;
			CIFS_MPT)
		PH_LINE="\${PH_MNT_DIR}/${PH_APP}" ;;
			PKG_NAME)
		PH_LINE="${PH_APP_PKG}" ;;
	esac
	case "$PH_APP" in Kodi)
		case "$PH_i" in PRE_CMD)
                	PH_LINE='${PH_SCRIPTS_DIR}/app/pre_cmds/Kodi-PRE.sh' ;;
				POST_CMD)
                	PH_LINE='${PH_SCRIPTS_DIR}/app/post_cmds/Kodi-POST.sh' ;;
				PKG_NAME)
                	PH_LINE='kodi' ;;
		esac ;;
                        Emulationstation)
		case "$PH_i" in CIFS_MPT)
                	PH_LINE='${PH_EMUL_SETUP_DIR}/roms' ;;
				PKG_NAME)
                	PH_LINE='' ;;
		esac ;;
                        Moonlight)
		case "$PH_i" in BITRATE)
                	PH_LINE='20480' ;;
				PCKTSIZE)
                	PH_LINE='1472' ;;
				FPS)
                	PH_LINE=':-1' ;;
				WIDTH)
                	PH_LINE='1920' ;;
				HEIGHT)
                	PH_LINE='1080' ;;
				RES)
                	PH_LINE='1080' ;;
				PKG_NAME)
                	PH_LINE='moonlight' ;;
				CMD_OPTS)
                	PH_LINE="-\${PH_MOON_RES} -bitrate \${PH_MOON_BITRATE} -packetsize \${PH_MOON_PCKTSIZE} -width \${PH_MOON_WIDTH} -height \${PH_MOON_HEIGHT} -app \"\${PH_MOON_GAME}\" -input /dev/input/eventPH_CTRL1 \"\${PH_MOON_SRV}\"" ;;
		esac ;;
                        Bash)
		case "$PH_i" in PKG_NAME)
                	PH_LINE='bash' ;;
		esac ;;
                        X11)
		case "$PH_i" in PKG_NAME)
                	PH_LINE='xinit' ;;
		esac ;;
                        Ctrls)
		case "$PH_i" in MAP)
                	PH_LINE='no' ;;
				PS3_PIN)
                	PH_LINE='0000' ;;
				PS4_PIN)
                	PH_LINE='' ;;
				BLUE_ADAPT)
                	PH_LINE='none' ;;
				TYPE)
                	PH_LINE='PS4' ;;
		esac ;;
                        PieHelper)
		case "$PH_i" in CMD_OPTS)
                	PH_LINE='Main' ;;
				PRE_CMD)
                	PH_LINE='${PH_SCRIPTS_DIR}/app/pre_cmds/PieHelper-PRE.sh' ;;
				POST_CMD)
                	PH_LINE='${PH_SCRIPTS_DIR}/app/post_cmds/PieHelper-POST.sh' ;;
				PKG_NAME)
                	PH_LINE='' ;;
				SANITY)
                	PH_LINE='yes' ;;
		esac ;;
        esac
	unset -n PH_OPTS
	if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/options.defaults' -l '${PH_OPT}:${PH_LINE}'"
	then
		ph_run_with_rollback -c false -m "Could not create" || \
			return 1
	fi
	declare -n PH_OPTS="PH_${PH_APPU}_OPTS"
done
unset -n PH_OPTS
if ! ph_run_with_rollback -c "ph_secure_pieh -q -f '${PH_CONF_DIR}/options.defaults'"
then
	ph_run_with_rollback -c false -m "Could not create" || \
		return 1
fi
ph_add_value_to_param -p PH_REMOVE_APPS_DEFAULTS -v "$PH_APP"
ph_run_with_rollback -c true && \
	return "$?"
}
