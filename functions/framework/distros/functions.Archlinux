# Archlinux-specific codebase

function ph_get_pkg_version {

declare PH_APP_PKG
declare PH_PKG_VERSION

PH_APP_PKG="${1}"
PH_PKG_VERSION=""

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_PKG_VERSION="$("${PH_SUDO}" pacman -Qi "${PH_APP_PKG}" 2>/dev/null | nawk 'tolower($1) ~ /^version$/ { \
		printf $3 ; \
		exit \
	}')"
then
	if [[ -n "${PH_PKG_VERSION}" ]]
	then
		echo -n "${PH_PKG_VERSION}"
	fi
fi
return "${?}
}

function ph_get_pkg_updates {

declare PH_APP_PKG
declare PH_PKG_VERSION
declare PH_PKG_UPDATES
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_QUIESCE

PH_APP_PKG=""
PH_PKG_VERSION=""
PH_PKG_UPDATES=""
PH_OPTION=""
PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_QUIESCE="1"

OPTIND="1"

while getopts :p:q PH_OPTION
do
	case "${PH_OPTION}" in p)
		[[ -n "${PH_APP_PKG}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_PKG="${OPTARG}" ;;
			q)
		[[ "${PH_QUIESCE}" -eq "0" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_QUIESCE="0" ;;
			*)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP_PKG}" || ( "${PH_QUIESCE" -eq "1" && "${#}" -ne "2" ) || \
	( "${PH_QUIESCE" -eq "0" && "${#}" -ne "3" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_PKG_VERSION="$(ph_get_pkg_version "${PH_APP_PKG}")"
then
	if PH_PKG_UPDATES="$("${PH_SUDO}" apt-cache madison "${PH_APP_PKG}" 2>/dev/null | nawk -v vers="^${PH_PKG_VERSION}$" 'BEGIN { \
			i = "0" ; \
		} \
		$3 !~ vers { \
			i++ ; \
			versarr[i] = $3 \
		} END { \
			for (j=1;j<=i;j++) { \
				printf versarr[j] ; \
				if (j<i) { \
					printf " " \
				} ; \
				delete versarr[j] \
			}
		}')"
	then
		if [[ -n "${PH_PKG_UPDATES}" ]]
		then
			if [[ "${PQ_QUIESCE}" -eq "1" ]]
			then
				echo -n "${PH_PKG_UPDATES}"
			fi
			true
		fi
	fi
fi
return "${?}"
}

function ph_get_path_pkg {

declare PH_APP_PATH
declare PH_APP_PKG

PH_APP_PATH="${1}"
PH_APP_PKG=""

[[ "${PH_APP_PATH}" != /* || "${#}" -ne "1" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ph_sync_pkg_db
then
	PH_APP_PKG="$("${PH_SUDO}" pacman -Fx --machinereadable "\(^${PH_APP_PATH}$\)\{1\}" 2>/dev/null | nawk -F '\0' '{ \
			print $2 \
		}')"
	if [[ -n "${PH_APP_PKG}" ]]
	then
		echo -n "${PH_APP_PKG}"
		return 0
	else
		ph_set_result -m "An error occurred trying to determine the package for path '${PH_APP_PATH}'"
	fi
fi
return 1
}

function ph_clean_pkg_db {

[[ "${#}" -ne "0" ]] && \
        ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Cleaning up after package operations"
if "${PH_SUDO}" "${PH_SCRIPTS_DIR}/expect/cleanpmpkgdb.expect" >/dev/null 2>&1
then
	if "${PH_SUDO}" pacman -Rns "$(pacman -Qtdq 2>/dev/null)" --noconfirm >/dev/null 2>&1
	then
		ph_run_with_rollback -c true
	fi
fi
printf "%10s\033[33m%s\033[0m\n" "" "Warning : Failed to cleanup after package operations"
ph_set_result -r 0
return 0
}

function ph_install_pkg {

declare PH_APP_PKG
local -a PH_PKG_UPDATES

PH_APP_PKG="$(ph_resolve_dynamic_value "${1}")"
PH_PKG_UPDATES=()

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking for package " "'${PH_APP_PKG}'"
if ph_get_pkg_inst_state "${PH_APP_PKG}"
then
	if read -r -a PH_PKG_UPDATES -d';' < <(ph_get_pkg_updates "${PH_APP_PKG}"; echo -n ";") 2>/dev/null
	then
	else
		ph_run_with_rollback -c true -m "Nothing to do"
	fi
else
	ph_run_with_rollback -c true -m "Not found"
	printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0m\n" "" "--> Installing package " "'${PH_APP_PKG}'" " (This may take a while)"
	if ! "${PH_SUDO}" pacman -S "${PH_APP_PKG}" --noconfirm >/dev/null 2>&1
	then
		ph_set_result -m "An error occurred trying to install package '${PH_APP_PKG}'"
		ph_run_with_rollback -c false -m "Could not install"
	else
		ph_add_value_to_param -p PH_REMOVE_PKGS -v "${PH_APP_PKG}"
		ph_run_with_rollback -c true
	fi
fi
return "${?}"
}

function ph_sync_pkg_db {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Synchronizing the package database"
if "${PH_SUDO}" pacman -Syy --noconfirm >/dev/null 2>&1
then
	if "${PH_SUDO}" "${PH_EXPECT}" "${PH_SCRIPTS_DIR}/expect/pacman_clean_pkg_db.expect" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true
		return "${?}"
	fi
fi
ph_set_result -m "An error occurred trying to synchronize the package database"
ph_run_with_rollback -c false -m "Could not synchronize"
return "${?}"
}

function ph_update_pkg {

declare PH_APP_PKG

PH_APP_PKG="$(ph_resolve_dynamic_value "${1}")"

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ph_sync_pkg_db
then
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking for package " "'${PH_APP_PKG}'"
	if ph_get_pkg_inst_state "${PH_APP_PKG}"
	then
		ph_run_with_rollback -c true -m "Found"
		ph_run_with_rollback -c "ph_remove_pkg '${PH_APP_PKG}'" || \
			return 1
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
		ph_set_result -r 0
	fi
	ph_run_with_rollback -c "ph_install_pkg '${PH_APP_PKG}'"
fi
return "${?}"
}

function ph_remove_pkg {

declare PH_APP_PKG

PH_APP_PKG="$(ph_resolve_dynamic_value "${1}")"

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking for package " "'${PH_APP_PKG}'"
if ph_get_pkg_inst_state "${PH_APP_PKG}"
then
	ph_run_with_rollback -c true -m "Found"
	printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m\n" "" "--> Uninstalling package " "'${PH_APP_PKG}'" " (This may take a while)"
	if "${PH_SUDO}" pacman -Rs "${PH_APP_PKG}" --noconfirm >/dev/null 2>&1
	then
		if "${PH_SUDO}" pacman -Rns "$(pacman -Qtdq 2>/dev/null)" --noconfirm >/dev/null 2>&1
		then
			ph_add_value_to_param -p PH_INSTALL_PKGS -v "${PH_APP_PKG}"
			ph_run_with_rollback -c true
		fi
	else
		ph_set_result -m "An error occurred trying to uninstall package '${PH_APP_PKG}'"
		ph_run_with_rollback -c false -m "Could not uninstall"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return "${?}"
}

function ph_get_pkg_inst_state {

declare PH_APP_PKG

PH_APP_PKG="$(ph_resolve_dynamic_value "${1}")"

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

"${PH_SUDO}" pacman -Qs "${PH_APP_PKG}" >/dev/null 2>&1
return "${?}"
}

function ph_check_pkg_validity {

declare PH_APP_PKG

PH_APP_PKG="$(ph_resolve_dynamic_value "${1}")"

[[ -z "${PH_APP_PKG}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ph_sync_pkg_db
then
	if ! "${PH_SUDO}" pacman -Ss "${PH_APP_PKG}" --noconfirm >/dev/null 2>&1
	then
		ph_set_result -m "An error occurred since '${PH_APP_PKG}' is not a valid package"
		false
	else
		true
	fi
fi
return "${?}"
}

function ph_update_system {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ph_sync_pkg_db
then
	printf "%8s%s\033[1;37m%s\033[0m\n" "" "--> Updating the system" " (This may take a while)"
	if "${PH_SUDO}" pacman -Su --noconfirm >/dev/null 2>&1
	then
		ph_run_with_rollback -c true
		ph_clean_pkg_db
	else
		ph_set_result -m "At least one of the attempted package operations failed"
		ph_run_with_rollback -c false -m "Could not update"
		ph_clean_pkg_db
		false
	fi
fi
return "${?}"
}
