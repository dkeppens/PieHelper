# PieHelper module declarations not required by the update process (By Davy Keppens on 06/10/18)
# Toggle debugstate of a specific module between Enable/Disable by running 'confpieh_ph.sh -p debug -m module_name'

function ph_check_password_validity {

declare PH_PASSWD

PH_PASSWD="${1}"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -z "${PH_PASSWD}" ]]
then
	ph_set_result -m "Passwords cannot be empty"
else
	if echo "${PH_PASSWD}" 2>/dev/null | grep -E "'|[[:space:]]" >/dev/null
	then
		ph_set_result -m "Passwords may not contain single quote (') or space characters"
	else
		return 0
	fi
fi
return 1
}

function ph_create_oos_app_code {

declare PH_APP
declare -l PH_APPL

PH_APP="${1}"
PH_APPL="${PH_APP:0:3}"

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Adding configure function for application '${PH_APP}' to codebase file '${PH_FUNCS_DIR}/functions.user'"
if ph_check_app_state_validity -a "${PH_APP}" -q -d
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Nothing to do since ${PH_APP} is not an out-of-scope application"
	ph_set_result -r 0
else
	if ! cat >>"${PH_FUNCS_DIR}/functions.user" 2>/dev/null <<EOF

function ph_configure_${PH_APPL} {

## add your code here
return 0
}
EOF
	then
		ph_set_result -m "An error occurred trying to add function 'ph_configure_${PH_APPL}' to codebase file '${PH_FUNCS_DIR}/functions.user'"
		ph_run_with_rollback -c false -c "Could not add" || \
			return 1
	else
		ph_add_value_to_param -p PH_REMOVE_OOS_APPS_CODE -v "${PH_APP}"
		ph_run_with_rollback -c true -m "Configuration code for ${PH_APP} can now be added to '${PH_FUNCS_DIR}/functions.user'"
	fi
fi
return 0
}

function ph_get_app_executable {

declare PH_APP
declare PH_APP_EXEC
declare PH_APP_GRAPH
declare PH_APP_CMD
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_APP_EXEC=""
PH_APP_GRAPH=""
PH_APP_CMD=""
PH_OPTION=""

OPTIND="1"

while getopts :a:c: PH_OPTION
do
	case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP="${OPTARG}" ;;
			     c)
		[[ -n "${PH_APP_CMD}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_CMD="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || ( -n "${PH_APP_CMD}" && "${#}" -ne "4" ) || \
	( -z "${PH_APP_CMD}" && "${#}" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -z "${PH_APP_CMD}" ]]
then
	PH_APP_CMD="$(ph_get_app_cmd_from_app_name "${PH_APP}")"
fi
PH_APP_GRAPH="$(ph_get_app_graphical_prop -a "${PH_APP}" -c "${PH_APP_CMD}")"
PH_APP_EXEC="$(echo -n "${PH_APP_CMD}" | nawk -v app="${PH_APP}" -v appgraph="${PH_APP_GRAPH}" '{ \
		if (appgraph == "yes") { \
			if (app == "X11") { \
				printf $1 \
			} else { \
				printf $2 \
			} \
		} else { \
			printf $1 \
		} \
	}')"
echo -n "${PH_APP_EXEC}"
return 0
}

function ph_get_app_graphical_prop {

declare PH_APP
declare PH_APP_GRAPH
declare PH_APP_CMD
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_APP_GRAPH=""
PH_APP_CMD=""
PH_OPTION=""

OPTIND="1"

while getopts :a:c: PH_OPTION
do
	case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP="${OPTARG}" ;;
			     c)
		[[ -n "${PH_APP_CMD}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_CMD="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || -z "${PH_APP_CMD}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_GRAPH="$(echo -n "${PH_APP_CMD}" | nawk -v app="${PH_APP}" 'BEGIN { \
		graph = "no" \
	} { \
		if (app == "X11") { \
			graph = "yes" \
		} else { \
			if ($1 ~ /^\/usr\/bin\/xinit$/ || $1 ~ /^\/usr\/bin\/startx$/) { \
				graph = "yes" \
			} \
		} \
	} END { \
		printf "%s", graph \
	}')"
echo -n "${PH_APP_GRAPH}"
return 0
}

function ph_remove_oos_app_code {

declare PH_APP
declare -l PH_APPL

PH_APP="${1}"
PH_APPL="${PH_APP:0:3}"

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Removing configure function for application '${PH_APP}' from codebase file '${PH_FUNCS_DIR}/functions.user'"
if ph_check_app_state_validity -a "${PH_APP}" -q -d
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Nothing to do since ${PH_APP} is not an out-of-scope application"
	ph_set_result -r 0
else
	if nawk -v app="_${PH_APPL}$" 'BEGIN {
			flag = "0" 
		}
		$1 ~ /^function$/ && $2 ~ app {
			flag = "1" ;
			while ($1 !~ /^}$/) {
				getline
			} ;
			getline ;
			flag = "0" ;
			next
		} {
			if (flag == 0) {
				print $0
			}
		}' "${PH_FUNCS_DIR}/functions.user" >"${PH_TMP_DIR}/functions_user_tmp" 2>/dev/null
	then
		if mv "${PH_TMP_DIR}/functions_user_tmp" "${PH_FUNCS_DIR}/functions.user" 2>/dev/null
		then
			ph_add_value_to_param -p PH_CREATE_OOS_APPS_CODE -v "${PH_APP}"
			ph_run_with_rollback -c true && \
				return "${?}"
		fi
	fi
fi
"${PH_SUDO}" rm "${PH_TMP_DIR}/functions_user_tmp" 2>/dev/null
ph_set_result -m "An error occurred trying to remove function 'ph_configure_${PH_APPL}' from codebase file '${PH_FUNCS_DIR}/functions.user'"
ph_run_with_rollback -c false -m "Could not remove" || \
	return 1
}

function ph_add_line_to_file {

declare PH_LINE
declare PH_PARAMS
declare PH_FILE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_ADD_AS_ROOT

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_LINE=""
PH_PARAMS=""
PH_FILE=""
PH_ADD_AS_ROOT="1"
PH_OPTION=""

OPTIND="1"

while getopts :l:f:r PH_OPTION
do
	case "${PH_OPTION}" in l)
		[[ -n "${PH_LINE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_LINE="${OPTARG}" ;;
			     f)
		[[ -n "${PH_FILE}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_FILE="${OPTARG}" ;;
			     r)
		[[ -n "${PH_PARAMS}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_PARAMS="-r"
		PH_ADD_AS_ROOT="0" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_FILE}" || "${#}" -lt "4" || ( ! -f "${PH_FILE}" && ! -L "${PH_FILE}" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "${PH_ADD_AS_ROOT}" -eq "0" ]]
then
	if echo -e "${PH_LINE}" 2>/dev/null | "${PH_SUDO}" tee -a "${PH_FILE}" >/dev/null 2>&1
	then
		ph_add_value_to_param -p PH_REMOVE_LINES -v "${PH_FILE}'${PH_PARAMS}'$(echo -e "${PH_LINE}")"
		return 0
	fi
else
	if echo -e "${PH_LINE}" | tee -a "${PH_FILE}" >/dev/null 2>&1
	then
		ph_add_value_to_param -p PH_REMOVE_LINES -v "${PH_FILE}'${PH_PARAMS}'$(echo -e "${PH_LINE}")"
		return 0
	fi
fi
ph_set_result -m "An error occurred trying to add line '${PH_LINE}' to file '${PH_FILE}'"
return 1
}

function ph_remove_line_from_file {

declare PH_LINE_REGEX
declare PH_LINE
declare PH_PARAMS
declare PH_FILE
declare PH_LINK_TARGET
declare PH_TMP_FILE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -i PH_REMOVE_AS_ROOT

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_LINE_REGEX=""
PH_LINE=""
PH_PARAMS=""
PH_FILE=""
PH_LINK_TARGET=""
PH_TMP_FILE=""
PH_COUNT="0"
PH_REMOVE_AS_ROOT="1"
PH_OPTION=""

OPTIND="1"

while getopts :l:f:r PH_OPTION
do
	case "${PH_OPTION}" in l)
		[[ -n "${PH_LINE_REGEX}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_LINE_REGEX="${OPTARG}" ;;
		     f)
		[[ -n "${PH_FILE}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_FILE="${OPTARG}"
		PH_TMP_FILE="${PH_TMP_DIR}/$(sed 's/\./_/g'<<<"${PH_FILE##*/}")_tmp.$(date +'%s%N')" ;;
		     r)
		[[ -n "${PH_PARAMS}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_PARAMS="-r"
		PH_REMOVE_AS_ROOT="0" ;;
		     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_FILE}" || -z "${PH_LINE_REGEX}" || "${#}" -lt "4" || ( ! -f "${PH_FILE}" && ! -L "${PH_FILE}" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_COUNT="$("${PH_SUDO}" grep -P "^${PH_LINE_REGEX}$" "${PH_FILE}" 2>/dev/null | wc -l)"
then
	if PH_LINE="$("${PH_SUDO}" nawk -v comp="${PH_COUNT}" -v line="^${PH_LINE_REGEX}$" 'BEGIN { \
			count = "0" \
		} \
		$0 ~ line { \
			count++ ; \
			if (count != comp) { \
				next \
			} else { \
				print ; \
				exit \
			} \
		}' "${PH_FILE}" 2>/dev/null)"
	then
		if "${PH_SUDO}" nawk -v comp="${PH_COUNT}" -v line="^${PH_LINE_REGEX}$" 'BEGIN { \
				count = "0" \
			} \
			$0 ~ line { \
				count++ ; \
				if (count != comp) { \
					print ; \
					next \
				} else { \
					next \
				} \
			} { \
				print \
			}' "${PH_FILE}" >"${PH_TMP_FILE}" 2>/dev/null
		then
			if [[ "${PH_REMOVE_AS_ROOT}" -eq "0" ]]
			then
				if [[ -f "${PH_FILE}" ]]
				then
					if "${PH_SUDO}" cp --no-preserve=mode,ownership "${PH_TMP_FILE}" "${PH_FILE}" 2>/dev/null
					then
						if "${PH_SUDO}" rm "${PH_TMP_FILE}" 2>/dev/null
						then
							ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"${PH_LINE}")"
							return 0
						fi
					fi
				else
					if PH_LINK_TARGET="$(ph_get_link_target "${PH_FILE}")"
					then
						if "${PH_SUDO}" cp --no-preserve=mode,ownership "${PH_TMP_FILE}" "${PH_LINK_TARGET}" 2>/dev/null
						then
							if "${PH_SUDO}" rm "${PH_TMP_FILE}" 2>/dev/null
							then
								ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"${PH_LINE}")"
								return 0
							fi
						fi
					else
						return 1
					fi
				fi
			else
				if [[ -f "${PH_FILE}" ]]
				then
					if mv "${PH_TMP_FILE}" "${PH_FILE}" 2>/dev/null
					then
						ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"${PH_LINE}")"
						return 0
					fi
				else
					if PH_LINK_TARGET="$(ph_get_link_target "${PH_FILE}")"
					then
						if mv "${PH_TMP_FILE}" "${PH_LINK_TARGET}" 2>/dev/null
						then
							ph_add_value_to_param -p PH_ADD_LINES -v "${PH_FILE}'${PH_PARAMS}'$(sed 's/\t/\\t/g'<<<"${PH_LINE}")"
							return 0
						fi
					else
						return 1
					fi
				fi
			fi
		fi
	fi
fi
ph_set_result -m "An error occurred trying to remove line '${PH_LINE}' from file '${PH_FILE}'"
"${PH_SUDO}" rm "${PH_TMP_FILE}" 2>/dev/null
return 1
}

function ph_git_add_local {

declare PH_GIT_COMMIT_MSG

PH_GIT_COMMIT_MSG="${1}"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Adding build directory " "'${PH_BASE_DIR}'" " to the local git"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if [[ -z "${PH_GIT_COMMIT_MSG}" ]]
	then
		cd - >/dev/null 2>&1
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping the addition since the commit message is empty"
		ph_set_result -r 0
		return 0
	else
		if git add . >/dev/null 2>&1
		then
			cd - >/dev/null 2>&1
			ph_add_value_to_param -p PH_GIT_ADD_LOCAL -v "yes"
			ph_run_with_rollback -c true
			return "${?}"
		else
			ph_set_result -m "An error occurred trying to add build directory '${PH_BASE_DIR}' to the local git"
		fi
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not add"
return "${?}"
}

function ph_undo_git_add_local {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Undoing the latest addition of build directory " "'${PH_BASE_DIR}'" " in the local git"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if git reset >/dev/null 2>&1
	then
		cd - >/dev/null 2>&1
		ph_run_with_rollback -c true
		return "${?}"
	else
		ph_set_result -m "An error occurred trying to undo the latest addition of build directory '${PH_BASE_DIR}' in the local git"
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not undo"
return "${?}"
}

function ph_git_tag_local {

declare PH_NEW_VERSION
declare PH_GIT_COMMIT_MSG
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_NEW_VERSION=""
PH_GIT_COMMIT_MSG=""
PH_OPTION=""

OPTIND="1"

while getopts :v:m: PH_OPTION
do
	case "${PH_OPTION}" in v)
		[[ -n "${PH_NEW_VERSION}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_NEW_VERSION="${OPTARG}" ;;
			     m)
		[[ -n "${PH_GIT_COMMIT_MSG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_COMMIT_MSG="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Tagging the local git build as " "'${PH_NEW_VERSION}'"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if [[ -z "${PH_GIT_COMMIT_MSG}" ]]
	then
		cd - >/dev/null 2>&1
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping the tag since the commit message is empty"
		ph_set_result -r 0
		return 0
	else
		if git tag -a "${PH_NEW_VERSION}" -m "${PH_GIT_COMMIT_MSG}" >/dev/null 2>&1
		then
			cd - >/dev/null 2>&1
			ph_add_value_to_param -p PH_GIT_TAG_LOCAL -v "yes"
			ph_run_with_rollback -c true
			return "${?}"
		else
			ph_set_result -m "An error occurred trying to tag the local git build as '${PH_NEW_VERSION}'"
		fi
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not tag"
return "${?}"
}
 
function ph_undo_git_commit_local {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Undoing the latest commit in the local git"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if git reset --soft HEAD~1 >/dev/null 2>&1
	then
		cd - >/dev/null 2>&1
		ph_run_with_rollback -c true
		return "${?}"
	else
		ph_set_result -m "An error occurred trying to undo the latest commit in the local git"
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not undo"
return "${?}"
}

function ph_git_commit_local {

declare PH_NEW_VERSION
declare PH_GIT_COMMIT_MSG
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_NEW_VERSION=""
PH_GIT_COMMIT_MSG=""
PH_OPTION=""

OPTIND="1"

while getopts :m:v: PH_OPTION
do
	case "${PH_OPTION}" in m)
		[[ -n "${PH_GIT_COMMIT_MSG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_COMMIT_MSG="${OPTARG}" ;;
			     v)
		[[ -n "${PH_NEW_VERSION}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_NEW_VERSION="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Committing build " "'${PH_NEW_VERSION}'" " to the local git"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if [[ -z "${PH_GIT_COMMIT_MSG}" ]]
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping the commit since the commit message is empty"
		ph_set_result -r 0
		cd - >/dev/null 2>&1
		return 0
	else
		if git commit -a --message="${PH_GIT_COMMIT_MSG}" >/dev/null 2>&1
		then
			cd - >/dev/null 2>&1
			ph_add_value_to_param -p PH_GIT_COMMIT_LOCAL -v "yes"
			ph_run_with_rollback -c true
			return "${?}"
		else
			ph_set_result -m "An error occurred trying to commit build '${PH_NEW_VERSION}' to the local git"
		fi
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not commit"
return "${?}"
}

function ph_git_local {

declare PH_NEW_VERSION
declare PH_GIT_COMMIT_MSG
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_NEW_VERSION=""
PH_GIT_COMMIT_MSG=""
PH_OPTION=""

PH_OLD_VERSION="$(git tag -l --points-at HEAD 2>/dev/null)"
PH_OLD_GIT_COMMIT_MSG="$(git log -1 --pretty=%B 2>/dev/null)"
OPTIND="1"

while getopts :m:v: PH_OPTION
do
	case "${PH_OPTION}" in m)
		[[ -n "${PH_GIT_COMMIT_MSG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_COMMIT_MSG="${OPTARG}" ;;
			     v)
		[[ -n "${PH_NEW_VERSION}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_NEW_VERSION="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

ph_run_with_rollback -c "ph_git_add_local '${PH_GIT_COMMIT_MSG}'" || \
	return 1
ph_run_with_rollback -c "ph_git_commit_local -v '${PH_NEW_VERSION}' -m '${PH_GIT_COMMIT_MSG}'" || \
	return 1
ph_run_with_rollback -c "ph_git_tag_local -v '${PH_NEW_VERSION}' -m '${PH_GIT_COMMIT_MSG}'"
return "${?}"
}

function ph_git_clone_master {

declare PH_GIT_REPO_DIR
declare PH_GIT_REPO_NAME
declare PH_GIT_REPO_ARGS
declare PH_GIT_REPO
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_GIT_REPO_DIR=""
PH_GIT_REPO_NAME=""
PH_GIT_REPO_ARGS=""
PH_GIT_REPO=""
PH_OPTION=""

OPTIND="1"

while getopts :d:r:n:a: PH_OPTION
do
	case "${PH_OPTION}" in d)
		[[ -n "${PH_GIT_REPO_DIR}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_DIR="${OPTARG}" ;;
			     n)
		[[ -n "${PH_GIT_REPO_NAME}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_NAME="${OPTARG}" ;;
			     a)
		[[ -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_ARGS="${OPTARG}" ;;
			     r)
		[[ -n "${PH_GIT_REPO}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_GIT_REPO_DIR}" || -z "${PH_GIT_REPO}" || -z "${PH_GIT_REPO_NAME}" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -d "${PH_GIT_REPO_DIR}" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -t directory -d '${PH_GIT_REPO_DIR}'" || \
		return 1
fi
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Cloning master git repository " "'${PH_GIT_REPO}'"
if cd "${PH_GIT_REPO_DIR}" >/dev/null 2>&1
then
	if git clone ${PH_GIT_REPO_ARGS} "${PH_GIT_REPO}" >/dev/null 2>&1
	then
		cd - >/dev/null 2>&1
		ph_add_value_to_param -p PH_GIT_UNDO_CLONE_MASTER -v "${PH_GIT_REPO_DIR}'${PH_GIT_REPO}'${PH_GIT_REPO_NAME}'${PH_GIT_REPO_ARGS}"
		ph_run_with_rollback -c true
		return "${?}"
	else
		ph_set_result -m "An error occurred trying to clone master git repository '${PH_GIT_REPO}'"
	fi
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${GIT_REPO_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not clone"
return "${?}"
}

function ph_git_undo_clone_master {

declare PH_GIT_REPO
declare PH_GIT_REPO_ARGS
declare PH_GIT_REPO_DIR
declare PH_GIT_REPO_NAME
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_GIT_REPO=""
PH_GIT_REPO_ARGS=""
PH_GIT_REPO_DIR=""
PH_GIT_REPO_NAME=""
PH_OPTION=""

OPTIND="1"

while getopts :d:n:r:a: PH_OPTION
do
	case "${PH_OPTION}" in d)
		[[ -n "${PH_GIT_REPO_DIR}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_DIR="${OPTARG}" ;;
			     r)
		[[ -n "${PH_GIT_REPO}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO="${OPTARG}" ;;
			     a)
		[[ -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_ARGS="${OPTARG}" ;;
			     n)
		[[ -n "${PH_GIT_REPO_NAME}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_REPO_NAME="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_GIT_REPO_DIR}" || -z "${PH_GIT_REPO}" || -z "${PH_GIT_REPO_NAME}" || \
	( -e "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" && ! -d "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Removing cloned git repository " "'${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}'"
if [[ ! -e "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" ]]
then
	ph_run_with_rollback -c true -m "Nothing to do"
else
	if "${PH_SUDO}" rm -r "${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}" 2>/dev/null
	then
		ph_add_value_to_param -p PH_GIT_CLONE_MASTER -v "${PH_GIT_REPO_DIR}'${PH_GIT_REPO}'${PH_GIT_REPO_NAME}'${PH_GIT_REPO_ARGS}"
		ph_run_with_rollback -c true
	else
		ph_set_result -m "An error occurred trying to remove cloned git repository '${PH_GIT_REPO_DIR}/${PH_GIT_REPO_NAME}'"
		ph_run_with_rollback -c false -m "Could not remove"
	fi
fi
return "${?}"
}

function ph_git_commit_master {

declare PH_NEW_VERSION
declare PH_GIT_COMMIT_MSG
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_NEW_VERSION=""
PH_GIT_COMMIT_MSG=""
PH_OPTION=""

OPTIND="1"

while getopts :v:m: PH_OPTION
do
	case "${PH_OPTION}" in v)
		[[ -n "${PH_NEW_VERSION}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_NEW_VERSION="${OPTARG}" ;;
			     m)
		[[ -n "${PH_GIT_COMMIT_MSG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_COMMIT_MSG="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Committing build " "'${PH_NEW_VERSION}'" " to the master git repository"
if cd "${PH_BASE_DIR}" >/dev/null 2>&1
then
	if [[ -z "${PH_GIT_COMMIT_MSG}" ]]
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping the commit since the commit message is empty"
		ph_set_result -r 0
		cd - >/dev/null 2>&1
		return 0
	else
		if git push --mirror >/dev/null 2>&1
		then
			cd - >/dev/null 2>&1
			ph_add_value_to_param -p PH_GIT_COMMIT_MASTER -v "yes"
			ph_run_with_rollback -c true
			return "${?}"
		fi
	fi
	ph_set_result -m "An error occurred trying to commit build '${PH_NEW_VERSION}' to the master git repository"
	cd - >/dev/null 2>&1
else
	ph_set_result -m "An error occurred trying to change directory to '${PH_BASE_DIR}'"
fi
ph_run_with_rollback -c false -m "Could not commit"
return "${?}"
}

function ph_git_master {

declare PH_NEW_VERSION
declare PH_GIT_COMMIT_MSG
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_NEW_VERSION=""
PH_GIT_COMMIT_MSG=""
PH_OPTION=""

OPTIND="1"

while getopts :v:m: PH_OPTION
do
	case "${PH_OPTION}" in v)
		[[ -n "${PH_NEW_VERSION}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_NEW_VERSION="${OPTARG}" ;;
			     m)
		[[ -n "${PH_GIT_COMMIT_MSG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_GIT_COMMIT_MSG="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

ph_run_with_rollback -c "ph_git_commit_master -v '${PH_NEW_VERSION}' -m '${PH_GIT_COMMIT_MSG}'"
return "${?}"
}

function ph_get_app_state_from_app_name {

declare PH_APP
declare PH_APP_STATE

PH_APP="${1}"
PH_APP_STATE=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_STATE="$(ph_check_app_state_validity -a "${PH_APP}" -q -f -u)"
echo -n "${PH_APP_STATE}"
return "${?}"
}

function ph_check_pieh_shared_config {

declare PH_i
declare PH_DIR
declare PH_SUFFIX
declare -a PH_DEFAULT_APPS

PH_i=""
PH_DIR=""
PH_SUFFIX=""

[[ "${#}" -ne "0" ]] && \
	unset PH_DEFAULT_APPS && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_DEFAULT_APPS+=($(ph_get_app_list_by_state -s Default -t minimum))
for PH_i in "${PH_SCRIPTS_DIR}" "${PH_BUILD_DIR}" "${PH_SNAPSHOT_DIR}" "${PH_MNT_DIR}" "${PH_EXCLUDES_DIR}" \
	"${PH_CONF_DIR}" "${PH_TMP_DIR}" "${PH_FILES_DIR}" "${PH_MENUS_DIR}" "${PH_TEMPLATES_DIR}" \
	HOWTO VERSION VERSIONS kodi.excludes tar.excludes default_apps_GL default_apps_X \
	Support System Main PS3 PS4 XBOX360 XBOXSX SystemRetained SystemInteractive SystemRetaineds \
	Controllers OOSapp "${PH_DEFAULT_APPS[@]}" "${PH_CHECK_SUPPORTED[@]}" \
	MovefromPieHScript LoginScript MoveScript MovetoPieHScript RestartScriptPieH \
	RestartScript StartScriptPieH StartScript StopScriptPieH StopScript \
	confapps confpieh confttys confgena confctrl confoper confopts listblue listmoon \
	setpasswd.expect confctrls.expect functions.$(sed 's/ / functions./g'<<<"${PH_SUPPORTED_DISTROS[*]}")
do
	PH_DIR=""
	PH_SUFFIX=""
	case "${PH_i}" in Support|System*|Main|PS*|XBOX*)
		PH_DIR="${PH_MENUS_DIR}/"
		PH_SUFFIX=".lst" ;;
			Controllers|OOSapp|`sed 's/ /|/g'<<<"${PH_DEFAULT_APPS[*]}"`)
		PH_DIR="${PH_TEMPLATES_DIR}/"
		PH_SUFFIX="_conf.template" ;;
			*Script|*PieH)
		PH_DIR="${PH_TEMPLATES_DIR}/"
		PH_SUFFIX=".template" ;;
			conf*|list*)
		PH_DIR="${PH_SCRIPTS_DIR}/"
		PH_SUFFIX="_ph.sh" ;;
			`sed 's/ /|/g'<<<"${PH_CHECK_SUPPPORTED[*]}"`)
		PH_DIR="${PH_CONF_DIR}/distros/"
		PH_SUFFIX=".conf" ;;
			*.excludes)
		PH_DIR="${PH_EXCLUDES_DIR}/" ;;
			default_apps_*|VERSIONS)
		PH_DIR="${PH_FILES_DIR}/" ;;
			VERSION)
		PH_DIR="${PH_CONF_DIR}/" ;;
			*.expect)
		PH_DIR="${PH_SCRIPTS_DIR}/app/expect/" ;;
			functions.*)
		PH_DIR="${PH_FUNCS_DIR}/distros/" ;;
			HOWTO)
		PH_DIR="${PH_BASE_DIR}/" ;;
			*)
		: ;;
	esac
	if ! ph_check_object_existence -q -o "${PH_DIR}${PH_i}${PH_SUFFIX}"
	then
		ph_show_result
		exit "${?}"
        fi
done
unset PH_DEFAULT_APPS
return 0
}

function ph_check_pieh_configured_config {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_GROUP
declare PH_APP_STR_TTY
declare PH_APPU_CIFS_MPT
declare -i PH_RET_CODE
declare -u PH_APPU
declare -l PH_APPL
declare -a PH_CIFS_MPTS

PH_i=""
PH_APP=""
PH_APP_USER=""
PH_APP_GROUP=""
PH_APP_STR_TTY=""
PH_APPU_CIFS_MPT=""
PH_RET_CODE="0"
PH_APPU=""
PH_APPL=""

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%2s%s\n\n" "" "While PieHelper is configured :" >>"${PH_TMP_DIR}/.reported_issues"
for PH_i in sup int cont os defaults alloweds
do
	ph_check_base_conf_file_validity "${PH_i}" || \
		PH_RET_CODE="1"
done
if [[ ! -f /etc/profile.d/PieHelper-path.sh ]]
then
        printf "%4s%s\033[1;33m%s\033[0m%s\n" "" "- The PATH and LD_LIBRARY_PATH extension " "'/etc/profile.d/PieHelper-path.sh'" " is missing" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
else
	if [[ "$("${PH_SUDO}" find /etc/profile.d/PieHelper-path.sh -exec ls -l {} \; 2>/dev/null | nawk '{ \
			print $3 \
		}')" != "root" ]]
	then
		printf "%4s%s\n" "" "- The PATH and LD_LIBRARY_PATH extension '/etc/profile.d/PieHelper-path.sh' has a corrupted value for ownership -> Fix by running '${PH_SUDO} chown root:root /etc/profile.d/PieHelper-path.sh'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
fi
if [[ ! -L "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" && "${PH_DISTRO}" == "Debian" ]]
then
        printf "%4s%s\n" "" "- ${PH_DISTRO} release symbolic link is missing" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
fi
if [[ -f "${PH_TMP_DIR}/.auto_update_denied" ]]
then
        printf "%4s%s\n" "" "- File '${PH_TMP_DIR}/.auto_update_denied' is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
fi
for PH_APP in Controllers $(ph_get_app_list_by_state -s Supported -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	if ! ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_APP}.conf"
	then
       		printf "%4s%s\n" "" "- Supported application ${PH_APP} configuration file '${PH_APP}.conf' is missing" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
	for PH_i in "StatusManagement_${PH_APP}" "OptionsManagement_${PH_APP}" "TTYManagement_${PH_APP}" "${PH_APP}"
	do
		[[ "${PH_i}" == "TTYManagement_${PH_APP}" && "${PH_APP}" == "Controllers" ]] && \
			continue
		if ! ph_check_object_existence -q -o "${PH_MENUS_DIR}/${PH_i}.lst"
		then
       		 	printf "%4s%s\n" "" "- Integrated application ${PH_APP} menu item '${PH_i}.lst' is missing" >>"${PH_TMP_DIR}/.reported_issues"
			PH_RET_CODE="1"
		fi
	done
	for PH_i in alloweds defaults
	do
		if ph_check_object_existence -q -o "${PH_CONF_DIR}/options.${PH_i}"
		then
			if ! grep -E "^PH_${PH_APPU}_" "${PH_CONF_DIR}/options.${PH_i}" >/dev/null 2>&1
			then
       				printf "%4s%s\n" "" "- Supported application ${PH_APP} ${PH_i%?} option values are missing" >>"${PH_TMP_DIR}/.reported_issues"
				PH_RET_CODE="1"
			fi
		fi
	done
done
read -r -a PH_CIFS_MPTS -d';' < <("${PH_SUDO}" find "${PH_MNT_DIR}/*" -maxdepth 1 -type d -exec basename {} \; 2>/dev/null; echo -n ';')
for PH_APP in "${PH_CIFS_MPTS[@]}"
do
	if ! cut -f1 "${PH_CONF_DIR}/integrated_apps" 2>&1 | grep -E "^${PH_APP}$" >/dev/null
	then
        	printf "%4s%s\n" "" "- The default CIFS mountpoint '${PH_MNT_DIR}/${PH_APP}' of '$(ph_get_app_state_from_app_name -a ${PH_APP})' application '${PH_APP}' is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
done
unset PH_CIFS_MPTS
for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	PH_APPU_CIFS_MPT="$(ph_get_app_cifs_mpt -a "${PH_APP}" -r)"
	if ! cut -f1 "${PH_CONF_DIR}/supported_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
	then
        	printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing an entry in configuration file '${PH_CONF_DIR}/supported_apps'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
	if [[ -n "${PH_APPU_CIFS_MPT}" && ! -d "${PH_APPU_CIFS_MPT}" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing CIFS mountpoint '${PH_APPU_CIFS_MPT}'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
done
for PH_APP in $(ph_get_app_list_by_state -s Halted -t exact)
do
	PH_APPL="${PH_APP:0:4}"
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
	if [[ ! -f "/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing LoginScript '/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
	if [[ ! -f "/etc/systemd/system/getty@tty${PH_APP_STR_TTY}.service.d/autologin.conf" ]]
	then
        	printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing autologin configuration '/etc/systemd/system/getty@tty${PH_APP_STR_TTY}.service.d/autologin.conf'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
	for PH_i in $(nawk -v app="^${PH_APP}$" -v appl="${PH_APPL}" -v scriptsdir="${PH_SCRIPTS_DIR}" 'BEGIN { \
			ORS = " " \
		} \
		$1 !~ app { \
			appl2 = tolower(substr($1,1,4)) ; \
			print scriptsdir "/" appl "to" appl2 ".sh " scriptsdir "/" appl2 "to" appl ".sh " \
		} END { \
			print scriptsdir "/start" appl ".sh " scriptsdir "/stop" appl ".sh " scriptsdir "/restart" appl ".sh" \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
	do
		if [[ ! -f "${PH_i}" ]]
		then
        		printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing management script '${PH_i}'" >>"${PH_TMP_DIR}/.reported_issues"
			PH_RET_CODE="1"
		else
			if [[ ! -x "${PH_i}" ]]
			then
        			printf "%4s%s\n" "" "- Integrated application '${PH_APP}' is missing execute permission for management script '${PH_i}'" >>"${PH_TMP_DIR}/.reported_issues"
				PH_RET_CODE="1"
			fi
		fi
	done
done
for ((PH_APP_STR_TTY=2;PH_APP_STR_TTY<="${PH_PIEH_MAX_TTYS}";PH_APP_STR_TTY++))
do
	if cut -f2 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_STR_TTY}$" >/dev/null
	then
		PH_APP="$(ph_get_app_name_from_app_tty "${PH_APP_STR_TTY}")"
		PH_APPL="${PH_APP:0:4}"
		PH_APP_USER="$(ph_get_app_user_from_app_tty "${PH_APP_STR_TTY}")"
		if [[ -f "/etc/systemd/system/getty@tty${PH_APP_STR_TTY}.service.d/autologin.conf" ]]
		then
			if cut -f2 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_STR_TTY}$" >/dev/null
			then
				if [[ "$(ph_get_app_user_from_autologin "${PH_APP_STR_TTY}")" != "${PH_APP_USER}" ]]
				then
					printf "%4s%s\n" "" "- Autologin for 'tty${PH_APP_STR_TTY}' has a corrupted value for PH_APP_USER -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
				if [[ "${PH_APP_STR_TTY}" -ne "$(ph_get_app_tty_from_autologin "${PH_APP_STR_TTY}")" ]]
				then
					printf "%4s%s\n" "" "- Autologin for 'tty${PH_APP_STR_TTY}' has a corrupted value for PH_APP_TTY -> Should be '${PH_APP_STR_TTY}'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
			else
				printf "%4s%s\n" "" "- Autologin configuration for 'tty${PH_APP_STR_TTY}' is present while tty${PH_APP_STR_TTY} is unallocated" >>"${PH_TMP_DIR}/.reported_issues"
				PH_RET_CODE="1"
			fi
		fi
		if [[ -f "/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh" ]]
		then
			if cut -f2 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_STR_TTY}$" >/dev/null
			then
				if [[ "$(ph_get_app_user_from_login_script_owner "${PH_APP_STR_TTY}")" != "${PH_APP_USER}" ]]
				then
					printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_STR_TTY}' has a corrupted value for ownership -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
				if [[ "$(ph_get_app_user_from_login_script "${PH_APP_STR_TTY}")" != "${PH_APP_USER}" ]]
				then
					printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_STR_TTY}' has a corrupted value for PH_APP_USER -> Should be '${PH_APP_USER}'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
				if [[ "$(ph_get_app_tty_from_login_script "${PH_APP_STR_TTY}")" -ne "${PH_APP_STR_TTY}" ]]
				then
					printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_STR_TTY}' has a corrupted value for PH_APP_TTY -> Should be 'tty${PH_APP_STR_TTY}'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
				if [[ "$(ph_get_app_name_from_login_script "${PH_APP_STR_TTY}")" != "${PH_APP}" ]]
				then
					printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_STR_TTY}' has a corrupted value for PH_APP_CMD -> Should be '${PH_SCRIPTS_DIR}/start${PH_APPL}.sh'" >>"${PH_TMP_DIR}/.reported_issues"
					PH_RET_CODE="1"
				fi
			else
				printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_STR_TTY}' is present while tty${PH_APP_STR_TTY} is unallocated" >>"${PH_TMP_DIR}/.reported_issues"
				PH_RET_CODE="1"
			fi
		fi
	fi
done
if [[ -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
	PH_APP_STR_TTY="$(nawk '$0 ~ /^ExecStartPost=\+\/bin\/chvt/ { \
			printf $2 \
		}' /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null)"
	PH_APP="$(ph_get_app_name_from_app_tty "${PH_APP_STR_TTY}")"
	if [[ "${PH_PIEH_STARTAPP}" == "none" ]]
	then
        	printf "%4s%s\n" "" "- 'tty1' StartApp configuration is present while PH_PIEH_STARTAPP is set to 'none'" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	else
		if [[ "${PH_PIEH_STARTAPP}" != "${PH_APP}" ]]
		then
        		printf "%4s%s\n" "" "- 'tty1' StartApp configuration is for ${PH_APP} while PH_PIEH_STARTAPP is set to '${PH_PIEH_STARTAPP}'" >>"${PH_TMP_DIR}/.reported_issues"
			PH_RET_CODE="1"
		fi
	fi
else
	if [[ "${PH_PIEH_STARTAPP}" != "none" ]]
	then
        	printf "%4s%s\n" "" "- PH_PIEH_STARTAPP is set to '${PH_PIEH_STARTAPP}' while 'tty1' StartApp configuration is missing" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
fi
if [[ "${PH_RET_CODE}" -ne "0" ]]
then
	if [[ -f "${PH_TMP_DIR}/.first_run" ]]
	then
		printf "%4s%s\n" "" "- File '${PH_TMP_DIR}/.first_run' is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
else
	"${PH_SUDO}" rm "${PH_TMP_DIR}/.reported_issues" 2>/dev/null
fi
return "${PH_RET_CODE}"
}

function ph_check_base_conf_file_validity {

declare PH_i
declare PH_APP
declare PH_FILE
declare PH_FILE_SHORTNAME

PH_i=""
PH_APP=""
PH_FILE=""
PH_FILE_SHORTNAME="${1}"

[[ "${PH_FILE_SHORTNAME}" != @(sup|int|cont|os|@(default|allowed)s) || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_FILE="$(ph_get_filename_from_shortname "${PH_FILE_SHORTNAME}")"
if ! ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_FILE}"
then
	printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is missing" >>"${PH_TMP_DIR}/.reported_issues"
	return 1
fi
if [[ "${PH_i}" == @(sup|int) ]]
then
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if [[ "$(nawk -v app="^${PH_APP}$"$ 'BEGIN { \
				count = "0" \
			} \
			$1 ~ app { \
				count++ \
			} END { \
				printf count \
			}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)" -gt "1" ]]
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is corrupted -> Multiple instances of '${PH_APP}'" >>"${PH_TMP_DIR}/.reported_issues"
			return 1
		fi
	done
fi
case "${PH_i}" in cont)
	: ;;
		os)
	: ;;
		defaults)
	: ;;
		alloweds)
	: ;;
		sup)
	if ! ph_check_app_state_validity -a PieHelper -q -s
	then
        	printf "%4s%s\n" "" "- PieHelper is not a supported application" >>"${PH_TMP_DIR}/.reported_issues"
		return 1
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if ! ph_check_app_support_data_validity "${PH_APP}"
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' has corrupted data for ${PH_APP}" >>"${PH_TMP_DIR}/.reported_issues"
			return 1
		fi
	done ;;
		int)
	if ! ph_check_app_state_validity -a PieHelper -q -i
	then
        	printf "%4s%s\n" "" "- PieHelper is not an integrated application" >>"${PH_TMP_DIR}/.reported_issues"
		return 1
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)
	do
		if ! ph_check_app_integration_data_validity "${PH_APP}"
		then
			printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' has corrupted data for ${PH_APP}" >>"${PH_TMP_DIR}/.reported_issues"
			return 1
		fi
	done ;;
esac
## add syntax check for OS.defaults, controller_cli_ids and both option files
return 0
}

function ph_check_pieh_unconfigured_config {

declare PH_i
declare PH_APP
declare PH_FILE
declare -i PH_APP_TTY
declare -i PH_RET_CODE

PH_i=""
PH_APP=""
PH_FILE=""
PH_APP_TTY="0"
PH_RET_CODE="0"

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%2s%s\n\n" "" "While PieHelper is unconfigured :" >>"${PH_TMP_DIR}/.reported_issues"
for PH_i in sup int cont os defaults alloweds
do
	ph_check_default_base_conf_file_validity "${PH_i}" || \
		PH_RET_CODE="1"
done
if [[ -f /etc/profile.d/PieHelper-path.sh ]]
then
        printf "%4s%s\n" "" "- The PATH and LD_LIBRARY_PATH extension " "'/etc/profile.d/PieHelper-path.sh'" " is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
fi
if [[ "${PH_DISTRO}" == "Debian" ]]
then
	if ph_check_object_existence -q -o "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf"
	then
		printf "%4s%s\n" "" "- ${PH_DISTRO} release symbolic link is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
fi
for PH_i in Controllers $(ph_get_app_list_by_state -s Default -t minimum)
do
	if ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_i}.conf"
	then
		printf "%4s%s\n" "" "- Configuration file '${PH_CONF_DIR}/${PH_i}.conf' is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
	fi
done
for PH_i in $("${PH_SUDO}" ls "${PH_MENUS_DIR}/"!(@(System|SystemRetaineds|SystemRetained|SystemInteractive|Support|PS3|PS4|XBOX360|XBOXSX|Main).lst) 2>/dev/null | \
	nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print $1 \
	}')
do
       	printf "%4s%s\n" "" "- Menu item '${PH_i##*/}' is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
done
for PH_i in $("${PH_SUDO}" find "${PH_MNT_DIR}/*" -type d -mount 2>/dev/null | nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print \
	}')
do
	PH_APP="${PH_i##*/}"
       	printf "%4s%s\n" "" "- Default CIFS mountpoint '${PH_MNT_DIR}/${PH_APP}' is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
done
for PH_i in $("${PH_SUDO}" find "${PH_SCRIPTS_DIR}" -maxdepth 1 -type f -regextype egrep ! -regex ".*/(start|stop|restart|.*_ph).*\.sh" -print 2>/dev/null | nawk 'BEGIN { \
		ORS =  " " \
	} { \
		print $1 \
	}')
do
       	printf "%4s%s\n" "" "- Management script '${PH_i##*/}' is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
done
for ((PH_APP_TTY=2;PH_APP_TTY<="${PH_PIEH_MAX_TTYS}";PH_APP_TTY++))
do
        if [[ -f "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" ]]
        then
                printf "%4s%s\n" "" "- LoginScript for 'tty${PH_APP_TTY}' is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
        fi
        if [[ -f "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf" ]]
        then
                printf "%4s%s\n" "" "- Autologin configuration for 'tty${PH_APP_TTY}' is present" >>"${PH_TMP_DIR}/.reported_issues"
		PH_RET_CODE="1"
        fi
done
if [[ -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
        printf "%4s%s\n" "" "- StartApp configuration for 'tty1' is present" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
fi
if [[ ! -f "${PH_TMP_DIR}/.first_run" ]]
then
	printf "%4s%s\n" "" "- Temporary file '${PH_TMP_DIR}/.first_run' is missing" >>"${PH_TMP_DIR}/.reported_issues"
	PH_RET_CODE="1"
fi
[[ "${PH_RET_CODE}" -eq "0" ]] && \
	"${PH_SUDO}" rm "${PH_TMP_DIR}/.reported_issues" 2>/dev/null
return "${PH_RET_CODE}"
}

function ph_show_app_info {

declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_APP_PKG
declare PH_APP_STATE
declare PH_APP_INST_STATE
declare PH_APP_STR_TTY
declare -u PH_APPU
declare -n PH_APP_PERSISTENCE

PH_APP="${1}"
PH_APP_USER="$(ph_get_app_user_from_app_name "${PH_APP}")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "${PH_APP}")"
PH_APP_PKG="$(ph_get_app_pkg_from_app_name "${PH_APP}")"
PH_APP_STATE="$(ph_get_app_state_from_app_name "${PH_APP}")"
PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "${PH_APP}")"
PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
PH_APPU="${PH_APP:0:4}"
PH_APP_PERSISTENCE="PH_${PH_APPU}_PERSISTENT"

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	unset -n PH_APP_PERSISTENCE && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "${PH_APP_USER}" ]] && \
	PH_APP_USER="-"
[[ -z "${PH_APP_PKG}" ]] && \
	PH_APP_PKG="-"
printf "\n%10s\033[1;37m%-20s\033[33m%s\n" "" "App name" ": ${PH_APP}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App tty" ": ${PH_APP_STR_TTY}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App run account" ": ${PH_APP_USER}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App start command" ": ${PH_APP_CMD}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App state" ": ${PH_APP_STATE}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App package name" ": ${PH_APP_PKG}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App install state" ": ${PH_APP_INST_STATE}"
printf "%10s\033[37m%-20s\033[33m%s\n" "" "App persistence" ": $(cut -c1<<<"${PH_APP_PERSISTENCE}" | tr "[:lower:]" "[:upper:]")$(cut -c2-<<<"${PH_APP_PERSISTENCE}")"
if [[ "${PH_APP}" == "PieHelper" && "${PH_APP_STATE}" == "Running" && "$(ph_get_app_environment "${PH_APP}")" == "pts" ]]
then
	PH_APP_STATE="Yes"
else
	PH_APP_STATE="No"
fi
printf "%10s\033[37m%-20s\033[33m%s\033[0m\n" "" "Active on pts" ": ${PH_APP_STATE}"
unset -n PH_APP_PERSISTENCE
return 0
}

function ph_allocate_new_tty {

declare PH_APP
declare PH_APP_STR_TTY

PH_APP="${1}"
PH_APP_STR_TTY=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Allocating the first free tty to ${PH_APP}"
if [[ "${PH_APP}" == "PieHelper" ]]
then
	PH_APP_STR_TTY="2"
else
	for ((PH_APP_STR_TTY=3;PH_APP_STR_TTY<="$((PH_PIEH_MAX_TTYS+1))";PH_APP_STR_TTY++))
	do
		if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_STR_TTY}$" >/dev/null
		then
			continue
		fi
		break
	done
	if [[ "${PH_APP_STR_TTY}" -eq "$((PH_PIEH_MAX_TTYS+1))" ]]
	then
		ph_set_result -m "Could not allocate a tty to ${PH_APP} since the maximum number of $((PH_PIEH_MAX_TTYS-1)) ttys has been allocated"
		ph_run_with_rollback -c false -m "Could not allocate" || \
			return 1
	fi
fi
ph_run_with_rollback -c true -m "tty${PH_APP_STR_TTY}"
return "${PH_APP_STR_TTY}"
}

function ph_check_object_existence {

declare PH_DIR
declare PH_FILE
declare PH_TYPE
declare PH_OBJECT
declare PH_OBJECT_TYPE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_QUIESCE
declare -i PH_CHECK_FLAG

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_DIR=""
PH_FILE=""
PH_TYPE="Unique"
PH_OBJECT=""
PH_OBJECT_TYPE="configuration file"
PH_OPTION=""
PH_QUIESCE="1"
PH_CHECK_FLAG="1"

OPTIND="1"

while getopts :o:q PH_OPTION
do
	case "${PH_OPTION}" in o)
		[[ -n "${PH_OBJECT}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_OBJECT="${OPTARG}" ;;
			     q)
		[[ "${PH_QUIESCE}" -eq "0" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_QUIESCE="0" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_OBJECT}" || ( "${#}" -ne "2" && "${PH_QUIESCE}" -eq "1" ) || \
	( "${#}" -ne "3" && "${PH_QUIESCE}" -eq "0" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_DIR="${PH_OBJECT%/*}"
PH_FILE="${PH_OBJECT##*/}"
if [[ -d "${PH_OBJECT}" ]]
then
	PH_OBJECT_TYPE="directory"
else
	if [[ "${PH_OBJECT}" == @(sup|int|cont|os|@(default|allowed)s) ]]
	then
		PH_DIR="${PH_CONF_DIR}"
		PH_FILE="$(ph_get_filename_from_shortname "${PH_OBJECT}")"
	else
   	    	case "${PH_OBJECT}" in */TTYManagement.lst|*/OptionsManagement.lst|*/StatusManagement.lst)
			PH_TYPE="Generated"
			PH_OBJECT_TYPE="link" ;;
				*/Main.lst|*/PS3.lst|*/PS4.lst|*/Support.lst|*/XBOX360.lst|*/XBOXSX.lst)
			PH_OBJECT_TYPE="menu item" ;;
				*/System.lst|*/SystemInteractive.lst|*/SystemRetained.lst|*/SystemRetaineds.lst)
			PH_OBJECT_TYPE="menu item" ;;
				*/*.lst)
			PH_TYPE="Generated"
			PH_OBJECT_TYPE="menu item" ;;
				*/listblue_ph.sh|*/listmoon_ph.sh)
			PH_OBJECT_TYPE="script" ;;
				*/confapps_ph.sh|*/confctrl_ph.sh|*/confgena_ph.sh|*/confoper_ph.sh|*/confttys_ph.sh|*/confpieh_ph.sh)
			PH_OBJECT_TYPE="script" ;;
				*/*.sh)
			PH_TYPE="Generated"
			PH_OBJECT_TYPE="management script" ;;
				*/*.template)
			PH_OBJECT_TYPE="template" ;;
				*/.gitignore|*/.first_run|*/.auto_update_denied|*/HOWTO)
			PH_OBJECT_TYPE="file" ;;
				*/.configure_in_progress|*/.unconfigure_in_progress|*/TODO|*/INSTALL|*/README.md|*/CODE_OF_CONDUCT.md|*/LICENSE)
			PH_OBJECT_TYPE="file"
			PH_TYPE="Optional" ;;
				*/*.expect)
			PH_OBJECT_TYPE="expect script" ;;
				*/functions.user)
			PH_TYPE="Generated"
			PH_OBJECT_TYPE="codebase file" ;;
				*/functions.*)
			PH_OBJECT_TYPE="codebase file" ;;
				*/*.excludes)
			PH_OBJECT_TYPE="tar excludefile" ;;
				*/distros/*.conf)
			for PH_i in "${PH_CHECK_SUPPORTED[@]}"
			do
				if [[ "${PH_FILE%.conf}" == "${PH_i}" ]]
				then
					PH_CHECK_FLAG="0"
					break
				fi
			done
			if [[ "${PH_CHECK_FLAG}" -eq "1" ]]
			then
				PH_OBJECT_TYPE="link"
				PH_TYPE="Generated"
			fi ;;
				"${PH_CONF_DIR}/"*.conf)
			PH_TYPE="Generated" ;;
				*)
			: ;;
       		esac
	fi
fi
[[ "${PH_QUIESCE}" -eq "1" ]] && \
	printf "%8s%s\n" "" "--> Checking ${PH_OBJECT_TYPE} '${PH_DIR}/${PH_FILE}'"
if [[ ! ( -f "${PH_DIR}/${PH_FILE}" && "${PH_OBJECT_TYPE}" != @(directory|link) ) && \
	! ( -d "${PH_DIR}/${PH_FILE}" && "${PH_OBJECT_TYPE}" == "directory" ) && \
	! ( -L "${PH_DIR}/${PH_FILE}" && "${PH_OBJECT_TYPE}" == "link" ) ]]
then
	if [[ "${PH_QUIESCE}" -eq "1" ]]
	then
		if [[ "${PH_TYPE}" == "Unique" ]]
		then
			printf "%10s\033[1;31m%s\033[0m%s\n" "" "ERROR : " "Not found"
			ph_set_result -r 1
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
			ph_set_result -r 0
		fi
	fi
	return 1
fi
if [[ "${PH_QUIESCE}" -eq "1" ]]
then
	ph_run_with_rollback -c true -m "Found"
fi
return 0
}

function ph_check_default_base_conf_file_validity {

declare PH_FILE
declare PH_FILE_SHORTNAME

PH_FILE=""
PH_FILE_SHORTNAME="${1}"

[[ "${PH_FILE_SHORTNAME}" != @(cont|os|sup|int|@(default|allowed)s) || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_FILE="$(ph_get_filename_from_shortname "${PH_FILE_SHORTNAME}")"
if ph_check_object_existence -q -o "${PH_CONF_DIR}/${PH_FILE}"
then
	printf "%4s%s\n" "" "- Unique configuration file '${PH_FILE}' is present" >>"${PH_TMP_DIR}/.reported_issues"
	return 1
fi
return 0
}

function ph_stop_all_running_apps {

declare PH_APP
declare PH_STOP_MODE

PH_APP=""
PH_STOP_MODE="${1}"

[[ "${#}" -ne "1" || "${PH_STOP_MODE}" != @(normal|forced) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in $(ph_get_app_list_by_state -s Running -t exact)
do
	ph_do_app_action stop "${PH_APP}" "${PH_STOP_MODE}" || \
		return 1
done
return 0
}

function ph_update_app {

declare PH_i
declare PH_j
declare PH_APP
declare PH_APP_CMD
declare PH_APP_PKG
declare PH_APP_STATE
declare PH_UPDATE_DIR
declare PH_NEW_DIRS
declare PH_NEW_VERSION
declare PH_VALUE
declare PH_OPT
declare PH_ANSWER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -i PH_APP_TTY
declare -i PH_RET_CODE
declare -l PH_APPL

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_j=""
PH_APP=""
PH_APP_CMD=""
PH_APP_PKG=""
PH_APP_STATE=""
PH_UPDATE_DIR="/tmp/update"
PH_NEW_DIRS=""
PH_NEW_VERSION=""
PH_VALUE=""
PH_OPT=""
PH_ANSWER=""
PH_OPTION=""
PH_COUNT="0"
PH_APP_TTY="0"
PH_RET_CODE="0"
PH_APPL=""

OPTIND="1"

while getopts :a: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -ne "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "PieHelper" ]]
then
	ph_run_with_rollback -c "ph_git_clone_master -d '${PH_UPDATE_DIR}' -n PieHelper -r 'https://github.com/dkeppens/PieHelper.git'" || \
		return 1
	printf "%8s%s\n" "" "--> Checking for available PieHelper updates"
	PH_NEW_VERSION="$(cat "${PH_UPDATE_DIR}/PieHelper${PH_CONF_DIR##*PieHelper}/VERSION" 2>/dev/null)"
	if [[ "$PH_VERSION" == "$PH_NEW_VERSION" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (No available updates)"
		ph_run_with_rollback -l -c "ph_undo_git_clone_master -d '${PH_UPDATE_DIR}' -n PieHelper -r 'https://github.com/dkeppens/PieHelper.git'"
		return "$?"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Found update '${PH_NEW_VERSION}')"
	fi
	printf "%8s%s\n" "" "--> Checking if auto-update is allowed"
	if ph_check_object_existence -q -o "${PH_UPDATE_DIR}/PieHelper${PH_FILES_DIR##*PieHelper}/.auto_update_denied"
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No"
		printf "%8s%s\n\n" "" "--> Displaying reminder for manual updates"
		printf "%12s\033[1;37m%s\033[1;33m%s\033[1;37m%s\n" "" "- Version " "'${PH_NEW_VERSION}'" " has major changes and is denying automatic update"
		printf "%l2s%s\n" "" "- To obtain the new version :"
		printf "%l4s%s\n" "" "* Quit PieHelper to a shell prompt"
		printf "%14s%s\n" "" "* Unconfigure and uninstall PieHelper by running 'confpieh_ph.sh -r' (Your system will reboot)"
		printf "%14s%s\n" "" "* Install and configure the new version according to the WIKI procedure at 'https://github.com/dkeppens/PieHelper/wiki/Install-instructions'"
		printf "%l2s%s\033[0;0m\n\n" "" "- User settings will need to be reconfigured"
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		printf "%8s%s\n" "" "--> Cleaning up"
		"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
		printf "%2s\033[32m%s\033[0m\n\n" "" "SUCCESS"
		return 0
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n\n" "" "--> Listing new changes since last update"
		nawk -v oldver="^VERSION ${PH_VERSION} -" -v newver="^VERSION ${PH_NEW_VERSION} -" 'BEGIN {
				flag = 0
			}
			$0 ~ oldver {
				getline ;
				while ($0 !~ /^VERSION /) {
					getline
				} ;
				flag = 1 ;
				print ;
				next
			}	
			$0 ~ newver {
				print $0 ;
				getline ;
				while ($0 !~ /^VERSION /) {
					print ;
					if (getline<=0) {
						exit 0
					}
				}
			} {
				if (flag==1) {
					print ;
					 next
				} else {
					next
				}
			}' "${PH_UPDATE_DIR}/PieHelper${PH_FILES_DIR##*PieHelper}/VERSIONS" 2>/dev/null | more
		printf "\n\033[1;37m%s\033[0;0m\n\n" "Important : - Updating will stop all running applications"
		while [[ "$PH_ANSWER" != @(y|n) ]]
		do
			[[ "$PH_COUNT" -ne "0" ]] && \
				printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
			printf "%8s%s\033[1;37m%s\033[0;0m%s" "" "--> Update now " "(y/n)" " ? "
			read -r PH_ANSWER 2>/dev/null
			ph_set_result -r 0
			if [[ "$PH_ANSWER" == "n" ]]
			then
				printf "%10s\033[32m%s\033[0m\n" "" "OK (No)"
				ph_set_result -w -m "Quit at user request"
				"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
				ph_show_result
				return "$?"
			fi
			((PH_COUNT++))
		done
	fi
	for PH_APP in $(nawk 'BEGIN { \
			ORS = " " \
		} \
		$1 !~ /^PieHelper$/ && $3 !~ /^-$/ { \
			print $1 \
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)
	do
		printf "%8s%s\n" "" "--> Checking ${PH_APP} application state"
		PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
		PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
		PH_APP_CMD="$(sed "s/#PH_TTY#/${PH_APP_TTY}/g" <<<"$PH_APP_CMD")"
		[[ "$PH_APP" == "Bash" ]] && \
			PH_APP_CMD="bash"
		if pgrep -t "tty${PH_APP_TTY}" -f "$PH_APP_CMD" >/dev/null
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : ${PH_APP} is running on it's allocated tty -> Stopping"
			if ! ph_do_app_action stop "${PH_APP}" forced
			then
				printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
				"$PH_SUDO" rm -r /tmp/PieHelper 2>/dev/null
				return 1
			fi
		else
			printf "%10s\033[32m%s\033[0m\n" "" "OK (Not 'Running')"
		fi
	done
	ph_run_with_rollback -c "ph_store_all_options"
	printf "%8s%s\n" "" "--> Updating directory structure"
	for PH_i in $(find "$PH_UPDATE_DIR" -type d 2>/dev/null)
	do
		if [[ ! -d "${PH_BASE_DIR}/${PH_i##*/update}" && "${PH_BASE_DIR}/${PH_i##*/update}" != "${PH_BASE_DIR}/PieHelper/mnt/"* ]]
		then
			mkdir -p "${PH_BASE_DIR}/${PH_i##*/update}" 2>/dev/null
			[[ -z "$PH_NEW_DIRS" ]] && \
				PH_NEW_DIRS="${PH_i##*/update}/" || \
				PH_NEW_DIRS="${PH_NEW_DIRS} ${PH_i##*/update}/"
		fi
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' and optional non-codebase files"
	for PH_i in /PieHelper/ /PieHelper${PH_MNT_DIR##*PieHelper}/ /PieHelper${PH_TMP_DIR##*PieHelper}/ /PieHelper${PH_BUILD_DIR##*PieHelper}/ \
		/PieHelper${PH_SNAPSHOT_DIR##*PieHelper}/ /PieHelper${PH_CONF_DIR##*PieHelper}/ /PieHelper${PH_CONF_DIR##*PieHelper}/distros/ \
		/PieHelper${PH_FILES_DIR##*PieHelper}/ /PieHelper${PH_TEMPLATES_DIR##*PieHelper}/ /PieHelper${PH_EXCLUDES_DIR##*PieHelper}/ \
		/PieHelper${PH_MENUS_DIR##*PieHelper}/
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_UPDATE_DIR}${PH_i}${PH_j}" || \
				"${PH_j}" == @(*!(PieHelper).lst|*.conf|@(integrated|supported)_apps|OS.defaults|controller_cli_ids|options.@(allowed|default)s) ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j##*/}" 2>/dev/null
		done
	done
	for PH_i in $(echo -n "$PH_NEW_DIRS")
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_BASE_DIR}${PH_i}${PH_j}" ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j}" 2>/dev/null
		done
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' codebase files"
	for PH_i in /PieHelper${PH_MAIN_DIR##*PieHelper}/pre_cmds/ /PieHelper${PH_MAIN_DIR##*PieHelper}/post_cmds/ \
		/PieHelper${PH_MAIN_DIR##*PieHelper}/ /PieHelper${PH_FUNCS_DIR##*PieHelper}/ /PieHelper${PH_FUNCS_DIR##*PieHelper}/distros/ /PieHelper${PH_MAIN_DIR##*PieHelper}/expect/
	do
		for PH_j in $(ls "${PH_UPDATE_DIR}${PH_i}" 2>/dev/null)
		do
			[[ -d "${PH_UPDATE_DIR}${PH_i}${PH_j}" || "$PH_i" == functions.user ]] && \
				continue
			cp -p "${PH_UPDATE_DIR}${PH_i}${PH_j}" "${PH_BASE_DIR}${PH_i}${PH_j}" 2>/dev/null
		done
	done
	printf "%8s%s\n" "" "--> Updating 'Unique' config files"
	cp -p "${PH_UPDATE_DIR}/PieHelper${PH_CONF_DIR##*PieHelper}/distros/"*.conf "${PH_CONF_DIR}/distros/" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' management scripts"
	for PH_i in $(ls "${PH_UPDATE_DIR}/PieHelper${PH_SCRIPTS_DIR##*PieHelper}/"+(conf|list)*.sh 2>/dev/null)
	do
		cp -p "${PH_UPDATE_DIR}/PieHelper${PH_SCRIPTS_DIR##*PieHelper}/${PH_i}" "${PH_SCRIPTS_DIR}/${PH_i}" 2>/dev/null
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Updating 'Unique' menus"
	for PH_i in $(ls "${PH_UPDATE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/" 2>/dev/null)
	do
		[[ -d "${PH_BASE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/${PH_i}" ]] && \
			continue
		if [[ "$PH_i" != @(OptionsManagement.lst|TTYManagement.lst|StatusManagement.lst|$(nawk 'BEGIN { \
				ORS = "|" \
			} \
			$1 !~ /^PieHelper$/ { \
				print $1 ".lst|" "OptionsManagement_" $1 ".lst|" "TTYManagement_" $1 ".lst|" "StatusManagement_" $1 ".lst" \
			}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)) ]]
		then
			cp -p "${PH_UPDATE_DIR}/PieHelper${PH_MENUS_DIR##*PieHelper}/${PH_i}" "${PH_MENUS_DIR}/${PH_i}" 2>/dev/null
		fi
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	printf "%8s%s\n" "" "--> Sourcing new 'Shared' codebase"
	source "${PH_FUNCS_DIR}/functions.update" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
	for PH_APP in $(ph_get_app_list_by_state -s Supported -t minimum)
	do
		ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t support" || \
			return 1
	done
	ph_run_with_rollback -c "ph_retrieve_stored_options" || \
		return 1
	for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
	do
		ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t integrate" || \
			return 1
	done
	ph_secure_pieh -t delayed
	printf "%8s%s\n" "" "--> Cleaning up"
	"$PH_SUDO" rm -r /${PH_UPDATE_DIR}/PieHelper 2>/dev/null
	"$PH_SUDO" rm "${PH_TMP_DIR}/.first_run" 2>/dev/null
	"$PH_SUDO" rm "${PH_TMP_DIR}/.auto_update_denied" 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n\n" "" "OK"
	printf "%s\n" "Restart PieHelper manually to finalize updating to version '${PH_NEW_VERSION}'"
	printf "%s\n" "Press 'Enter' to quit"
	read -r 2>/dev/null
	ph_quit_pieh
else
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	PH_APP_PKG="$(ph_get_app_pkg_from_app_name "$PH_APP")"
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
	printf "%8s%s\n" "" "--> Checking ${PH_APP} application state"
	if [[ "$(ph_get_app_inst_state_from_app_name "$PH_APP")" == "PI" ]]
	then
		case "$PH_APP_STATE" in Running)
				ph_set_result -r 1
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not update package '${PH_APP_PKG}' while ${PH_APP} state is '${PH_APP_STATE}'" ;;
					*)
				ph_set_result -r 0
				printf "%10s\033[32m%s\033[0m\n" "" "OK"
				ph_update_pkg "$PH_APP_PKG"
				ph_set_result -r "$?" ;;
		esac
	else
		ph_set_result -r 1
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Updating requires installation state 'PI'"
	fi
fi
[[ "$PH_RESULT" != @(SUCCESS|Warning) ]] && \
	return 1
if [[ "$PH_FILE_SUFFIX" == "_GL" && "$PH_APP" == "Kodi" && "$PH_APP_TTY" -gt "1" ]]
then
	ph_modify_app_script -a "$PH_APP" -t "$PH_APP_TTY" || \
		return 1
fi
return 0
}

function ph_check_user_state {

declare PH_APP_USER

PH_APP_USER="${1}"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ! id "${PH_APP_USER}" >/dev/null 2>&1
then
	return 1
fi
return 0
}

function ph_check_user_validity {

declare PH_APP_USER

PH_APP_USER="${1}"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ! echo "${PH_APP_USER}" | grep -E "^[a-z_][a-z0-9_-]*[$]?$" >/dev/null
then
	return 1
fi
return 0
}

function ph_get_app_tty_from_app_name {

declare PH_APP
declare PH_APP_STR_TTY

PH_APP="${1}"
PH_APP_STR_TTY=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ! PH_APP_STR_TTY="$(nawk -v app="^${PH_APP}$" -v max="${PH_PIEH_MAX_TTYS}" '$1 ~ app { \
		if ($2 ~ /^-$/ || ($2 <= max && $2 > 1)) { \
			printf $2 ; \
			exit 0 \
		} else { \
			printf "%s", "1" ; \
			exit 1 \
		} \
	} { \
		next \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
then
	PH_APP_STR_TTY="1"
fi
echo -n "${PH_APP_STR_TTY}"
[[ "${PH_APP_STR_TTY}" -eq "1" ]] && \
	return 1
return 0
}

function ph_restore_file {

declare PH_FILE
declare PH_TMP_FILE
declare PH_PARAMS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_RESTORE_AS_ROOT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_FILE=""
PH_TMP_FILE=""
PH_PARAMS=""
PH_OPTION=""
PH_RESTORE_AS_ROOT="1"

OPTIND="1"

while getopts :f:rc PH_OPTION
do
	case "$PH_OPTION" in f)
		[[ -n "$PH_FILE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG"
		PH_TMP_FILE="$("$PH_SUDO" ls -lAt "${PH_TMP_DIR}/$(echo -n "${PH_FILE##*/}" | sed 's/\./_/g')_tmp"* 2>/dev/null | nawk '{ \
				print ; \
				exit \
			}')" ;;
			     r)
		[[ "$PH_RESTORE_AS_ROOT" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_RESTORE_AS_ROOT="0" ;;
			     c)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-c" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-c" || \
			PH_PARAMS="${PH_PARAMS} -c" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || "$#" -lt "2" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_RESTORE_AS_ROOT" -eq "0" ]]
then
	"$PH_SUDO" mv "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
else
	mv "$PH_TMP_FILE" "$PH_FILE" 2>/dev/null
fi
if [[ "$?" -eq "0" ]]
then
	ph_add_value_to_param -p PH_STORE_FILES -v "${PH_FILE}'${PH_PARAMS}"
	return 0
fi
ph_set_result -m "An error occurred trying to restore '${PH_TMP_FILE}' as '${PH_FILE}'"
return 1
}


function ph_store_file {

declare PH_FILE
declare PH_TMP_FILE
declare PH_PARAMS
declare PH_COMMAND
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_STORE_AS_ROOT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_FILE=""
PH_TMP_FILE=""
PH_PARAMS=""
PH_COMMAND=""
PH_OPTION=""
PH_STORE_AS_ROOT="1"

OPTIND="1"

while getopts :f:rc PH_OPTION
do
	case "$PH_OPTION" in f)
		[[ -n "$PH_FILE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE="$OPTARG"
		PH_TMP_FILE="${PH_TMP_DIR}/$(echo -n "${PH_FILE##*/}" | sed 's/\./_/g')_tmp.$(date +'%s%N')" ;;
			     c)
		[[ -n "$PH_COMMAND" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-c" || \
			PH_PARAMS="${PH_PARAMS} -c"
		PH_COMMAND="cp -p" ;;
			     r)
		[[ "$PH_STORE_AS_ROOT" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_STORE_AS_ROOT="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE" || "$#" -lt "2" || ( ! -f "$PH_FILE" && ! -L "$PH_FILE" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_COMMAND" ]] && \
	PH_COMMAND="mv"
if [[ "$PH_STORE_AS_ROOT" -eq "0" ]]
then
	"$PH_SUDO" ${PH_COMMAND} "$PH_FILE" "$PH_TMP_FILE" 2>/dev/null
else
	${PH_COMMAND} "$PH_FILE" "$PH_TMP_FILE" 2>/dev/null
fi
if [[ "$?" -eq "0" ]]
then
	ph_add_value_to_param -p PH_RESTORE_FILES -v "${PH_FILE}'${PH_PARAMS}"
	return 0
fi
ph_set_result -m "An error occurred trying to store '${PH_FILE}' as '${PH_TMP_FILE}'"
return 1
}

function ph_create_base_conf_file {

declare PH_FILE
declare PH_FILE_SHORTNAME

PH_FILE=""
PH_FILE_SHORTNAME="${1}"

[[ "${PH_FILE_SHORTNAME}" != @(cont|os|int|sup|@(default|allowed)s) || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_FILE="$(ph_get_filename_from_shortname "${PH_FILE_SHORTNAME}")"
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Creating base configuration file " "'${PH_FILE}'"
if [[ ! -e "${PH_CONF_DIR}/${PH_FILE}" ]]
then
	if ph_run_with_rollback -c "ph_create_empty_file -t file -q -d '${PH_CONF_DIR}/${PH_FILE}'"
	then
		ph_run_with_rollback -c true
	else
		ph_run_with_rollback -c false -m "Could not create"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return "${?}"
}

function ph_update_pieh_version {

declare PH_NEW_VERSION

PH_NEW_VERSION="${1}"

[[ -z "${PH_NEW_VERSION}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Updating PieHelper version to " "'${PH_NEW_VERSION}'"
if [[ "${PH_VERSION}" != "${PH_NEW_VERSION}" ]]
then
	if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '${PH_CONF_DIR}/VERSION' -l '${PH_VERSION}'"
	then
		if ph_run_with_rollback -c "ph_add_line_to_file -r -f '${PH_CONF_DIR}/VERSION' -l '${PH_NEW_VERSION}'"
		then
			PH_VERSION="${PH_NEW_VERSION}"
			ph_add_value_to_param -p PH_PIEH_VERSION -v "${PH_VERSION}"
			ph_run_with_rollback -c true && \
				return "${?}"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not update" || \
		return 1
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_get_app_cmd_from_app_name {

declare PH_APP
declare PH_APP_CMD
declare PH_APP_STR_TTY
declare PH_FILE

PH_APP="$1"
PH_APP_CMD=""
PH_APP_STR_TTY=""
PH_FILE=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_FILE in "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
do
	PH_APP_CMD="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
			ORS = " " \
		} \
		$1 ~ app { \
			for (i=4;i<=NF;i++) { \
				if (i == NF) { \
					ORS = "" ; \
					print $i \
				} else { \
					print $i \
				} \
			} \
		}' "$PH_FILE" 2>/dev/null)"
	if [[ -n "$PH_APP_CMD" ]]
	then
		[[ "$PH_APP" == "PieHelper" ]] && \
			PH_APP_CMD="$(ph_resolve_dynamic_value "${PH_APP_CMD}")"
		if echo "$PH_APP_CMD" | grep -E "#PH_TTY#" >/dev/null
		then
			PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
			if [[ "$PH_APP_STR_TTY" != "-" ]]
			then
				echo -n "${PH_APP_CMD//#PH_TTY#/${PH_APP_STR_TTY}}"
				return 0
			fi
		fi
		echo -n "$PH_APP_CMD"
		return 0
	fi
done
return 1
}

function ph_get_app_name_from_app_cmd {

declare PH_APP
declare PH_APP_CMD
declare PH_FILE

PH_APP=""
PH_APP_CMD="$1"
PH_FILE=""

[[ -z "$PH_APP_CMD" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_FILE in "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
do
	PH_APP="$(nawk -v appcmd="^()*${PH_APP_CMD}$" 'BEGIN { \
			storevar = "" ; \
			count = "0" \
		} { \
			storevar = $1 ; \
			$1 = "" ; \
			$2 = "" ; \
			$3 = "" ; \
			if ($0 ~ appcmd) { \
				count++ \
			} \
		} { \
			next \
		} END { \
			if (count == 1) { \
				printf storevar \
			} \
		}' "$PH_FILE" 2>/dev/null)"
	if [[ -n "$PH_APP" ]]
	then
		echo -n "$PH_APP"
		return 0
	fi
done
return 1
}

function ph_get_app_user_from_app_name {

declare PH_APP
declare PH_APP_USER

PH_APP="$1"
PH_APP_USER=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
		printf $2 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1 
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_name_from_base_conf_file {

declare PH_i
declare PH_j
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_APP_INST_STATE
declare PH_APP_PKG
declare PH_APP_STR_TTY
declare PH_FILE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -l PH_il

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_j=""
PH_APP=""
PH_APP_USER=""
PH_APP_CMD=""
PH_APP_INST_STATE=""
PH_APP_PKG=""
PH_APP_STR_TTY=""
PH_FILE=""
PH_OPTION=""
PH_COUNT="0"
PH_il=""

OPTIND="1"

while getopts :u:t:c:i:p: PH_OPTION
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ -n "$PH_APP_STR_TTY" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_STR_TTY="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             p)
		[[ -n "$PH_APP_PKG" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" && -z "$PH_APP_CMD" && -z "$PH_APP_INST_STATE" && -z "$PH_APP_PKG" && \
	( "$PH_APP_STR_TTY" != @(+([[:digit:]])|-) || ( "$PH_APP_STR_TTY" == +([[:digit:]]) && \
	( "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_STR_TTY" -le "1" ))) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in USER STR_TTY CMD INST_STATE PKG
do
	if [[ "$PH_i" == "STR_TTY" ]]
	then
		PH_il="$PH_i"
	else
		PH_il="tty"
	fi
	declare -n PH_VAR="PH_APP_${PH_i}"
	if [[ ( "$PH_i" != "STR_TTY" && -z "$PH_VAR" ) || \
		( "$PH_i" == "STR_TTY" && "$PH_VAR" -le "1" ) ]]
	then
		unset -n PH_VAR
		continue
	fi
	case "$PH_i" in STR_TTY)
		PH_FILE="${PH_CONF_DIR}/integrated_apps" ;;
			PKG)
		PH_APP="$(ph_get_app_name_from_app_pkg "$PH_VAR")" ;;
			*)
		PH_FILE="${PH_CONF_DIR}/supported_apps" ;;
	esac
	if [[ "$PH_i" != "PKG" ]]
	then
		for PH_j in 1 2
		do
			[[ "$PH_j" == "2" ]] && \
				PH_FILE="${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}"
			PH_COUNT="$(nawk -v comp="$PH_il" -v mstring="^()*${PH_VAR}()*$" 'BEGIN { \
					count = 0 ; \
					$1 = "" ; \
					if (comp == "user") { \
						$3 = "" \
					} elif (comp == "cmd") { \
						$2 = "" ; \
						$3 = "" \
					} elif (comp == "inst_state") { \
						$2 = "" \
					} ; \
					if (comp != "cmd") { \
						for (i=4;i<=NF;i++) { \
							$i = "" \
						} \
					} \
				} \
				$0 ~ mstring { \
					count++ ; \
					next \
				} { \
					next \
				} END { \
					printf "%s", count \
				}' "${PH_FILE}" 2>/dev/null)"
			[[ "$PH_COUNT" -gt "0" || "$PH_i" != "CMD" ]] && \
				break
		done
		case "$PH_COUNT" in 0)
			unset -n PH_VAR
			continue ;;
				    1)
			PH_APP="$(eval "ph_get_app_name_from_app_${PH_il} \"${PH_VAR}\"")" ;;
				    *)
			unset -n PH_VAR
			return 1 ;;
		esac
	fi
	unset -n PH_VAR
	[[ -n "$PH_APP" ]] && \
		break
done
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_inst_state {

declare PH_APP
declare PH_APP_INST_STATE

PH_APP=""
PH_APP_INST_STATE="$1"

[[ "$PH_APP_INST_STATE" != @(P|U)@(I|U) || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v inst_state="^${PH_APP_INST_STATE}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$3 ~ inst_state { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_user {

declare PH_APP
declare PH_APP_USER

PH_APP=""
PH_APP_USER="$1"

[[ -z "$PH_APP_USER" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v user="^${PH_APP_USER}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$2 ~ user { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_name_from_app_tty {

declare PH_APP
declare PH_APP_STR_TTY

PH_APP=""
PH_APP_STR_TTY="${1}"

[[ "${PH_APP_STR_TTY}" != @(+([[:digit:]])|-) || ( "${PH_APP_STR_TTY}" == +([[:digit:]]) && \
	( "${PH_APP_STR_TTY}" -le "1" || "${PH_APP_STR_TTY}" -gt "${PH_PIEH_MAX_TTYS}" )) || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(nawk -v tty="^${PH_APP_STR_TTY}$" 'BEGIN { \
		app = "" ; \
		count = "0" \
	} \
	$2 ~ tty { \
		app = $1 ; \
		count++ \
	} { \
		next \
	} END { \
		if (count == 1) { \
			printf app \
		} \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
[[ -z "${PH_APP}" ]] && \
	return 1
echo -n "${PH_APP}"
return 0
}

function ph_check_mac_validity {

declare PH_MAC_ADDR

PH_MAC_ADDR="$1"

[[ -z "$PH_MAC_ADDR" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_MAC_ADDR" != @({5}(@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9])){1}(:))@([A-F][0-9]|[0-9][A-F]|{2}([A-F])|{2}([0-9]))|none) ]]
then
	return 1
fi
return 0
}

function ph_check_ip_validity {

declare PH_IPV4_ADDR

PH_IPV4_ADDR="$1"

[[ -z "$PH_IPV4_ADDR" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_IPV4_ADDR" != @({3}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9]))\.){1}(@({1}(1){1}([0-9]){1}([0-9])|{1}(2){1}([0-4]){1}([0-9])|{1}(2){1}(5){1}([0-4])|{1}([1-9]){1}([0-9])|{1}([0-9])))|) ]]
then
	return 1
fi
return 0
}

function ph_get_pieh_conf_state {

declare PH_CONF_STATE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_QUIESCE

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_CONF_STATE=""
PH_OPTION=""
PH_QUIESCE="1"

OPTIND="1"

while getopts :q PH_OPTION
do
        case "$PH_OPTION" in q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_QUIESCE="0" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( "$#" -ne "1" && "$PH_QUIESCE" -eq "0" ) || ( "$PH_QUIESCE" -eq "1" && "$#" -ne "0" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -f "${PH_TMP_DIR}/.first_run" ]]
then
	PH_CONF_STATE="unconfigured"
else
	PH_CONF_STATE="configured"
fi
if [[ "$PH_QUIESCE" -ne "0" ]]
then
	printf "\n%4s\033[1;37m%8s%-20s%s\033[1;33m%s\033[0;0m\n" "" "Current " "PieHelper version " ": " "'${PH_VERSION}'"
	printf "%12s\033[1;37m%-20s%s\033[1;33m%s\033[0;0m\n" "" "configuration state " ": " "${PH_CONF_STATE}"
else
	echo -n "$PH_CONF_STATE"
fi
return 0
}

function ph_print_bannerline {

declare -i PH_COUNT
declare -i PH_COLUMNS

PH_COUNT="0"
PH_COLUMNS="$(tput cols 2>/dev/null)"

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

while [[ "${PH_COUNT}" -lt "${PH_COLUMNS}" ]]
do
	printf "%s" "*"
	((PH_COUNT++))
done
printf "\n"
return 0
}

function ph_configure_app_options {

declare PH_APP
declare PH_ANSWER
declare -i PH_OPT
declare -i PH_COUNT
declare -i PH_RET_CODE
declare -a PH_OPTAR

PH_APP="$1"
PH_ANSWER=""
PH_OPT="0"
PH_COUNT="0"
PH_RET_CODE="0"
PH_OPTAR=($(nawk -F'=' 'BEGIN { \
		ORS = " " \
	} \
	$1 ~ /^PH_/ { \
		print $1 \
	}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null))

[[ "$?" -ne "0" || -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Starting configuration of read-write ${PH_APP} option(s) (Press 'Enter' to start)"
read -r 2>/dev/null
printf "%10s\033[32m%s\033[0m\n" "" "OK"
sleep 1
for ((PH_OPT=0;PH_OPT<="$(("${#PH_OPTAR[@]}"-1))";PH_OPT++))
do
	clear
        PH_COUNT="0"
        PH_ANSWER=""
	PH_RET_CODE="0"
        confopts_ph.sh -p get -a "$PH_APP" -o "${PH_OPTAR[$PH_OPT]}" | tail -n +4
        confopts_ph.sh -p help -a "$PH_APP" -o "${PH_OPTAR[$PH_OPT]}" | tail -n +4
	printf "%s\033[36m%s\033[0m\033[32m%s\033[0m\033[36m%s\033[0m\n" "- " "Changing the value of " "'${PH_OPTAR[$PH_OPT]}'" " interactively"
        while [[ "$PH_ANSWER" != @(y|n) ]]
        do
                if [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && "$PH_COUNT" -eq "0" ]]
		then
			printf "\n%12s\033[32m%s\n" "" "INFO : - A value for PH_MOON_SRV is required for further configuration"
			printf "%19s%s\033[0m\n\n" "" "- An empty value for PH_MOON_SRV will end configuration but it can later be restarted using either 'confapps_ph.sh' or the PieHelper menu : "
		fi
        	[[ "$PH_COUNT" -gt "0" ]] && \
			printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
               	printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m%s" "" "--> Do you want the change the value for " "'${PH_OPTAR[$PH_OPT]}' " "(y/n)" " ? "
               	read -r PH_ANSWER 2>/dev/null
               	if ! ph_screen_input "$PH_ANSWER"
               	then
			if [[ "$PH_OPT" -eq "0" ]]
			then
				ph_set_result -r 1
			else
				ph_set_result -r 1
			fi
			unset PH_OPTAR
			return 1
               	fi
               	((PH_COUNT++))
        done
        printf "%10s%s\n" "" "OK"
        if [[ "$PH_ANSWER" == "y" ]]
        then
                false
                while [[ "$?" -ne "0" ]]
                do
			PH_ANSWER=""
                        printf "%8s%s" "" "--> Please enter the new value for '${PH_OPTAR[$PH_OPT]}' : "
                        read -r PH_ANSWER 2>/dev/null
                        printf "%10s%s\n" "" "OK"
                        if ph_set_option_to_value "$PH_APP" -r "${PH_OPTAR[$PH_OPT]}'$PH_ANSWER"
			then
				if [[ "${PH_OPTAR[$PH_OPT]}" != "PH_MOON_SRV" ]]
				then
					printf "%2s%s\n\n" "" "SUCCESS"
					sleep 2
				else
					if [[ -n "$PH_MOON_SRV" ]]
					then
						printf "%2s%s\n\n" "" "SUCCESS"
						sleep 2
					fi
				fi
			else
				printf "%8s%s\n\n" "" "--> Please select how to proceed"
				printf "%12s%s\033[32m%s\033[0m%s\n" "" "1. " "'r'" " to retry"
				printf "%12s%s\033[32m%s\033[0m%s\n" "" "2. " "'s'" " to skip to next option"
				printf "%12s%s\033[32m%s\033[0m%s\n\n" "" "3. " "Any other key" " to quit all configuration of '$PH_APP'"
				printf "%8s%s\n" "" "Your choice ? "
				read -rs -n 1 PH_ANSWER 2>/dev/null
				printf "\r"
				case "$PH_ANSWER" in s|S)
						PH_RET_CODE="1"
						printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR" " : Skipped by user"
						printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
						sleep 2 ;;
						     r|R)
						printf "%10s%s\n" "" "OK (Retrying)"
						PH_ANSWER="y"
						sleep 1
						false ;;
						       *)
						ph_set_result -r 1
						printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR" " : Quit by user"
						printf "%2s\033[31m%s\033[0m\n\n" "" "FAILED"
						unset PH_OPTAR
						sleep 2
						return 1 ;;
				esac
			fi
                done
	else
		if [[ "${PH_OPTAR[$PH_OPT]}" != "PH_MOON_SRV" ]]
		then
			printf "%2s%s\n\n" "" "SUCCESS"
			sleep 2
		fi
	fi
        [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && -z "$PH_MOON_SRV" ]] && PH_RET_CODE="1"
	ph_set_result -r "$PH_RET_CODE"
	[[ "$PH_ANSWER" == @(s|S) ]] && PH_ANSWER="" && continue
        if [[ "${PH_OPTAR[$PH_OPT]}" == "PH_MOON_SRV" && -z "$PH_MOON_SRV" ]]
        then
		printf "%2s\033[31m%s\033[0m%s\n\n" "" "ABORT" " : Empty value for PH_MOON_SRV"
		sleep 2
		unset PH_OPTAR
		return 1
	fi
        PH_ANSWER=""
done
unset PH_OPTAR
return 0
}

function ph_configure_moon {

declare PH_MOON_USER
declare PH_MOON_PATH

PH_MOON_USER=""
PH_MOON_PATH=""

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

ph_configure_app_options Moonlight || \
	return 1
if [[ -n "$PH_MOON_SRV" ]]
then
	PH_MOON_PATH="$(nawk '$1 ~ /^Moonlight$/ { \
			printf $3 \
		}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
	PH_MOON_USER="$(ph_get_app_user_from_app_name Moonlight)"
	if [[ -d "$(getent passwd "$PH_MOON_USER" 2>/dev/null | head -1 | cut -d':' -f6)/.cache" ]]
	then
		printf "%8s%s\n" "" "--> Removing the Moonlight cache directory for user '${PH_MOON_USER}'"
		if "$PH_SUDO" rm -r "$(getent passwd "$PH_MOON_USER" 2>/dev/null | head -1 | cut -d':' -f6)/.cache" 2>/dev/null
		then
			ph_run_with_rollback -c true
		else
			ph_run_with_rollback -c false -m "Could not remove" || \
				return 1
		fi
	fi
	printf "%8s%s\n" "" "--> Pairing with server '${PH_MOON_SRV}'"
	if "$PH_SUDO" -u "$PH_MOON_USER" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} pair ${PH_MOON_SRV}" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true && \
			return "$?"
	else
		ph_run_with_rollback -c false -m "Could not pair" || \
			return 1
	fi
else
	ph_set_result -m "Could not configure Moonlight without having a valid value for option 'PH_MOON_SRV'"
fi
return 1
}

function ph_configure_kodi {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Configuring Kodi"
printf "%10s\033[33m%s\033[0m\n" "" "Warning : Code for configuration of Kodi is currently unimplemented"
ph_set_result -r 0
return 0
}

function ph_configure_x11 {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Configuring X11"
printf "%10s\033[33m%s\033[0m\n" "" "Warning : Code for configuration of X11 is currently unimplemented"
ph_set_result -r 0
return 0
}

function ph_configure_bash {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Configuring Bash"
ph_run_with_rollback -c true -m "Nothing to do" && \
	return "$?"
}

function ph_configure_emul {

declare PH_ALSA_CARD
declare PH_ALSA_DEV

PH_ALSA_CARD=""
PH_ALSA_DEV=""

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Configuring Emulationstation"
PH_ALSA_CARD="$(aplay -l 2>/dev/null | nawk 'BEGIN { \
		ORS = "" \
	} \
	$0 ~ /HDMI/ { \
		for (i=1;i<=NF;i++) { \
			if ($i ~ /^card$/) { \
				sub(/:/,"",$(i+1)) ; \
				print $(i+1) \
			} \
		} \
	}' 2>/dev/null)"
PH_ALSA_DEV="$(aplay -l 2>/dev/null | nawk 'BEGIN { \
		ORS = "" \
	} \
	$0 ~ /HDMI/ { \
		for (i=1;i<=NF;i++) { \
			if ($i ~ /^device$/) { \
				sub(/:/,"",$(i+1)) ; \
				print $(i+1) \
			} \
		} \
	}' 2>/dev/null)"
if [[ -n "$PH_ALSA_CARD" && -n "$PH_ALSA_DEV" ]]
then
	if "$PH_SUDO" nawk -v card="$PH_ALSA_CARD" -v dev="$PH_ALSA_DEV" '$1 ~ /^audio_enable$/ {
			print "audio_enable = true" ;
			next
		}
		$1 ~ /^audio_out_rate$/ {
			print "audio_out_rate = 44100" ;
			next
		}
		$1 ~ /^audio_driver$/ {
			print "audio_driver = alsa" ;
			next
		}
		$1 ~ /^audio_sync$/ {
			print "audio_sync = true" ;
			next
		}
		$1 ~ /^audio_device$/ {
			print "audio_device = hw:" card "," dev ;
			next
		}
		{
			print
		}' /opt/retropie/configs/all/retroarch.cfg >/tmp/retroarch.cfg_tmp 2>/dev/null
	then
		if "$PH_SUDO" mv /tmp/retroarch.cfg_tmp /opt/retropie/configs/all/retroarch.cfg 2>/dev/null
		then
			ph_run_with_rollback -c true -m "ALSA audio is configured" && \
				return "$?"
		fi
	fi
fi
"$PH_SUDO" rm /tmp/retroarch_cfg_tmp 2>/dev/null
ph_run_with_rollback -c false -m "Could not configure" || \
	return 1
}

function ph_configure_app {

declare PH_APP
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -l PH_APPL

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_OPTION=""
PH_APPL=""

OPTIND="1"

while getopts :a: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG"
                PH_APPL="${PH_APP:0:4}" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -ne "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if ph_configure_"$PH_APPL" 2>/dev/null
then
	if [[ "$(ph_check_app_state_validity -a "$PH_APP" -q -d ; echo "$?")" -ne "0" && \
		"$(functions 2>&1 | grep -E "function ph_configure_${PH_APPL} {" >/dev/null ; echo "$?")" -ne "0" ]]
	then
		printf "%8s%s\n" "" "--> Configuring ${PH_APP}"
		ph_set_result -m "${PH_APP} is an out-of-scope application and requires prior user-side development of a function called 'ph_configure_${PH_APPL}' in file '${PH_FUNCS_DIR}/functions.user'"
		ph_run_with_rollback -c false -m "Could not configure" || \
			return 1
	fi
else
	return 1
fi
return 0
}

function ph_setup_controllers {

declare PH_i
declare PH_j
declare PH_MAP
declare PH_ADD_CTRL_TYPE
declare PH_PARENT_DEV_PATH
declare -i PH_PRINT_FLAG
declare -i PH_NUM_CTRL
declare -i PH_CTRL_CLI_ID
declare -i PH_EVDEVS

PH_i=""
PH_j=""
PH_MAP="$PH_CONT_MAP"
PH_ADD_CTRL_TYPE=""
PH_PARENT_DEV_PATH=""
PH_PRINT_FLAG="1"
PH_NUM_CTRL="$1"
PH_CTRL_CLI_ID="0"
PH_EVDEVS="0"

[[ "$PH_NUM_CTRL" -eq "0" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -f "${PH_CONF_DIR}/controller_cli_ids" ]]
then
	ph_create_base_conf_file cont || \
		return 1
fi
ph_cleanup_controllers reset
[[ "${PH_CONT_TYPE}" == "XBOX360" ]] && \
	PH_MAP="no"
PH_EVDEVS="$(ls -l /dev/input/event+([[:digit:]]) 2>/dev/null | wc -l)"
if [[ "$PH_EVDEVS" -eq "0" ]]
then
	printf "%8s%s\n" "" "--> Running type verification of input devices"
	printf "%10s%s\n" "" "ERROR : (None found)"
	return 1 
fi
for PH_i in $(find /dev/input -name "event+([[:digit:]])" -exec ls -l {} \; 2>/dev/null | sort -n 2>/dev/null | nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $NF \
	}')
do
	printf "%8s%s\n" "" "--> Running type verification of input device '${PH_i##*event}'"
	PH_PARENT_DEV_PATH="$(udevadm info "$PH_i" 2>/dev/null | nawk -F'=' '$0 ~ /.: DEVPATH=/ { print $2 }')"
	PH_PARENT_DEV_PATH="${PH_PARENT_DEV_PATH%/*}"
	[[ "$PH_CONT_TYPE" == "PS4" ]] && \
		PH_ADD_CTRL_TYPE="PS4A"
	for PH_j in "$PH_CONT_TYPE" ${PH_ADD_CTRL_TYPE}
	do
		[[ "$PH_j" != "PS4A" ]] && \
			PH_PRINT_FLAG="0"
## add xboxurecv connection type for wireless XBOX360 USB Receiver
		PH_CTRL_CONN="$(udevadm info -q all --path "$PH_PARENT_DEV_PATH" 2>/dev/null | nawk -F'=' -v type="$PH_j" 'BEGIN { \
				flag = 0 ; \
				conn="" ; \
				if (type ~ /^PS4$/) { \
					string = "\"(Sony Interactive Entertainment )*Wireless Controller\"$" \
				} elif (type ~ /^PS4A$/) { \
					string="\"Sony Interactive Entertainment DUALSHOCK.*4 USB Wireless Adaptor\"$" \
				} elif (type ~ /^PS3$/) { \
					string="\".*PLAYSTATION\(R\)3 Controller\"$" \
				} elif (type ~ /^XBOX360$/) { \
					string="\"Microsoft X-Box 360 pad\"$" \
				} \
			} \
			$2 ~ string { \
				flag = 1 ; \
				next \
			} \
			$1 ~ "^.: ID_BUS$" { \
				if (type ~ /^PS4A/) { \
					conn = "sonywadapt" \
				} else { \
					conn = $2 \
				} ; \
				next \
			} { \
				next \
			} END { \
				if (flag == "1") { \
					print conn \
				} \
			}' 2>/dev/null)"
		if [[ -n "$PH_CTRL_CONN" ]]
		then
			PH_CTRL_CLI_ID="${PH_i##*event}"
			declare -n PH_CONN="PH_CTRL_CONN${PH_CTRL_CLI_ID}"
			declare -n PH_CLI_ID="PH_CTRL_CLI_ID${PH_CTRL_CLI_ID}"
			PH_CONN="$PH_CTRL_CONN"
			PH_CLI_ID="$PH_CTRL_CLI_ID"
			printf "%10s\033[32m%s\033[0m\n" "" "OK '${PH_CONT_TYPE}:${PH_CONN}:id ${PH_CLI_ID}'"
			[[ "$PH_j" == "PS4" ]] && \
				PH_PRINT_FLAG="1"
			echo "$PH_CLI_ID" >>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null
			unset -n PH_CLI_ID PH_CONN
		else
			[[ "$PH_j" != "PS4" && "$PH_PRINT_FLAG" -eq "0" ]] && \
				printf "%10s\033[32m%s\033[0m\n" "" "OK (Not a '${PH_CONT_TYPE}' controller)"
		fi
	done
done
printf "%8s%s\n" "" "--> Verifying '${PH_CONT_TYPE}' controller count"
if [[ "$(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)" -eq "$PH_NUM_CTRL" ]]
then
        printf "%10s\033[32m%s\033[0m\n" "" "OK"
else
        if [[ "$(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)" -lt "$PH_NUM_CTRL" ]]
	then
                printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Insufficient number of '${PH_CONT_TYPE}' controllers connected ($(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)<->${PH_NUM_CTRL} requested)"
		return 1
	fi
        declare -n PH_CONN="PH_CTRL_CONN$(sed -n '1p' "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null)"
        declare -n PH_CLI_ID="PH_CTRL_CLI_ID$(sed -n '1p' "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null)"
        printf "%10s\033[33m%s\033[0m" "" "Warning : Greater number of '${PH_CONT_TYPE}' controllers connected than requested ($(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)<->${PH_NUM_CTRL} requested) -> Using '${PH_CONN}:CLI id ${PH_CLI_ID}'"
        if [[ "$PH_NUM_CTRL" -ne "1" ]]
        then
		for ((PH_i=2;PH_i<="${PH_NUM_CTRL}";PH_i++))
                do
                        if [[ "$PH_i" -le "$PH_NUM_CTRL" ]]
			then
				printf "\033[33m%s\033[0m" " &&"
                        	printf "\033[33m%s\033[0m" " '$(eval "echo -n \"\$PH_CTRL_CONN${PH_i}\""):CLI id $(eval "echo -n \"\$PH_CTRL_CLI_ID${PH_i}\"")'"
			fi
                done
        fi
        echo ""
	unset -n PH_CONN PH_CLI_ID
fi
if [[ "$PH_NUM_CTRL" -ge "2" ]]
then
	printf "%8s%s\n" "" "--> Growing udev event queue for multiple controller usage"
	"$PH_SUDO" udevadm control --children-max 500 2>/dev/null
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
if [[ "$PH_MAP" == "yes" ]]
then
	ph_cleanup_controllers unmap || \
		return 1
	printf "%8s%s\n" "" "--> Starting 'xboxdrv' instance with virtual 'XBOX360' controller mapping"
	for ((PH_CTRL_ID=1;PH_CTRL_ID<="${PH_NUM_CTRL}";PH_CTRL_ID++))
	do
		declare -n PH_CLI_ID="PH_CTRL_CLI_ID$(sed -n "${PH_CTRL_CLI_ID}p" "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null)"
		declare -n PH_CONN="PH_CTRL_CONN$(sed -n "${PH_CTRL_CLI_ID}p" "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null)"
		case "${PH_CONT_TYPE}_${PH_CONN}" in PS4_bluetooth)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev "/dev/input/event${PH_CLI_ID}" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" >/dev/null 2>&1 && \
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && \
				>"${PH_CONF_DIR}/controller_cli_ids" && \
				return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null ;;
## correct button mappings for the three cases below
		   			   	 PS3_bluetooth)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev "/dev/input/event${PH_CLI_ID}" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" >/dev/null 2>&1 && \
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && \
				>"${PH_CONF_DIR}/controller_cli_ids" && \
				return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null ;;
			   			       PS3_usb)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev "/dev/input/event${PH_CLI_ID}" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" >/dev/null 2>&1 && \
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && \
				>"${PH_CONF_DIR}/controller_cli_ids" && \
				return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null ;;
				         		     *)
			("$PH_SUDO" nice --adjustment="-9" "$(command -v xboxdrv 2>/dev/null)" \
				--evdev "/dev/input/event${PH_CLI_ID}" \
				--evdev-absmap ABS_X=x1,ABS_Y=y1 \
				--evdev-absmap ABS_Z=x2,ABS_RZ=y2 \
				--evdev-absmap ABS_RX=lt,ABS_RY=rt \
				--evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
				--evdev-keymap BTN_SELECT=tl,BTN_START=tr \
				--evdev-keymap KEY_#308=lb,BTN_Z=rb \
				--evdev-keymap KEY_#305=a,BTN_C=b,KEY_#304=x,KEY_#307=y \
				--evdev-keymap BTN_TL2=back,BTN_MODE=guide,BTN_TR2=start \
				--axismap -y1=y1,-y2=y2 \
				--pid-file "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" --silent --detach-kernel-driver --mimic-xpad &) >/dev/null 2>&1
			cat "/tmp/xboxdrv${PH_CTRL_CLI_ID}.pid" >/dev/null 2>&1 && \
				printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not start instance" && \
				>"${PH_CONF_DIR}/controller_cli_ids" && \
				return 1
			echo "$((PH_EVDEVS+"$((PH_CTRL_CLI_ID-1))"))" >>"${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null ;; 
		esac
		unset -n PH_CLI_ID PH_CONN
	done
	printf "%10s\033[32m%s\033[0m\n" "" "OK"
fi
for PH_i in $(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | paste -d" " -s)
do
	[[ "$PH_i" -lt "$PH_EVDEVS" ]] && \
		unset -n "PH_CTRL_CONN${PH_i}" "PH_CTRL_CLI_ID${PH_i}"
done
return 0
}

function ph_get_controller_cli_id {

declare PH_CTRL_CLI_ID
declare -i PH_CTRL_CLI_ID_LINE

PH_CTRL_CLI_ID=""
PH_CTRL_CLI_ID_LINE="$1"

[[ "$PH_CTRL_CLI_ID_LINE" -eq "0" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_CTRL_CLI_ID="$(sed -n "${PH_CTRL_ID_LINE}p" "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null)"
then
	echo -n "$PH_CTRL_CLI_ID"
else
	return 1
fi
return 0
}

function ph_cleanup_controllers {

declare PH_MODE
declare PH_XBOXDRV_PID_FILE
declare -i PH_XBOXDRV_PID

PH_MODE="${1}"
PH_XBOXDRV_PID_FILE="$("${PH_SUDO}" ls -lt /tmp/xboxdrv*.pid 2>/dev/null | nawk '{ \
		printf substr($NF,5) ; \
		exit \
	}')"
PH_XBOXDRV_PID="$(cat "${PH_XBOXDRV_PID_FILE}" 2>/dev/null)"

[[ "${PH_MODE}" != @(reset|unmap|full) || "${#}" -ne "1" ]] && \ -ef 
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "${PH_MODE}" == @(reset|full) ]]
then
	if [[ -s "${PH_CONF_DIR}/controller_cli_ids" ]]
	then
		printf "%8s%s\n" "" "--> Resetting all controller IDs"
		if ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/controller_cli_ids'"
		then
			if ph_run_with_rollback -c "ph_create_empty_file -q -t file -d '${PH_CONF_DIR}/controller_cli_ids'"
			then
				ph_run_with_rollback -c true
			fi
		else
			ph_run_with_rollback -c false -m "Could not reset" || \
				return 1
		fi
	fi
fi
if [[ "${PH_MODE}" == @(unmap|full) ]]
then
	if pgrep -f "^$(command -v xboxdrv 2>/dev/null)" >/dev/null 2>&1
	then
		printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Stopping all instances of " "'xboxdrv'"
		if "${PH_SUDO}" kill -9 "${PH_XBOXDRV_PID}" >/dev/null 2>&1
		then
			if "${PH_SUDO}" rm "${PH_XBOXDRV_PID_FILE}" >/dev/null 2>&1
			then
				ph_run_with_rollback -c true
				sleep 1
				return 0
			else
				ph_set_result -m "An error occurred trying to remove PID file '${PH_XBOXDRV_PID_FILE}' of 'xboxdrv' process '${PH_XBOXDRV_PID}'"
			fi
		else
			ph_set_result -m "An error occurred trying to kill 'xboxdrv' process '${PH_XBOXDRV_PID}'"
		fi
		ph_run_with_rollback -c false -m "Could not stop"
			return 1
	fi
fi
return 0
}

function ph_get_app_pkg_from_app_name {

declare PH_APP
declare -u PH_APPU
declare -n PH_APP_PKG

PH_APP="${1}"
PH_APPU="${PH_APP:0:4}"
PH_APP_PKG="PH_${PH_APPU}_PKG_NAME"

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	unset -n PH_APP_PKG && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

echo -n "${PH_APP_PKG}"
unset -n PH_APP_PKG
return 0
}

function ph_get_app_environment {

declare PH_APP
declare PH_APP_CMD
declare PH_APP_STR_TTY
declare PH_APP_ENV

PH_APP="${1}"
PH_APP_CMD=""
PH_APP_STR_TTY=""
PH_APP_ENV=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_APP_CMD="$(ph_get_app_cmd_from_app_name "${PH_APP}")"
then
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
	if [[ "${PH_APP_STR_TTY}" != @(1|-) ]]
	then
		if [[ "${PH_APP}" == "Bash" ]]
		then
			PH_APP_CMD="bash"
			if [[ -n "$(ps --ppid "$(pgrep -t "tty${PH_APP_STR_TTY}" -f "${PH_APP_CMD}" 2>/dev/null)" 2>/dev/null | tail -n +2)" ]]
			then
				PH_APP_ENV="tty"
			fi
		else
			PH_APP_CMD="${PH_APP_CMD//#PH_TTY#/${PH_APP_STR_TTY}}"
			if pgrep -t "tty${PH_APP_STR_TTY}" -f "${PH_APP_CMD}" >/dev/null 2>&1
			then
				PH_APP_ENV="tty"
			else
				if [[ "${PH_APP}" == "PieHelper" && \
					"$(pgrep -f "^/bin/bash .*/startpieh.sh[[:space:]]*-p$|.*/startpieh.sh[[:space:]]*-p[[:space:]]*.*$" >/dev/null; echo "$?")" -eq "0" ]]
				then
					PH_APP_ENV="pts"
				fi
			fi
		fi
	fi
fi
[[ -z "${PH_APP_ENV}" ]] && \
	return 1
echo -n "${PH_APP_ENV}"
return 0
}

function ph_check_app_state_validity {

declare PH_i
declare PH_APP
declare PH_APP_CMD
declare PH_APP_STR_TTY
declare PH_APP_TYPE
declare PH_APP_STATE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_QUIESCE
declare -i PH_FORCE_PRINT_FLAG
declare -i PH_RET_CODE
declare -l PH_APPL

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_i=""
PH_APP=""
PH_APP_CMD=""
PH_APP_STR_TTY=""
PH_APP_TYPE=""
PH_APP_STATE="Unused"
PH_OPTION=""
PH_QUIESCE="1"
PH_FORCE_PRINT_FLAG="1"
PH_RET_CODE="0"
PH_APPL=""

OPTIND="1"

while getopts :a:isuhrdqfvo PH_OPTION
do
	case "${PH_OPTION}" in i)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Integrated" ;;
			     s)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Supported" ;;
			     d)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Default" ;;
			     h)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Halted" ;;
			     v)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Reserved" ;;
			     r)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Running" ;;
			     u)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Unused" ;;
			     o)
		[[ -n "${PH_APP_TYPE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_TYPE="Out-of-scope" ;;
			     f)
		[[ "${PH_FORCE_PRINT_FLAG}" -eq "0" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_FORCE_PRINT_FLAG="0" ;;
			     q)
		[[ "${PH_QUIESCE}" -eq "0" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_QUIESCE="0" ;;
			     a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP="${OPTARG}"
		PH_APPL="${PH_APP:0:4}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || -z "${PH_APP_TYPE}" || ( "${#}" -gt "3" && "${PH_QUIESCE}" -eq "1" && "${PH_FORCE_PRINT_FLAG}" -eq "1" ) || \
	( "${#}" -gt "4" && (( "${PH_QUIESCE}" -eq "0" && "${PH_FORCE_PRINT_FLAG}" -eq "1" ) || \
	( "${PH_QUIESCE}" -eq "1" && "${PH_FORCE_PRINT_FLAG}" -eq "0" ))) || "${#}" -gt "5" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "${PH_QUIESCE}" -eq "1" ]] && \
	printf "%8s%s\n" "" "--> Checking the application state of ${PH_APP}"
case "${PH_APP_TYPE}" in Default|Out-of-scope)
	if cut -f1 "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
	then
		PH_APP_STATE="Default"
	else
		PH_APP_STATE="Out-of-scope"
	fi ;;
		*)
	if [[ "${PH_APPL}" == @(none|all|prom|cont) ]]
	then
		PH_APP_STATE="Reserved"
	else
		if ! ph_check_app_state_validity -a "${PH_APP}" -q -d
		then
			if [[ "${PH_APPL}" == @(x11|kodi|moon|emul|bash|pieh) ]]
			then
				PH_APP_STATE="Reserved"
			else
				PH_APP_STATE="Out-of-scope"
			fi
		else
			PH_APP_STATE="Default"
		fi
	fi
	if cut -f1 "${PH_CONF_DIR}/supported_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
	then
		PH_APP_STATE="Supported"
		if cut -f1 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP}$" >/dev/null
		then
			PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
			if [[ "${PH_APP_STR_TTY}" == "-" ]]
			then
				PH_APP_STATE="Integrated"
			else
				PH_APP_STATE="Halted"
				if [[ "$(ph_get_app_environment "${PH_APP}")" == @(tty|pts) ]]
				then
					PH_APP_STATE="Running"
				fi
			fi
		fi
	fi ;;
esac
if [[ "${PH_APP_TYPE}" != "${PH_APP_STATE}" ]]
then
	case "${PH_APP_STATE}" in Out-of-scope)
			[[ "${PH_APP_TYPE}" == @(Halted|Running|Integrated|Supported|Reserved|Default) ]] && \
				PH_RET_CODE="1" ;;
				Reserved)
			[[ "${PH_APP_TYPE}" != "Default" ]] && \
				PH_RET_CODE="1" ;;
				Default)
			[[ "${PH_APP_TYPE}" == @(Halted|Running|Integrated|Supported|Out-of-scope|Reserved) ]] && \
				PH_RET_CODE="1" ;;
				Supported)
			[[ "${PH_APP_TYPE}" == @(Halted|Running|Integrated|Reserved|Default|Out-of-scope) ]] && \
				PH_RET_CODE="1" ;;
				Integrated)
			[[ "${PH_APP_TYPE}" == @(Halted|Running|Reserved|Default|Out-of-scope) ]] && \
				PH_RET_CODE="1" ;;
				Running)
			[[ "${PH_APP_TYPE}" == @(Halted|Reserved|Default|Out-of-scope) ]] && \
				PH_RET_CODE="1" ;;
				Halted)
			[[ "${PH_APP_TYPE}" == @(Running|Reserved|Default|Out-of-scope) ]] && \
				PH_RET_CODE="1" ;;
				*)
			: ;;
	esac
	if [[ "${PH_APP_STATE}" == @(@(Support|Integrat|Halt)ed|Running) ]]
	then
		case "${PH_APP_TYPE}" in Default)
			ph_check_app_state_validity -a "${PH_APP}" -q -d && \
				PH_RET_CODE="0" ;;
				Out-of-scope)
			ph_check_app_state_validity -a "${PH_APP}" -q -o && \
				PH_RET_CODE="0" ;;
				*)
			: ;;
		esac
	fi
fi
if [[ "${PH_QUIESCE}" -eq "1" || "${PH_FORCE_PRINT_FLAG}" -eq "0" ]]
then
	if [[ "${PH_RET_CODE}" -eq "0" ]]
	then
		if [[ "${PH_QUIESCE}" -eq "1" ]]
		then
			ph_run_with_rollback -c true -m "'${PH_APP_STATE}' (Needed '${PH_APP_TYPE}')"
		else
			echo -n "${PH_APP_STATE}"
		fi
	else
		if [[ "${PH_QUIESCE}" -eq "1" ]]
		then
			ph_run_with_rollback -c false -m "'${PH_APP_STATE}' (Needed '${PH_APP_TYPE}')"
		else
			echo -n "${PH_APP_STATE}"
		fi
		ph_set_result -m "Application state '${PH_APP_TYPE}' is mandatory but got '${PH_APP_STATE}'"
	fi
fi
return "${PH_RET_CODE}"
}

function ph_move_app {

declare PH_APP
declare PH_APP_USER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY
declare -i PH_APP_NEW_TTY
declare -i PH_BOOT_TTY_FLAG

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_USER=""
PH_OPTION=""
PH_APP_TTY="0"
PH_APP_NEW_TTY="0"
PH_BOOT_TTY_FLAG="1"

OPTIND="1"

while getopts :t:a: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$PH_APP_NEW_TTY" -gt "0" || "$OPTARG" -le "1" || "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_NEW_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$PH_APP_NEW_TTY" -eq "0" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
[[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]] && \
	PH_BOOT_TTY_FLAG="0"
ph_run_with_rollback -c "ph_undo_setup_tty -a '${PH_APP}' -t '${PH_APP_TTY}' -u '${PH_APP_USER}'" || \
	return 1
ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -t '${PH_APP_NEW_TTY}' -u '${PH_APP_USER}'" || \
	return 1
if [[ "$PH_BOOT_TTY_FLAG" -eq "0" ]]
then
	ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_NEW_TTY}'" || \
		return 1
fi
return 0
}

function ph_set_tty_for_boot {

declare PH_i
declare -i PH_APP_TTY
declare -i PH_CUR_TTY

PH_i=""
PH_APP_TTY="$1"
PH_CUR_TTY="0"

[[ "$PH_APP_TTY" -eq "1" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -f /etc/systemd/system/getty@tty1.service.d/autostart.conf ]]
then
	[[ "$PH_APP_TTY" -eq "0" ]] && \
		return 0
	printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Creating StartApp configuration for " "'tty${PH_APP_TTY}'"
	if ph_run_with_rollback -c "ph_create_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
	then
		if ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
		then
			for PH_i in '[Service]' 'ExecStart=' 'ExecStart=-/sbin/agetty --noclear tty1 ${TERM}' "ExecStartPost=+/bin/chvt ${PH_APP_TTY}" 'TTYVTDisallocate=no' 'TTYReset=no' 'TTYVHangup=no'
			do
				if ! ph_run_with_rollback -c "ph_add_line_to_file -r -l '${PH_i}' -f '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
				then
					ph_run_with_rollback -c false -m "Could not create" || \
						return 1
				fi
			done
        		if "$PH_SUDO" chmod 644 /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null
			then
				if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
				then
					ph_add_value_to_param -p PH_SET_BOOT_TTYS -v "$PH_APP_TTY"
					ph_run_with_rollback -c true && \
						return "$?"
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			else
				ph_set_result -m "An error occurred trying to set permissions of file '/etc/systemd/system/getty@tty1.service.d/autostart.conf' to '644'"
			fi
		fi
	fi
	ph_run_with_rollback -c false -m "Could not create"
else
	PH_CUR_TTY="$(nawk '$1 ~ /^ExecStartPost=/ { \
			print $2 \
		}' /etc/systemd/system/getty@tty1.service.d/autostart.conf 2>/dev/null)"
	[[ "$PH_CUR_TTY" -eq "$PH_APP_TTY" ]] && \
		return 0
	printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Removing StartApp configuration for " "'tty${PH_CUR_TTY}'"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/systemd/system/getty@tty1.service.d/autostart.conf'"
	then
		if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
		then
			ph_run_with_rollback -c true
			ph_run_with_rollback -c "ph_disable_services 'getty@tty${PH_CUR_TTY}'" || \
				return 1
			ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_TTY}'" || \
				return 1
			ph_add_value_to_param -p PH_SET_BOOT_TTYS -v "$PH_APP_TTY"
			return 0
		else
			ph_set_result -m "An error occurred trying to reload systemd configuration"
		fi
	fi
	ph_run_with_rollback -c false -m "Could not remove"
fi
return 1
}

function ph_get_app_name_from_option {

declare PH_APP
declare PH_OPT

PH_APP=""
PH_OPT="$1"

[[ -z "$PH_OPT" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_APP="$(grep -El "^${PH_OPT}=" "${PH_CONF_DIR}/"*.conf 2>/dev/null)"
then
	if [[ -z "$PH_APP" ]]
	then
		PH_APP="$(grep -El "^\[\[.*declare.*${PH_OPT}=" "${PH_CONF_DIR}/"*.conf 2>/dev/null)"
	fi
fi
if [[ -n "$PH_APP" ]]
then
	PH_APP="${PH_APP%%.conf}"
	echo -n "${PH_APP##*/}"
else
	ph_set_result -m "An error occurred trying to determine the application name for option '${PH_OPT}'"
	return 1
fi
return 0
}

function ph_set_variable {

declare PH_VARNAME
declare PH_OLDVALUE
declare PH_VALUE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_RET_CODE

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_VARNAME=""
PH_OLDVALUE=""
PH_VALUE=""
PH_OPTION=""
PH_RET_CODE="0"

OPTIND="1"

while getopts :n:v: PH_OPTION
do
        case "$PH_OPTION" in n)
		[[ -n "$PH_VARNAME" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_VARNAME="$OPTARG" ;;
                             v)
		[[ -n "$PH_VALUE" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_VALUE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_VARNAME" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -n PH_VAR="${PH_VARNAME}"
PH_OLDVALUE="$PH_VAR"
if ! export PH_VAR="${PH_VALUE}"
then
	unset -n PH_VAR
	PH_RET_CODE="1"
else
	unset -n PH_VAR
	ph_add_value_to_param -p PH_VARIABLES -v "${PH_VARNAME}'${PH_OLDVALUE}"
fi
return "$PH_RET_CODE"
}

function ph_store_option {

declare PH_OPT_NAME

PH_OPT_NAME="$1"

[[ -z "$PH_OPT_NAME" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -f "${PH_TMP_DIR}/.stored_options" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -q -t file -d '${PH_TMP_DIR}/.stored_options'" || \
		return 1
fi
ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_TMP_DIR}/.stored_options' -l '${PH_OPT_NAME}'\\''$(eval "echo -n \"\$${PH_OPT_NAME}\"")'" || \
	return 1
ph_add_value_to_param -p PH_RETRIEVE_STORED_OPTION -v "$PH_OPT_NAME"
return 0
}

function ph_store_app_options {

declare PH_APP
declare PH_OPT

PH_APP="$1"
PH_OPT=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_OPT in $(nawk -F'=' 'BEGIN { \
		ORS = " " \
	} \
	$1 ~ /^PH_/ { \
		print $1 \
	}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
do
	ph_store_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_store_all_options {

declare PH_APP

PH_APP=""

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in Controllers $(ph_get_app_list_by_state -s Supported -t minimum)
do
	ph_store_app_options "$PH_APP" || \
		return 1
done
return 0
}

function ph_retrieve_stored_option {

declare PH_OPT_NAME
declare PH_OPT_VALUE

PH_OPT_NAME="$1"
PH_OPT_VALUE=""

[[ -z "$PH_OPT_NAME" || "$#" -ne "1" || ! -f "${PH_TMP_DIR}/.stored_options" || ! -s "${PH_TMP_DIR}/.stored_options" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_OPT_VALUE="$(nawk -F"'" -v option="^${PH_OPT_NAME}$" 'BEGIN { \
		value = "" \
	} \ 
	$1 ~ option { \
		value = $2 \
	} { \
		next \
	} END { \
		if (value ~ /^$/) { \
			exit 1 \
		} else { \
			printf value \
		} \
	}' "${PH_TMP_DIR}/.stored_options" 2>/dev/null)"
then
	ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_TMP_DIR}/.stored_options' -l '${PH_OPT_NAME}\'${PH_OPT_VALUE}'" || \
		return 1
	if [[ -f "${PH_TMP_DIR}/.stored_options" && ! -s "${PH_TMP_DIR}/.stored_options" ]]
	then
		ph_run_with_rollback -c "ph_remove_empty_file -q -t file -d '${PH_TMP_DIR}/.stored_options'" || \
			return 1
	fi
	ph_add_value_to_param -p PH_STORE_OPTION -v "$PH_OPT_NAME"
else
	ph_set_result -m "An error occurred trying to retrieve the value for option '${PH_OPT_NAME}' from '${PH_TMP_DIR}/.stored_options'"
	return 1
fi
return 0
}

function ph_retrieve_stored_app_options {

declare PH_APP
declare PH_OPT
declare PH_VALUE

PH_APP="$1"
PH_OPT=""
PH_VALUE=""

[[ -z "$PH_APP" || "$#" -ne "1" || ! -f "${PH_TMP_DIR}/.stored_options" || ! -s "${PH_TMP_DIR}/.stored_options" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_OPT in $(nawk 'BEGIN { \
		ORS =  " " ; \
		FS = "\x27" \
	} { \
		print $1 \
	}' "${PH_TMP_DIR}/.stored_options" 2>/dev/null)
do
	[[ "$(ph_get_app_name_from_option "$PH_OPT")" != "$PH_APP" ]] && \
		continue
	ph_retrieve_stored_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_retrieve_stored_options {

declare PH_OPT

PH_OPT=""

[[ "$#" -ne "0" || ! -f "${PH_TMP_DIR}/.stored_options" || ! -s "${PH_TMP_DIR}/.stored_options" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_OPT in $(nawk 'BEGIN { \
		ORS =  " " ; \
		FS = "\x27" \
	} { \
		print $1 \
	}' "${PH_TMP_DIR}/.stored_options" 2>/dev/null)
do
	ph_retrieve_stored_option "$PH_OPT" || \
		return 1
done
return 0
}

function ph_get_app_option_list_by_type {

declare PH_APP
declare PH_OPT_TYPE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -u PH_APPU

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_OPT_TYPE=""
PH_OPTION=""
PH_APPU=""

OPTIND="1"

while getopts :a:t: PH_OPTION
do
        case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}"
                PH_APPU="${PH_APP:0:4}" ;;
                             t)
		[[ -n "${PH_OPT_TYPE}" || "${OPTARG}" != r@(o|w) ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_OPT_TYPE="${OPTARG}" ;;
                             *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_OPT_TYPE}" || -z "${PH_APP}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "${PH_OPT_TYPE}" == "rw" ]]
then
	read -r -a PH_TYPE_OPTIONS -d';' < <(nawk -F'=' -v mstring="^PH_${PH_APPU}_.*=" '$0 ~ mstring { \
			print $1 \
		} { \
			next \
		} END { \
			print ";" \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
		ph_set_result -m "An error occurred trying to determine a list of ${PH_OPT_TYPE} options for '${PH_APP}'"
		return 1
else
	read -r -a PH_TYPE_OPTIONS -d';' < <(nawk -v mstring="^declare([[:space:]])+-(r)*(i)*(r)*([[:space:]])+PH_${PH_APPU}_.*=" '$0 ~ mstring { \
			print substr($3,0,(index($3,"=")-1)) \
		} { \
			next \
		} END { \
			print ";" \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
fi
if [[ "${#PH_TYPE_OPTIONS[@]}" -eq "0" ]]
then
	unset PH_TYPE_OPTIONS
	return 1
fi
echo -n "${PH_TYPE_OPTIONS[@]}"
unset PH_TYPE_OPTIONS
return 0
}

function ph_get_option_type {

declare PH_OPT
declare PH_OPT_TYPE

PH_OPT="${1}"
PH_OPT_TYPE=""

[[ -z "${PH_OPT}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if grep -E "^${PH_OPT}=" "${PH_CONF_DIR}/"*".conf" >/dev/null 2>&1
then
	PH_OPT_TYPE="rw"
else
	if grep -E "^declare([[:space:]])*-(r)*(i)*(r)*([[:space:]])*${PH_OPT}=" "${PH_CONF_DIR}/"*".conf" >/dev/null 2>&1
	then
		PH_OPT_TYPE="ro"
	fi
fi
if [[ -n "${PH_OPT_TYPE}" ]]
then
	echo -n "${PH_OPT_TYPE}"
	return 0
fi
return 1
}

function ph_get_option_value_from_app_conf_file {

declare PH_OPT
declare PH_VALUE
declare PH_OPT_TYPE
declare PH_APP
declare PH_RESOLVE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_OPT=""
PH_VALUE=""
PH_OPT_TYPE=""
PH_APP=""
PH_RESOLVE="no"
PH_OPTION=""

OPTIND="1"

while getopts :o:a:r PH_OPTION
do
        case "${PH_OPTION}" in o)
		[[ -n "${PH_OPT}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_OPT="${OPTARG}" ;;
                             a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}" ;;
                             r)
		[[ "${PH_RESOLVE}" == "yes" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_RESOLVE="yes" ;;
                             *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_OPT}" || -z "${PH_APP}" || "${#}" -gt "5" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if grep -E ^"${PH_OPT}=" "${PH_CONF_DIR}/${PH_APP}.conf" >/dev/null 2>&1
then
	PH_OPT_TYPE="read-write"
else
	PH_OPT_TYPE="read-only"
fi
while true
do
	if [[ "${PH_OPT_TYPE}" == "read-only" ]]
	then
		PH_VALUE="$(nawk -v comp="^\[\[.*declare.*([[:space:]])+${PH_OPT}=" 'BEGIN { \
				FS = "\x27" \
			} \
			$0 ~ comp { \
				print $2 \
			}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)" && \
			break
	else
		PH_VALUE="$(nawk -v opt="^$PH_OPT=" 'BEGIN { \
				FS = "\x27" \
			} \
			$1 ~ opt { \
				print $2 \
			}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)" && \
			break
	fi
	ph_set_result -m "An error occurred trying to retrieve the value of ${PH_OPT_TYPE} option ${PH_OPT} from '${PH_CONF_DIR}/${PH_APP}.conf'"
	return 1
done
if [[ "${PH_RESOLVE}" == "yes" ]]
then
	PH_VALUE="$(ph_resolve_dynamic_value "${PH_VALUE}")"
fi
echo -n "${PH_VALUE}"
return 0
}

function ph_set_option_to_default_value {

declare PH_OPT
declare PH_APP
declare PH_VALUE
declare PH_DEF_VALUE

PH_OPT="$1"
PH_APP=""
PH_VALUE="$(eval "echo -n \"\$${PH_OPT}\"")"
PH_DEF_VALUE="$(grep -E "^${PH_OPT}:" "${PH_CONF_DIR}/options.defaults" 2>/dev/null | cut -d":" -f2-)"

[[ -z "$PH_OPT" || "$#" -ne "1" || -z "$PH_DEF_VALUE" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP="$(ph_get_app_name_from_option "$PH_OPT")" || \
	return 1
export "OLD_${PH_OPT}=${PH_VALUE}"
ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"${PH_OPT}'${PH_DEF_VALUE}\"" || \
	return 1
unset "OLD_${PH_OPT}"
return 0
}

function ph_set_app_options_to_default_value {

declare PH_APP
declare PH_OPT

PH_APP="$1"
PH_OPT=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_OPT in $(nawk -F'=' 'BEGIN { \
		ORS = " " \
		} \
		$1 ~ /^PH_/ { \
			print $1 \
		}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
do
	ph_set_option_to_default_value "$PH_OPT" || \
		return 1
done
return 0
}

function ph_set_all_options_to_default_value {

declare PH_APP

PH_APP=""

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in Controllers $(ph_get_app_list_by_type -s Supported -t minimum)
do
	ph_set_app_options_to_default_value "$PH_APP" || \
		return 1
done
return 0
}

function ph_show_menu {

declare PH_i
declare PH_MENU
declare PH_MENU_LINE
declare PH_MENU_KEYWORD
declare PH_MENU_APP
declare PH_MENU_TYPE
declare PH_MENU_HEADER
declare PH_MENU_PARENT
declare PH_MENU_CMD
declare PH_MENU_ITEM
declare PH_LAST_RETURN
declare -i PH_ANSWER
declare -i PH_COUNT
declare -i PH_RET_CODE
declare -i PH_COLUMNS
declare -i PH_MENU_COUNT

PH_i=""
PH_MENU="${1}"
PH_MENU_LINE=""
PH_MENU_KEYWORD=""
PH_MENU_APP=""
PH_MENU_TYPE=""
PH_MENU_HEADER=""
PH_MENU_PARENT=""
PH_MENU_CMD=""
H_MENU_ITEM=""
PH_LAST_RETURN="${PH_LAST_RETURN_GLOB}"
PH_ANSWER="0"
PH_COUNT="0"
PH_RET_CODE="0"
PH_COLUMNS="$(tput cols 2>/dev/null)"
PH_MENU_COUNT="0"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

unset PH_LAST_RETURN_GLOB 2>/dev/null
if [[ "${PH_MENU}" == "Main" ]]
then
	PH_MENU_TYPE="menu"
	PH_MENU_HEADER="PieHelper ${PH_VERSION} > ${PH_MENU} ${PH_MENU_TYPE}"
else
	PH_MENU_TYPE="submenu"
	case "${PH_MENU}" in System|Support|Applications|Controllers)
		PH_MENU_APP="${PH_MENU}"
		PH_MENU_PARENT="Main" ;;
			SystemRetaineds)
		PH_MENU_PARENT="System"
		PH_MENU_APP="Retain System" ;;
			SystemRetained|SystemInteractive)
		PH_MENU_PARENT="System"
		PH_MENU_APP="${PH_MENU#System} ${PH_MENU_PARENT} Management" ;;
			StatusManagement_*|OptionsManagement_*|TTYManagement_*)
		PH_MENU_PARENT="${PH_MENU##*_}"
		if [[ "${PH_MENU_PARENT}" == "Controllers" ]]
		then
			PH_MENU_APP="${PH_MENU_PARENT%s} ${PH_MENU%%Management*}"
		else
			PH_MENU_APP="${PH_MENU_PARENT} ${PH_MENU%%Management*}"
		fi ;;
			PS3|PS4|XBOX360|XBOXSX)
		PH_MENU_PARENT="Controller Status"
		PH_MENU_APP="${PH_MENU} Status" ;;
			StatusManagement|TTYManagement|OptionsManagement)
		if PH_MENU_PARENT="$(ph_get_linked_menu_app)"
		then
			if [[ "${PH_MENU_PARENT}" == "Controllers" ]]
			then
				PH_MENU_APP="${PH_MENU_PARENT%s} ${PH_MENU%%Management}"
			else
				PH_MENU_APP="${PH_MENU_PARENT} ${PH_MENU%%Management}"
			fi
			PH_MENU="${PH_MENU}_${PH_MENU_PARENT}"
		else
			return 1
		fi ;;
			Out-of-scope|Default|Supported|Integrated|Halted|Running)
		PH_MENU_PARENT="Applications"
		PH_MENU_APP="${PH_MENU} ${PH_MENU_PARENT}" ;;
			*)
		PH_MENU_APP="${PH_MENU}"
		if [[ "${#BASH_ARGC[@]}" -gt "0" ]]
		then
			PH_MENU_PARENT="Applications"
		else
			PH_MENU_PARENT="${BASH_ARGC[1]} Applications"
		fi ;;
	esac
	PH_MENU_HEADER="PieHelper ${PH_VERSION} > ${PH_MENU_PARENT} ${PH_MENU_TYPE} : ${PH_MENU_APP}"
fi
while true
do
	if [[ -n "${PH_MENU_PARENT}" ]]
	then
		PH_MENU_HEADER="PieHelper ${PH_VERSION} > ${PH_MENU_PARENT} ${PH_MENU_TYPE} : ${PH_MENU_APP}"
	fi
	case "${PH_MENU}" in StatusManagement*|OptionsManagement*|TTYManagement*)
		ph_run_with_rollback -c "ph_link_app_to_menu -a '${PH_MENU_PARENT}' -q" || \
			return 1 ;;
			*)
		if [[ "${PH_MENU}" == @($(ph_get_app_list_by_state -s Unused -t minimum | sed "s/ /|/g")|Controllers) ]]
		then
			ph_run_with_rollback -c "ph_link_app_to_menu -a '${PH_MENU}' -q" || \
				return 1
		fi ;;
	esac
	declare -a PH_MENU_LINES
	case "${PH_MENU}" in Out-of-scope|Default|Supported|Integrated|Halted|Running)
		case "${PH_MENU}" in Out-of-scope)
			PH_MENU_KEYWORD="oos" ;;
				     *)
			PH_MENU_KEYWORD="$(cut -c1-3<<<"${PH_MENU}" | tr '[:upper:]' '[:lower:]')" ;;
		esac
		for PH_MENU_LINE in "List all ${PH_MENU} applications:confapps_ph.sh -r list -l ${PH_MENU_KEYWORD}" \
			"List packaged ${PH_MENU} applications:confapps_ph.sh -r list -l ${PH_MENU_KEYWORD} -s pkg" \
			"List unpackaged ${PH_MENU} applications:confapps_ph.sh -r list -l ${PH_MENU_KEYWORD} -s unpkg" \
			"List installed ${PH_MENU} applications:confapps_ph.sh -r list -l ${PH_MENU_KEYWORD} -s inst" \
			"List uninstalled ${PH_MENU} applications:confapps_ph.sh -r list -l ${PH_MENU_KEYWORD} -s uninst" \
			"Install ${PH_MENU} applications:confapps_ph.sh -r inst -l ${PH_MENU_KEYWORD} -s uninst" \
			"Uninstall ${PH_MENU} applications:confapps_ph.sh -r uninst -l ${PH_MENU_KEYWORD} -s inst"
		do
			[[ "${PH_MENU}" == "Running" && "${PH_MENU_LINE}" == @(Uninstall|Install)* ]] && \
				continue
			PH_MENU_LINES+=("${PH_MENU_LINE}")
		done
		declare -a PH_APPS_LIST
		PH_APPS_LIST=($(ph_get_app_list_by_state -s "${PH_MENU}" -t minimum))
		for PH_i in "${PH_APPS_LIST[@]}"
		do
			PH_MENU_LINES+=("Go to ${PH_i}:ph_show_menu \"${PH_i}\"")
		done
		unset PH_APPS_LIST ;;
			     *)
		if [[ "${PH_MENU}" == "Applications" ]]
		then
			for PH_MENU_LINE in "List all applications:confapps_ph.sh -r list -l all | more" \
				"List all packaged applications:confapps_ph.sh -r list -l all -s pkg | more" \
				"List all unpackaged applications:confapps_ph.sh -r list -l all -s unpkg | more" \
				"List all installed applications:confapps_ph.sh -r list -l all -s inst | more" \
				"List all uninstalled applications:confapps_ph.sh -r list -l all -s uninst | more" \
				"List the Start application:confapps_ph.sh -r list -l start | more" \
				"Set the Start application:confapps_ph.sh -r start -a prompt" \
				"Unset the Start application:confapps_ph.sh -r unstart -l start"
			do
				PH_MENU_LINES+=("${PH_MENU_LINE}")
			done
			for PH_i in Running Halted Integrated Supported Default Out-of-scope
			do
				if [[ -n "$(ph_get_app_list_by_state -s "${PH_i}" -t minimum)" ]]
				then
					PH_MENU_LINES+=("Go to ${PH_i} Applications:ph_show_menu ${PH_i}")
				fi
			done
		fi ;;
	esac
	declare -a PH_MENU_ITEMS PH_MENU_CMDS
	if [[ -e "${PH_MENUS_DIR}/${PH_MENU}.lst" ]]
	then
		for PH_i in ITEM CMD
		do
			if [[ "${PH_i}" == "ITEM" ]]
			then
				PH_COUNT="1"
			else
				PH_COUNT="2"
			fi
			while read -r
			do
				eval "PH_MENU_${PH_i}S+=(\"${REPLY}\")"
			done < <(cut -d':' "-f${PH_COUNT}" "${PH_MENUS_DIR}/${PH_MENU}.lst")
		done
	fi
	if [[ ! ( -e "${PH_MENUS_DIR}/${PH_MENU}.lst" ) || \
		"${PH_MENU}" == @(@(TTY|Options|Status)Management_|)@($(ph_get_app_list_by_state -s Unused -t minimum | sed "s/ /|/g")) ]]
	then
		if [[ "${PH_MENU}" == @(Applications|$(ph_get_app_list_by_state -s Unused -t minimum | sed "s/ /|/g")) ]]
		then
			for PH_i in Running Halted Integrated Supported Default Out-of-scope
			do
				if ph_check_app_state_validity -a "${PH_MENU}" -q "-$(cut -c1<<<"${PH_i}" | tr '[:upper:]' '[:lower:]')"
				then
					PH_MENU_LINES+=("Go to ${PH_i} Applications:ph_show_menu ${PH_i}")
				fi
			done
		fi
		if [[ "${PH_MENU}" == @($(ph_get_app_list_by_state -s Unused -t minimum | sed "s/ /|/g")) && \
			"${PH_MENU_PARENT}" != "Applications" ]]
		then
			PH_MENU_LINES+=("Go to ${PH_MENU_PARENT}:ph_show_menu ${PH_MENU_PARENT% *}")
		else
			if [[ "${PH_MENU}" != "Applications" ]]
			then
				PH_MENU_LINES+=("Go to Applications:ph_show_menu Applications")
			fi
		fi
		for PH_MENU_LINE in "Go to Main:ph_show_menu Main" \
			"Open a shell (Type 'CTRL-D' to return):echo;cd;/bin/bash" \
			"Quit:break" "Return to previous screen:return"
		do
			PH_MENU_LINES+=("${PH_MENU_LINE}")
		done
	fi
	if [[ "${#PH_MENU_LINES[@]}" -gt "0" ]]
	then
		for PH_MENU_LINE in "${PH_MENU_LINES[@]}"
		do
			PH_MENU_ITEMS+=("$(cut -d':' -f1<<<"${PH_MENU_LINE}")")
			PH_MENU_CMDS+=("$(cut -d':' -f2<<<"${PH_MENU_LINE}")")
		done
	fi
	unset PH_MENU_LINES
	PH_MENU_COUNT="${#PH_MENU_ITEMS[@]}"
	clear
	ph_print_bannerline
	printf "\n%$(echo -n $(($((PH_COLUMNS/2))-$(($(echo -n ${PH_MENU_HEADER} | wc -c)/2)))))s\033[1;036m%s\033[0;0m\n\n" "" "${PH_MENU_HEADER}"
	ph_print_bannerline
	printf "\n"
	if [[ "${PH_MENU}" == @(Out-of-scope|Default|Supported|Integrated|Halted|Running) && \
		-z "$(ph_get_app_list_by_state -s "${PH_MENU}" -t minimum)" ]]
	then
		printf "%-4s\033[0;33m%-30s\033[0m\n" "" "Warning : No known ${PH_MENU} applications"
	fi
	for ((PH_COUNT=0;PH_COUNT<="$((PH_MENU_COUNT-1))";PH_COUNT++))
	do
		printf "\033[1;37m%-4s%-30s\033[0m\n" "$((PH_COUNT+1)). " "${PH_MENU_ITEMS["${PH_COUNT}"]}"
	done
	PH_ANSWER="0"
	PH_COUNT="0"
	while [[ "${PH_ANSWER}" -lt "1" || "${PH_ANSWER}" -gt "${PH_MENU_COUNT}" ]]
	do
		if [[ "${PH_COUNT}" -gt "0" ]]
		then
			printf "\b\r%s\033[33m%s\033[0m" "Your Choice : " "Invalid response"
			sleep 2
			printf "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b%s\r" "                "
		else
			printf "\n"
		fi
		printf "%s" "Your Choice : "
		read -r PH_ANSWER 2>/dev/null
		((PH_COUNT++))
	done
	PH_MENU_CMD="${PH_MENU_CMDS["$((PH_ANSWER-1))"]}"
	PH_MENU_ITEM="${PH_MENU_ITEMS["$((PH_ANSWER-1))"]}"
	unset PH_MENU_ITEMS PH_MENU_CMDS
	if [[ "${PH_ANSWER}" -ne "${PH_MENU_COUNT}" ]]
	then
		if [[ "${PH_MENU_CMD}" != ph_show_menu* && "${PH_MENU_ITEM}" != Show*manual && "${PH_ANSWER}" -lt "$((PH_MENU_COUNT-2))" ]]
		then
			printf "\n\033[1;37m%s\033[0;0m\n\n" "Output of running commands :"
			ph_print_bannerline
			printf "\n"
			shopt -u extdebug
		fi
		eval "${PH_MENU_CMD}"
		PH_RET_CODE="${?}"
		if [[ "${PH_MENU_CMD}" != ph_show_menu* && "${PH_MENU_ITEM}" != Show*manual && "${PH_ANSWER}" -lt "$((PH_MENU_COUNT-2))" ]]
		then
			shopt -s extdebug
			printf "\n"
			ph_print_bannerline
			printf "\n"
		fi
	else
		if [[ -z "${PH_LAST_RETURN}" ]]
		then
			eval "${PH_MENU_CMD}" "${PH_ANSWER}" 2>/dev/null
		else
			printf "\n"
			ph_print_bannerline
			printf "\n\033[33m%s\033[0m\n\n" "Already on first screen"
			ph_print_bannerline
			printf "\n"
			PH_ANSWER="0"
		fi
	fi
	if [[ "${PH_MENU_CMD}" != ph_show_menu* && "${PH_ANSWER}" -lt "$((PH_MENU_COUNT-2))" ]]
	then
		printf "\033[1;37m%s\033[0;0m\n" "Press Enter to continue"
		read -r 2>/dev/null
	fi
done
shopt -u extdebug
ph_quit_pieh
}

function ph_do_escape_paths {

[[ "${#}" -eq "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

echo "${@}"| sed 's/\//\\\//g;s/ /\\ /g'
return 0
}

function ph_undo_escape_paths {

[[ "${#}" -eq "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

echo "${@}" | sed 's/\\//g'
return 0
}


function ph_unconfigure_pieh {

declare PH_i
declare PH_ANSWER
declare PH_CONF_STATE
declare PH_ACTION
declare PH_MODE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_i=""
PH_ANSWER=""
PH_CONF_STATE=""
PH_ACTION=""
PH_MODE=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"
PH_ROLLBACK_USED="yes"

while getopts :urb PH_OPTION
do
        case "${PH_OPTION}" in r)
		[[ -n "${PH_ACTION}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_ACTION="remove" ;;
			     u)
		[[ -n "${PH_ACTION}" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_ACTION="unconfigure" ;;
			     b)
		[[ -n "${PH_MODE}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_MODE="batch" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_ACTION}" || ( -z "${PH_MODE}" && "${#}" -ne "1" ) || \
	( -n "${PH_MODE}" && "${#}" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "${PH_MODE}" ]] && \
	PH_MODE="normal"
PH_CONF_STATE="$(ph_get_pieh_conf_state -q)"
if [[ "${PH_MODE}" == "normal" ]]
then
	if [[ "${PH_CONF_STATE}" == "unconfigured" && "${PH_ACTION}" == "unconfigure" ]]
	then
		ph_set_result -r 0 -w -m "PieHelper is already ${PH_CONF_STATE}"
		return 0
	fi
fi
if [[ "${PH_CONF_STATE}" == "configured" ]]
then
	if [[ "${PH_MODE}" == "normal" ]]
	then
		printf "\033[1;37m%2s%s\n\n" "" "This will :"
		printf "%4s%s\n" "" "- Stop all running applications"
		printf "%4s%s\n" "" "- Unconfigure the current StartApp if one is set"
		printf "%4s%s\n" "" "- Reset all application and controller options to default values"
		printf "%4s%s\n" "" "- Remove all items for controller management"
		printf "%4s%s\n" "" "- Unintegrate all integrated applications"
		printf "%4s%s\n" "" "- Unsupport all supported applications"
		printf "%4s%s\n" "" "- Remove all base configuration files"
		printf "%4s%s\033[33m%s\033[37m\n" "" "- Remove the PATH and LD_LIBRARY_PATH extension for " "'PieHelper'"
		printf "%4s%s\033[33m%s\033[37m%s\n" "" "- Restore system settings and scripts modified at " "'PieHelper'" " installation time to their original state"
		printf "%4s%s\n" "" "- Enable the graphical environment"
		[[ "${PH_ACTION}" == "remove" ]] && \
			printf "%4s%s\033[33m%s\033[37m%s\n" "" "- Remove directory " "'${PH_BASE_DIR}'" " and it's contents"
		printf "%4s%s\033[0m\n\n" "" "- Reboot your system"
		while [[ "${PH_ANSWER}" != @(y@(es|)|n@(o|)) ]]
		do
			[[ "${PH_COUNT}" -gt "0" ]] && \
				printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
			if [[ "${PH_ACTION}" == "unconfigure" ]]
			then
				printf "%8s%s\033[1;37m%s\033[0m%s" "" "--> Continue with PieHelper unconfiguration " "(y/n)" " ? "
			else
				printf "%8s%s\033[1;37m%s\033[0m%s" "" "--> Continue with PieHelper removal " "(y/n)" " ? "
			fi
			read -r PH_ANSWER 2>/dev/null
			ph_screen_input "${PH_ANSWER}" || \
				return 1
			((PH_COUNT++))
		done
		ph_run_with_rollback -c true -m "${PH_ANSWER}"
		if [[ "${PH_ANSWER}" == n@(o|) ]]
		then
			ph_set_result -w -m "Quitting at user request"
			ph_show_result
			return "${?}"
		fi
	fi
	ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.unconfigure_in_progress'" || \
		return 1
	ph_stop_all_running_apps forced || \
		return 1
	ph_run_with_rollback -c "ph_set_app_for_start none" || \
		return 1
	ph_set_all_options_to_default_value || \
		return 1
	ph_run_with_rollback -c "ph_remove_app_items -a Controllers -t support" || \
		return 1
	ph_run_with_rollback -c "ph_unintegrate_app -a integrated" || \
		return 1
	ph_run_with_rollback -c "ph_unsupport_app -a supported" || \
		return 1
	for PH_i in cont os int defaults alloweds sup
	do
		ph_run_with_rollback -c "ph_store_file -f '${PH_CONF_DIR}/$(ph_get_filename_from_shortname "${PH_i}")'" || \
			return 1
	done
	for PH_i in path logind
	do
		ph_run_with_rollback -c "ph_pieh_unconfigured_${PH_i}_conf" || \
			return 1
	done
	ph_run_with_rollback -c "ph_remove_empty_file -t link -d '${PH_CONF_DIR}/distros/${PH_DISTRO.conf}'" || \
		return 1
	if [[ -f "${PH_FILES_DIR}/stored/10-retropie_sh" ]]
	then
		ph_run_with_rollback -c "ph_pieh_unconfigured_emul_conf" || \
			return 1
	fi
	for ((PH_COUNT=2;PH_COUNT<="${PH_PIEH_MAX_TTYS}";PH_COUNT++))
	do
		ph_run_with_rollback -c "ph_disable_services 'getty@tty${PH_COUNT}'" || \
			return 1
	done
	ph_run_with_rollback -c "ph_enable_services 'getty@tty1'" || \
		return 1
	ph_run_with_rollback -c "ph_set_bootenv graphical.target" || \
		return 1
	ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.unconfigure_in_progress'" || \
		return 1
	if [[ "${PH_APP}" == "PieHelper" && ! -f "${PH_TMP_DIR}/.first_run" ]]
	then
		ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.first_run'" || \
			return 1
	fi
fi
if [[ "${PH_ACTION}" != "remove" && "${PH_BATCH}" == "no" ]]
then
	printf "\033[1;37m%s\033[33m%s\033[0m\n\n" "" "PieHelper can be reconfigured by running " "'${PH_SCRIPTS_DIR}/confpieh_ph.sh -c'"
	printf "\033[1;37m%s\033[33m%s\033[37m%s\033[0m\n" "Press " "'Enter'" " to reboot into the graphical environment"
	read -r 2>/dev/null
	"${PH_SUDO}" chvt 1 2>/dev/null
	"${PH_SUDO}" init 6 2>/dev/null
else
	return 0
fi
}

function ph_pieh_unconfigured_path_conf {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ -f "/etc/profile.d/PieHelper-path.sh" ]]
then
	printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing the PATH and LD_LIBRARY_PATH extension for " "'PieHelper'" " as " "'/etc/profile.d/PieHelper-path.sh'"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/profile.d/PieHelper-path.sh'"
	then
		ph_add_value_to_param -p PH_CONFIGURED_STATE -v path
		ph_run_with_rollback -c true
	else
		ph_run_with_rollback -c false -m "Could not remove"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return "${?}"
}

function ph_rollback_changes {

declare PH_i
declare PH_CMD
declare PH_PARAMS
declare PH_MOVE_SCRIPTS_REGEX
declare PH_RUN_SECURE
declare PH_RUN_GIT_COMMIT_LOCAL
declare PH_RUN_GIT_COMMIT_MASTER
declare PH_RUN_GIT_ADD_LOCAL
declare PH_RUN_GIT_TAG_LOCAL
declare PH_ROLLBACK_TIME
declare PH_GIT_REPO_DIR
declare PH_GIT_REPO_NAME
declare PH_GIT_REPO_ARGS
declare PH_GIT_REPO
declare PH_LINE
declare PH_FILE
declare PH_FILE_TYPE
declare PH_FILE_SOURCE
declare PH_FILE_DEST
declare PH_APP
declare PH_APP_USER
declare PH_APP_USER_GROUPS
declare PH_APP_CMD
declare PH_APP_PKG
declare PH_APP_INST_STATE
declare PH_APP_STR_TTY
declare PH_STOP_MODE
declare PH_ACTION
declare PH_OPTION
declare PH_OPTION_VALUE
declare PH_VAR_NAME
declare PH_VAR_VALUE
declare PH_OPT
declare PH_VALUE
declare -i PH_PARAM_INDEX
declare -i PH_DATA_INDEX
declare -i PH_APP_TTY
declare -i PH_PKG_FLAG
declare -i PH_RET_CODE
declare -a PH_RUN_ACLS

PH_i=""
PH_CMD=""
PH_PARAMS=""
PH_MOVE_SCRIPTS_REGEX=""
PH_RUN_SECURE=""
PH_RUN_GIT_COMMIT_LOCAL=""
PH_RUN_GIT_COMMIT_MASTER=""
PH_RUN_GIT_ADD_LOCAL=""
PH_RUN_GIT_TAG_LOCAL=""
PH_ROLLBACK_TIME=""
PH_GIT_REPO_DIR=""
PH_GIT_REPO_NAME=""
PH_GIT_REPO_ARGS=""
PH_GIT_REPO=""
PH_LINE=""
PH_FILE=""
PH_FILE_TYPE=""
PH_FILE_SOURCE=""
PH_FILE_DEST=""
PH_APP=""
PH_APP_USER=""
PH_APP_USER_GROUPS=""
PH_APP_CMD=""
PH_APP_PKG=""
PH_APP_INST_STATE=""
PH_APP_STR_TTY=""
PH_STOP_MODE=""
PH_ACTION=""
PH_OPTION=""
PH_OPTION_VALUE=""
PH_VAR_NAME=""
PH_VAR_VALUE=""
PH_OPT=""
PH_VALUE=""
PH_PARAM_INDEX="0"
PH_DATA_INDEX="0"
PH_APP_TTY="0"
PH_PKG_FLAG="1"
PH_RET_CODE="0"

PH_ROLLBACK_USED="no"

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in "${PH_DEPTH_PARAMS[@]}"
do
	if [[ "${PH_i}" == PH_@(INSTALL|REMOVE)_PKGS ]]
	then
		ph_update_pkg_index
		PH_RET_CODE="${?}"
		break
	fi

done
if [[ "${PH_RET_CODE}" -eq "0" ]]
then
	for PH_PARAM_INDEX in $(echo -n "${!PH_DEPTH_PARAMS[*]} " | tac -s " ")
	do
		PH_OPT="${PH_DEPTH_PARAMS["${PH_PARAM_INDEX}"]}"
		declare -n PH_DATA_ARRAY="${PH_OPT}"
		PH_DATA_INDEX="$(echo "${!PH_DATA_ARRAY[@]}" | nawk '{ \
				printf $NF \
			}')"
		PH_VALUE="${PH_DATA_ARRAY["${PH_DATA_INDEX}"]}"
		case "${PH_OPT}" in PH_APPS_ACTION)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_ACTION="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_STOP_MODE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_do_app_action '${PH_ACTION}' '${PH_APP}' '${PH_STOP_MODE}'" ;;
				  PH_UNBLACKLIST_MODULES)
			PH_CMD="ph_unblacklist_kernel_module '${PH_VALUE}'" ;;
				  PH_BLACKLIST_MODULES)
			PH_CMD="ph_blacklist_kernel_module '${PH_VALUE}'" ;;
				  PH_REMOVE_RIGHTS_USERS)
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_remove_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_CREATE_RIGHTS_USERS)
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_create_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REMOVE_ACLS_USERS)
			PH_ROLLBACK_TIME="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_FILE="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_PARAMS="${PH_PARAMS} -u '${PH_APP_USER}'"
			case "${PH_ROLLBACK_TIME}" in immediate)
				[[ -n "${PH_FILE}" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_user_acls -p remove ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_ACLS+=("remove'${PH_APP_USER}")
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_CREATE_ACLS_USERS)
			PH_ROLLBACK_TIME="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_FILE="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_PARAMS="${PH_PARAMS} -u '${PH_APP_USER}'"
			case "${PH_ROLLBACK_TIME}" in immediate)
				[[ -n "${PH_FILE}" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_user_acls -p create ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_ACLS+=("create'${PH_APP_USER}")
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_GIT_COMMIT_LOCAL)
			PH_RUN_GIT_COMMIT_LOCAL="${PH_VALUE}"
			PH_CMD="continue" ;;
				  PH_SET_BOOT_TTYS)
			PH_CMD="ph_set_tty_for_boot '${PH_VALUE}'" ;;
				  PH_MODIFY_APPS_SCRIPT)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_TTY="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_modify_app_script -a '${PH_APP}' -t '${PH_APP_TTY}'" ;;
				  PH_GIT_COMMIT_MASTER)
			PH_RUN_GIT_COMMIT_MASTER="${PH_VALUE}"
			PH_CMD="continue" ;;
				  PH_GIT_ADD_LOCAL)
			PH_RUN_GIT_ADD_LOCAL="${PH_VALUE}"
			PH_CMD="continue" ;;
				  PH_GRANT_APPS_ACCESS)
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_grant_pieh_access -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REVOKE_APPS_ACCESS)
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_revoke_pieh_access -u '${PH_APP_USER}' ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_FROM_SUP_FILE)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_INST_STATE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			for PH_i in USER INST_STATE CMD
			do
				[[ -n "$(eval "echo -n \"\$PH_APP_${PH_i}\"")" ]] && \
					PH_PARAMS="${PH_PARAMS} -$(cut -c1<<<"${PH_i}" | tr "[:upper:]" "[:lower:]") '\$PH_APP_${PH_i}'"
			done
			PH_CMD="ph_remove_app_from_support_file ${PH_PARAMS}" ;;
				  PH_ADD_APPS_TO_SUP_FILE)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_INST_STATE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_PARAMS="-a '${PH_APP}' -u '${PH_APP_USER}' -c '${PH_APP_CMD}'"
			[[ -n "$PH_APP_INST_STATE" ]] && \
				PH_PARAMS="${PH_PARAMS} -i '${PH_APP_INST_STATE}'"
			PH_CMD="ph_add_app_to_support_file ${PH_PARAMS}" ;;
				  PH_ADD_APPS_TO_INT_FILE)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_STR_TTY="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			[[ -n "${PH_APP_STR_TTY}" ]] && \
				PH_PARAMS="${PH_PARAMS} -t '${PH_APP_STR_TTY}'"
			PH_CMD="ph_add_app_to_integration_file ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_FROM_INT_FILE)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_STR_TTY="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			[[ -n "${PH_APP_STR_TTY}" ]] && \
				PH_PARAMS="${PH_PARAMS} -t '${PH_APP_STR_TTY}'"
			PH_CMD="ph_remove_app_from_integration_file ${PH_PARAMS}" ;;
				  PH_ADD_LINES)
			PH_FILE="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_LINE="$(echo -n "${PH_VALUE}" | cut -f3- -d"'")"
			PH_CMD="ph_add_line_to_file ${PH_PARAMS} -f '${PH_FILE}' -l '${PH_LINE}'" ;;
				  PH_REMOVE_LINES)
			PH_FILE="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_LINE="$(echo -n "${PH_VALUE}" | cut -f3- -d"'")"
			PH_CMD="ph_remove_line_from_file ${PH_PARAMS} -f '${PH_FILE}' -l '${PH_LINE}'" ;;
				  PH_GIT_TAG_LOCAL)
			PH_RUN_GIT_TAG_LOCAL="${PH_VALUE}"
			PH_CMD="continue" ;;
				  PH_APP_MOUNT_CIFS)
			PH_CMD="ph_mount_cifs_share '${PH_VALUE}'" ;;
				  PH_APP_UMOUNT_CIFS)
			PH_CMD="ph_umount_cifs_share '${PH_VALUE}'" ;;
				  PH_REMOVE_OOS_APPS_CODE)
			PH_CMD="ph_remove_oos_app_code '${PH_VALUE}'" ;;
				  PH_CREATE_OOS_APPS_CODE)
			PH_CMD="ph_create_oos_app_code '${PH_VALUE}'" ;;
				  PH_SECURE)
			PH_ROLLBACK_TIME="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_FILE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			case "${PH_ROLLBACK_TIME}" in immediate)
				[[ -n "${PH_FILE}" ]] && \
					PH_PARAMS="${PH_PARAMS} -f '${PH_FILE}'"
				PH_CMD="ph_secure_pieh ${PH_PARAMS}" ;;
					   delayed)
				PH_RUN_SECURE="yes"
				PH_CMD="continue" ;;
					   never)
				PH_CMD="continue" ;;
			esac ;;
				  PH_START_SERVICES)
			PH_CMD="ph_start_services '${PH_VALUE}'" ;;
				  PH_STOP_SERVICES)
			PH_CMD="ph_stop_services '${PH_VALUE}'" ;;
				  PH_INSTALL_APPS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			declare -a PH_ROUTINE_OPTS
			for PH_i in CMD USER PKG
			do
				declare -n PH_PARAM
				PH_PARAM="PH_APP_${PH_i}"
				if [[ -n "${PH_PARAM}" ]]
				then
					PH_ROUTINE_OPTS+=("-$(cut -c1<<<"${PH_i}" | tr '[:upper:]' '[:lower:]')" "'${PH_PARAM}'") 
				fi
				unset -n PH_PARAM	
			done
			PH_CMD="ph_install_app -a '${PH_APP}' ${PH_ROUTINE_OPTS[*]}"
			unset PH_ROUTINE_OPTS ;;
				  PH_UNINSTALL_APPS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			declare -a PH_ROUTINE_OPTS
			for PH_i in CMD USER PKG
			do
				declare -n PH_PARAM
				PH_PARAM="PH_APP_${PH_i}"
				if [[ -n "${PH_PARAM}" ]]
				then
					PH_ROUTINE_OPTS+=("-$(cut -c1<<<"${PH_i}" | tr '[:upper:]' '[:lower:]')" "'${PH_PARAM}'") 
				fi
				unset -n PH_PARAM	
			done
			PH_CMD="ph_uninstall_app -a '${PH_APP}' ${PH_ROUTINE_OPTS[*]}"
			unset PH_ROUTINE_OPTS ;;
				  PH_LINK_MENUS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_link_app_to_menu -a '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_UNDO_LINK_MENUS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			if [[ -n "${PH_APP}" ]]
			then
				PH_CMD="ph_unlink_app_from_menu '${PH_APP}' ${PH_PARAMS}"
			else
				PH_CMD="ph_unlink_app_from_menu ${PH_PARAMS}"
			fi ;;
				  PH_UNDO_SETUP_TTYS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_undo_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				  PH_SETUP_TTYS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				  PH_ENABLE_SERVICES)
			PH_CMD="ph_enable_services '${PH_VALUE}'" ;;
				  PH_DISABLE_SERVICES)
			PH_CMD="ph_disable_services '${PH_VALUE}'" ;;
				  PH_COPY_FILES)
			PH_FILE_DEST="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_FILE_SOURCE="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_copy_file $PH_PARAMS -s '${PH_FILE_SOURCE}' -d '${PH_FILE_DEST}'" ;;
				  PH_GIT_CLONE_MASTER)
			PH_GIT_REPO_DIR="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_GIT_REPO="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_GIT_REPO_NAME="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_GIT_REPO_ARGS="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_CMD="ph_git_clone_master -d '${PH_GIT_REPO_DIR}' -n '${PH_GIT_REPO_NAME}' -r '${PH_GIT_REPO}' -a '${PH_GIT_REPO_ARGS}'" ;;
				  PH_GIT_UNDO_CLONE_MASTER)
			PH_GIT_REPO_DIR="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_GIT_REPO="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_GIT_REPO_NAME="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_GIT_REPO_ARGS="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_CMD="ph_git_undo_clone_master -d '${PH_GIT_REPO_DIR}' -n '${PH_GIT_REPO_NAME}' -r '${PH_GIT_REPO}' -a '${PH_GIT_REPO_ARGS}'" ;;
				  PH_CREATE_APP_USER)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_create_app_user -a '${PH_APP}' -u '${PH_APP_USER}'" ;;
				  PH_REMOVE_APP_USER)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_remove_app_user -a '${PH_APP}' -u '${PH_APP_USER}'" ;;
				  PH_CREATE_APPS_CONF_FILE)
			PH_CMD="ph_create_app_conf_file '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_CONF_FILE)
			PH_CMD="ph_remove_app_conf_file '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_SCRIPTS)
			PH_CMD="ph_create_app_scripts '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_SCRIPTS)
			PH_CMD="ph_remove_app_scripts '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_MENUS)
			PH_CMD="ph_create_app_menus '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_MENUS)
			PH_CMD="ph_remove_app_menus '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_ALLOWEDS)
			PH_CMD="ph_create_app_alloweds '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_ALLOWEDS)
			PH_CMD="ph_remove_app_alloweds '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_DEFAULTS)
			PH_CMD="ph_create_app_defaults '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_DEFAULTS)
			PH_CMD="ph_remove_app_defaults '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_CIFS_MPT)
			PH_CMD="ph_create_app_cifs_mpt '${PH_VALUE}'" ;;
				  PH_REMOVE_APPS_CIFS_MPT)
			PH_CMD="ph_remove_app_cifs_MPT '${PH_VALUE}'" ;;
				  PH_CREATE_APPS_ITEMS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_create_app_items -a '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_REMOVE_APPS_ITEMS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_remove_app_items -a '${PH_APP}' ${PH_PARAMS}" ;;
				  PH_INSTALL_PKGS)
			PH_PKG_FLAG="0"
			PH_CMD="ph_install_pkg '${PH_VALUE}'" ;;
				  PH_REMOVE_PKGS)
			PH_PKG_FLAG="0"
			PH_CMD="ph_remove_pkg '${PH_VALUE}'" ;;
				  PH_LOAD_MODULES)
			PH_CMD="ph_load_kernel_module '${PH_VALUE}'" ;;
				  PH_UNLOAD_MODULES)
			PH_CMD="ph_unload_kernel_module '${PH_VALUE}'" ;;
				  PH_BOOTENV)
			PH_CMD="ph_set_bootenv '${PH_VALUE}'" ;;
				  PH_GROUPS)
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER_GROUPS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_set_user_group_membership -u '${PH_APP_USER}' -g '${PH_APP_USER_GROUPS}'" ;;
				PH_PIEH_VERSION)
			PH_CMD="ph_update_pieh_version '${PH_VALUE}'" ;;
				PH_STARTAPP)
			PH_CMD="ph_set_app_for_start '${PH_VALUE}'" ;;
				PH_CREATE_EMPTY_FILES)
			PH_FILE_DEST="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_FILE_TYPE="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_FILE_SOURCE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_CMD="ph_create_empty_file -t '${PH_FILE_TYPE}' -d '${PH_FILE_DEST}' -s '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_REMOVE_EMPTY_FILES)
			PH_FILE_DEST="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_FILE_TYPE="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_remove_empty_file -t '${PH_FILE_TYPE}' -d '${PH_FILE_DEST}' ${PH_PARAMS}" ;;
				PH_UNSUP_APPS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_APP_INST_STATE="$(echo -n "${PH_VALUE}" | cut -f5 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			for PH_i in USER CMD PKG INST_STATE
			do
				declare -n PH_VAR="PH_APP_${PH_i}"
				if [[ -n "${PH_VAR}" ]]
				then
					PH_PARAMS="${PH_PARAMS} -$(cut -c1<<<"${PH_i}" | tr "[:upper:]" "[:lower:]") '${PH_VAR}'"
				fi
				unset -n PH_VAR
			done
			PH_CMD="ph_unsupport_app ${PH_PARAMS}" ;;
				PH_UNINT_APPS)
			PH_CMD="ph_unintegrate_app -a '${PH_VALUE}'" ;;
				PH_INT_APPS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_TTY="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_integrate_app -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" ;;
				PH_SUP_APPS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_APP_USER="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_APP_CMD="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_APP_PKG="$(echo -n "${PH_VALUE}" | cut -f4 -d"'")"
			PH_APP_INST_STATE="$(echo -n "${PH_VALUE}" | cut -f5 -d"'")"
			PH_PARAMS="-a '${PH_APP}'"
			[[ -n "$(echo -n "${PH_VALUE}" | cut -f6 -d"'")" ]] && \
				PH_PARAMS="${PH_PARAMS} -f"
			for PH_i in USER CMD PKG INST_STATE
			do
				declare -n PH_VAR="PH_APP_${PH_i}"
				if [[ -n "${PH_VAR}" ]]
				then
					PH_PARAMS="${PH_PARAMS} -$(cut -c1<<<"${PH_i}" | tr "[:upper:]" "[:lower:]") '${PH_VAR}'"
				fi
				unset -n PH_VAR
			done
			PH_CMD="ph_support_app ${PH_PARAMS}" ;;
				PH_RESTORE_FILES)
			PH_FILE_SOURCE="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_restore_file -f '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_STORE_FILES)
			PH_FILE_SOURCE="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_PARAMS="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_store_file -f '${PH_FILE_SOURCE}' ${PH_PARAMS}" ;;
				PH_STORE_OPTION)
			PH_CMD="ph_store_option '${PH_VALUE}'" ;;
				PH_RETRIEVE_STORED_OPTION)
			PH_CMD="ph_retrieve_stored_option '${PH_VALUE}'" ;;
				PH_VARIABLES)
			PH_VAR_NAME="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_VAR_VALUE="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_CMD="ph_set_variable -n '${PH_VAR_NAME}' -v '${PH_VAR_VALUE}'" ;;
				PH_OPTIONS)
			PH_APP="$(echo -n "${PH_VALUE}" | cut -f1 -d"'")"
			PH_OPTION="$(echo -n "${PH_VALUE}" | cut -f2 -d"'")"
			PH_OPTION_VALUE="$(echo -n "${PH_VALUE}" | cut -f3 -d"'")"
			PH_CMD="ph_set_option_to_value '${PH_APP}' -r \"${PH_OPTION}'${PH_OPTION_VALUE}\"" ;;
				PH_CONFIGURED_STATE)
			PH_CMD="ph_pieh_configured_${PH_VALUE}_conf" ;;
				PH_UNCONFIGURED_STATE)
			PH_CMD="ph_pieh_unconfigured_${PH_VALUE}_conf" ;;
		esac
		unset PH_DATA_ARRAY["${PH_DATA_INDEX}"]
		unset PH_DEPTH_PARAMS["${PH_ARRAY_INDEX}"]
		unset -n PH_DATA_ARRAY
		if eval "${PH_CMD}"
		then
			continue
		fi
		PH_RET_CODE="1"
		break
	done
	while true
	do
		while true
		do
			if [[ "${PH_PKG_FLAG}" -eq "0" && "${PH_DISTRO}" == "Debian" ]]
			then
				! ph_apt_clean && \
					break
			fi
			if [[ "${#PH_RUN_ACLS[@]}" -gt "0" || -n "${PH_RUN_SECURE}" || -n "${PH_RUN_GIT_ADD_LOCAL}" || -n "${PH_RUN_GIT_TAG_LOCAL}" || \
				-n "${PH_RUN_GIT_COMMIT_LOCAL}" || -n "${PH_RUN_GIT_COMMIT_MASTER}" ]]
			then
				if [[ -n "${PH_RUN_SECURE}" ]]
				then
					! ph_secure_pieh && \
						break
				else
					if [[ "${#PH_RUN_ACLS[@]}" -gt "0" ]]
					then
						for PH_i in "${PH_RUN_ACLS[@]}"
						do
							! ph_user_acls -q -p "$(cut -d"'" -f1<<<"${PH_i}")" -u "$(cut -d"'" -f2<<<"${PH_i}")" && \
								break
						done
					fi
				fi
				for PH_i in ADD_LOCAL TAG_LOCAL COMMIT_LOCAL COMMIT_MASTER
				do
					if [[ "$(eval "echo -n \"\$PH_RUN_GIT_${PH_i}\"")" == "yes" ]]
					then
						if [[ "${PH_i}" != "COMMIT_MASTER" ]]
						then
							if ! eval "ph_undo_git_$(echo -n "${PH_i}" | tr '[:upper:]' '[:lower:]')"
							then
								break
							fi
						else
							! ph_git_commit_master -m "${PH_OLD_GIT_COMMIT_MSG}" -v "${PH_OLD_VERSION}" && \
								break
						fi
					fi
				done
			fi
			break 2
		done
		break
	done
fi
ph_show_result
return 1
}

function ph_stop_services {

declare PH_SERVICES
declare PH_SERVICE

PH_SERVICES="${*}"
PH_SERVICE=""

[[ "${#}" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_SERVICE in ${PH_SERVICES}
do
        printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Stopping systemd service " "'${PH_SERVICE}'"
	if ! systemctl is-active "${PH_SERVICE}" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
		while true
		do
			if "${PH_SUDO}" systemctl stop "${PH_SERVICE}" >/dev/null 2>&1
			then
				if "${PH_SUDO}" systemctl daemon-reload >/dev/null 2>&1
				then
					break
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			else
				ph_set_result -m "An error occurred trying to stop systemd service '${PH_SERVICE}'"
			fi
			ph_run_with_rollback -c false -m "Could not stop" || \
				return 1
		done
		ph_add_value_to_param -p PH_START_SERVICES -v "${PH_SERVICE}"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_disable_services {

declare PH_SERVICES
declare PH_SERVICE

PH_SERVICES="${*}"
PH_SERVICE=""

[[ "${#}" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_SERVICE in ${PH_SERVICES}
do
        printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Disabling systemd service " "'${PH_SERVICE}'"
	if systemctl is-disabled "${PH_SERVICE}" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
		while true
		do
			if "${PH_SUDO}" systemctl disable "${PH_SERVICE}" >/dev/null 2>&1
			then
				if "${PH_SUDO}" systemctl daemon-reload >/dev/null 2>&1
				then
					break
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			else
				ph_set_result -m "An error occurred trying to disable systemd service '${PH_SERVICE}'"
			fi
			ph_run_with_rollback -c false -m "Could not disable" || \
				return 1
		done
		ph_add_value_to_param -p PH_ENABLE_SERVICES -v "${PH_SERVICE}"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_copy_file {

declare PH_CMD
declare PH_MSG
declare PH_PARAMS
declare PH_FILE_SOURCE
declare PH_FILE_DEST
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_QUIESCE
declare -i PH_COPY_AS_ROOT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_CMD=""
PH_MSG=""
PH_PARAMS=""
PH_FILE_SOURCE=""
PH_FILE_DEST=""
PH_OPTION=""
PH_QUIESCE="1"
PH_COPY_AS_ROOT="1"

OPTIND="1"

while getopts :s:d:mrq PH_OPTION
do
	case "$PH_OPTION" in s)
		[[ -n "$PH_FILE_SOURCE" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_SOURCE="$OPTARG" ;;
			     d)
		[[ -n "$PH_FILE_DEST" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_FILE_DEST="$OPTARG" ;;
			     r)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-r" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-r" || \
			PH_PARAMS="${PH_PARAMS} -r"
		PH_COPY_AS_ROOT="0" ;;
			     q)
		echo "$PH_PARAMS" 2>/dev/null | grep -E "([[:space:]])*-q" >/dev/null && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-q" || \
			PH_PARAMS="${PH_PARAMS} -q"
		PH_QUIESCE="0" ;;
			     m)
		[[ -n "$PH_MSG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		[[ -z "$PH_PARAMS" ]] && \
			PH_PARAMS="-m" || \
			PH_PARAMS="${PH_PARAMS} -m"
		PH_MSG="Moving"
		PH_CMD="mv" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_FILE_SOURCE" || -z "$PH_FILE_DEST" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_CMD" ]] && \
	PH_CMD="cp -p" && \
	PH_MSG="Copying"
[[ "$PH_COPY_AS_ROOT" -eq "0" ]] && \
	PH_CMD="${PH_SUDO} ${PH_CMD}"
[[ "$PH_QUIESCE" -eq "1" ]] && \
	printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> ${PH_MSG} " "'${PH_FILE_SOURCE}'" " to " "'${PH_FILE_DEST}'"
if ${PH_CMD} "$PH_FILE_SOURCE" "$PH_FILE_DEST" 2>/dev/null
then
	ph_add_value_to_param -p PH_COPY_FILES -v "${PH_FILE_SOURCE}'${PH_FILE_DEST}'${PH_PARAMS}"
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c true
	return 0
else
	[[ "$PH_MSG" == "Moving" ]] && \
		PH_MSG="move" || \
		PH_MSG="copy"
	ph_set_result -m "An error occurred trying to ${PH_MSG} '${PH_FILE_SOURCE}' to '${PH_FILE_DEST}'"
	if [[ "$PH_QUIESCE" -eq "1" ]]
	then
		ph_run_with_rollback -c false -m "Could not ${PH_MSG}"
	fi
	return 1
fi
}

function ph_pieh_configured_logind_conf {

declare PH_i
declare -i PH_VALUE

PH_i=""
PH_VALUE="0"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Changing settings in system file " "'/etc/systemd/logind.conf'"
if [[ "$(grep -E "^NAutoVTs=${PH_PIEH_MAX_TTYS}$" /etc/systemd/logind.conf >/dev/null 2>&1 ; echo "$?")" -ne "0" && \
	"$(grep -E "^ReserveVT=1$" /etc/systemd/logind.conf >/dev/null 2>&1 ; echo "$?")" -ne "0" ]]
then
	if ph_run_with_rollback -c "ph_copy_file -q -r -s '/etc/systemd/logind.conf' -d '${PH_FILES_DIR}/stored/logind_conf'"
	then
		for PH_i in NAutoVTs ReserveVT
		do
			[[ "$PH_i" == "NAutoVTs" ]] && \
				PH_VALUE="${PH_PIEH_MAX_TTYS}" || \
				PH_VALUE="1"
			if grep -E "^${PH_i}=" /etc/systemd/logind.conf >/dev/null 2>&1
			then
				if grep -E "^${PH_i}=${PH_VALUE}$" /etc/systemd/logind.conf >/dev/null 2>&1
				then
					continue
				else
					if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=.*'"
					then
						if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=${PH_VALUE}'"
						then
							continue
						fi
					fi
				fi
			fi
			if grep -E "^#${PH_i}=" /etc/systemd/logind.conf >/dev/null 2>&1
			then
				if ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/systemd/logind.conf' -l '#${PH_i}=.*'"
				then
					if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/logind.conf' -l '${PH_i}=${PH_VALUE}'"
					then
						continue
					fi
				fi
			fi
			ph_run_with_rollback -c false -m "Could not change" || \
				return 1
		done
	else
		ph_run_with_rollback -c false -m "Could not change" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v "logind"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_pieh_unconfigured_logind_conf {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ ! -f "${PH_FILES_DIR}/logind_conf" ]] && \
	return 0
ph_run_with_rollback -c "ph_copy_file -r -m -s '${PH_FILES_DIR}/stored/logind_conf' -d '/etc/systemd/logind.conf'" || \
	return 1
ph_add_value_to_param -p PH_CONFIGURED_STATE -v logind
return 0
}

function ph_set_option_to_value {

declare PH_i
declare PH_j
declare PH_APP
declare PH_SUFFIX
declare PH_OPTARG_VAR
declare PH_OPTARG_VAL
declare PH_MSG_TYPE
declare PH_NEWVALUE
declare PH_OPT_DEFS
declare PH_OPT_REGEX
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_LENGTH
declare -i PH_NOW
declare -i PH_END
declare -i PH_RET_CODE
declare -i PH_OLD_SET_FLAG
declare -u PH_APPU

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_j=""
PH_APP="$1"
PH_SUFFIX=""
PH_OPTARG_VAR=""
PH_OPTARG_VAL=""
PH_MSG_TYPE=""
PH_NEWVALUE=""
PH_OPT_DEFS=""
PH_OPT_REGEX=""
PH_OPTION=""
PH_LENGTH="0"
PH_NOW="0"
PH_END="0"
PH_RET_CODE="0"
PH_OLD_SET_FLAG="1"
PH_APPU="${PH_APP:0:4}"

OPTIND="2"

[[ -z "$PH_APP" || "$#" -lt "3" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

([[ -f "${PH_CONF_DIR}/${PH_APP}.conf" && "$#" -gt "1" ]] ; return "$?") || \
	ph_set_option_to_value PieHelper -h && \
	while getopts :o:r:h PH_OPTION
do
	case "$PH_OPTION" in o)
			export PH_MSG_TYPE="Warning" ;;
			     r)
			export PH_MSG_TYPE="ERROR" ;;
			     *)
			ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
	if [[ "$PH_RET_CODE" -ne "0" ]]
	then
		ph_run_with_rollback -c false -m "Could not set"
		break
	fi
	PH_OLD_SET_FLAG="1"
	PH_OPTARG_VAR="$(echo -n "$OPTARG" | nawk 'BEGIN { \
			FS = "\x27" \
		} { \
			print $1 \
		}')"
	PH_OPTARG_VAL="$(echo -n "$OPTARG" | nawk 'BEGIN { \
			FS = "\x27" \
		} { \
			print $2 \
		}')"
	[[ -z "$PH_APP" || -z "$PH_OPTARG_VAR" ]] && \
		ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"
	if [[ "$PH_APP" != "LoginScript" ]]
	then
		if ! grep -E "^${PH_OPTARG_VAR}=" "${PH_CONF_DIR}/${PH_APP}.conf" >/dev/null
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "Variable '${PH_OPTARG_VAR}' is a read-only variable and it's value cannot be changed"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set ('${PH_OPTARG_VAR}' is read-only) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
	        PH_j="PH_${PH_APPU}"
		PH_LENGTH="$(echo -n PH_"$PH_APPU" | wc -c)"
		PH_SUFFIX="$(echo -n "$PH_OPTARG_VAR" | cut -c"$((PH_LENGTH+1))"-)"
		[[ "$PH_SUFFIX" == @(_CMD_OPTS|_NUM_CTRL|_USE_CTRL) ]] && \
			PH_SUFFIX=""
		for PH_i in _CMD_OPTS _NUM_CTRL _USE_CTRL "$PH_SUFFIX"
		do
			if [[ "$(declare -p "OLD_${PH_j}${PH_i}" 2>/dev/null)" != "declare -x "* ]]
			then
				export "OLD_${PH_j}${PH_i}"="$(eval "echo -n \"\$${PH_j}${PH_i}\"")"
			else
				[[ "$PH_OPTARG_VAR" == *"${PH_i}" ]] && \
					PH_OLD_SET_FLAG="0"
			fi
			[[ "$(declare -p "PH_OLDVALUE${PH_i}" 2>/dev/null)" == "declare -n "* ]] && \
				unset -n "PH_OLDVALUE${PH_i}"
			declare -n "PH_OLDVALUE${PH_i}"="OLD_${PH_j}${PH_i}"
			[[ "$(declare -p "PH_CURVALUE${PH_i}" 2>/dev/null)" == "declare -n "* ]] && \
				unset -n "PH_CURVALUE${PH_i}"
			declare -n "PH_CURVALUE${PH_i}"="${PH_j}${PH_i}"
			if [[ "$PH_OPTARG_VAR" == *"${PH_i}" ]]
			then
				[[ "$(declare -p PH_OLDVALUE 2>/dev/null)" == "declare -n "* ]] && \
					unset -n PH_OLDVALUE
				declare -n PH_OLDVALUE="OLD_${PH_j}${PH_i}"
				[[ "$(declare -p PH_CURVALUE 2>/dev/null)" == "declare -n "* ]] && \
					unset -n PH_CURVALUE
				declare -n PH_CURVALUE="${PH_j}${PH_i}"
			fi
		done
		if [[ "$PH_OPTARG_VAL" == "$PH_CURVALUE" ]]
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
			ph_run_with_rollback -c true -m "Nothing to do"
			continue
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_PKG" ]]
		then
			if ! ph_update_pkg_index
			then
				((PH_RET_CODE++))
				continue
			fi
			if ! ph_check_pkg_validity "$PH_OPTARG_VAL"
			then
				printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
				if [[ "$PH_MSG_TYPE" == "ERROR" ]]
				then
					((PH_RET_CODE++))
					ph_set_result -m "Could not set option '${PH_OPTARG_VAR}' to '${PH_OPTARG_VAL}' since it is not a valid package"
				else
					printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set '${PH_OPTARG_VAL}' as a valid package) -> Skipping"
					ph_set_result -r 0
				fi
				continue
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_MOON_USE_CTRL" && "$PH_OPTARG_VAL" == "no" ]]
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "Could not set option '${PH_OPTARG_VAR}' to '${PH_OPTARG_VAL}' since '${PH_APP}' requires at least one controller"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set ('${PH_APP}' requires at least one controller) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_MOON_CMD_OPTS" && "$(echo -n "$PH_OPTARG_VAL" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -ne "0" ]]
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$PH_MSG_TYPE" == "ERROR" ]]
			then
				((PH_RET_CODE++))
				ph_set_result -m "Could not set option '${PH_OPTARG_VAR}' to '${PH_OPTARG_VAL}' since no controller ID arguments were passed"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (The value must contain controller ID arguments) -> Skipping"
				ph_set_result -r 0
			fi
			continue
		fi
		if grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" >/dev/null 2>&1
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\n" "" "--> Checking if the new value " "'${PH_OPTARG_VAL}'" " for option " "'${PH_OPTARG_VAR}'" " is allowed"
			PH_OPT_DEFS="$(grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" 2>/dev/null | cut -d":" -f2)"
			PH_OPT_REGEX="$(grep -E "^${PH_OPTARG_VAR}:" "${PH_CONF_DIR}/options.alloweds" 2>/dev/null | cut -d":" -f3-)"
			if [[ ${PH_OPT_REGEX} ]]
			then
				true
			else
				false
			fi
       				if [[ "$?" -ne "0" ]]
				then
					if [[ "$PH_MSG_TYPE" == "ERROR" ]]
					then
						((PH_RET_CODE++))
						ph_set_result -m "Could not set option '${PH_OPTARG_VAR}' to '${PH_OPTARG_VAL}' since it's not '${PH_OPT_DEFS}')"
					else
						printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (Invalid value since not '${PH_OPT_DEFS}') -> Skipping"
						ph_set_result -r 0
					fi
					continue
				else
					ph_run_with_rollback -c true
				fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CIFS_MPT" && -n "$(ph_get_app_cifs_mpt -a '${PH_APP}' -r)" ]]
		then
			printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
			if [[ "$(mount 2>/dev/null | nawk -v mstring="^$(ph_get_app_cifs_mpt -a "$PH_APP" -r)$" '$3 ~ mstring { \
					print \
				} { \
					next \
				}' | wc -l)" -gt "0" ]]
			then
				if [[ "$PH_MSG_TYPE" == "ERROR" ]]
				then
					((PH_RET_CODE++))
					ph_set_result -m "The current mountpoint '$(ph_get_app_cifs_mpt -a "$PH_APP" -r)' cannot be active when changing mountpoints for '${PH_APP}'"
				else
					printf "%10s\033[31m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set (The old mountpoint is still active) -> Skipping"
					ph_set_result -r 0
				fi
				continue
			fi
		fi
	fi
	printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Setting option " "'${PH_OPTARG_VAR}'" " to " "'${PH_OPTARG_VAL}'" " in " "'${PH_CONF_DIR}/${PH_APP}.conf'"
	PH_OPTARG_VAL="$(ph_do_escape_paths "$PH_OPTARG_VAL")"
	if ! sed -i 's/^\('"${PH_OPTARG_VAR}"'=\)\([^\t]*\)\(\t*#.*\)/\1'\'"${PH_OPTARG_VAL}"\''\3/' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null
	then
		PH_OPTARG_VAL="$(ph_undo_escape_paths "$PH_OPTARG_VAL")"
		if [[ "$PH_MSG_TYPE" == "ERROR" ]]
		then
			((PH_RET_CODE++))
			ph_set_result -m "An error occurred trying to change the value of option '${PH_OPTARG_VAR}' in '${PH_CONF_DIR}/${PH_APP}.conf' to '${PH_OPTARG_VAL}'"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "${PH_MSG_TYPE} : Could not set"
			ph_set_result -r 0
		fi
		continue
	fi
	PH_OPTARG_VAL="$(ph_undo_escape_paths "$PH_OPTARG_VAL")"
	if [[ "$PH_APP" != "LoginScript" ]]
	then
		PH_CURVALUE="$PH_OPTARG_VAL"
		ph_add_value_to_param -p PH_OPTIONS -v "${PH_APP}'${PH_OPTARG_VAR}'${PH_OLDVALUE}"
		ph_run_with_rollback -c true
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CIFS_MPT" ]]
		then
			if [[ -n "$(eval "echo -n \"${PH_OPTARG_VAL}\"")" && ! -d "$(eval "echo -n \"${PH_OPTARG_VAL}\"")" ]]
			then
				if ! ph_run_with_rollback -c "ph_create_app_cifs_mpt '${PH_APP}'"
				then
					((PH_RET_CODE++))
					break
				fi
			fi
			if [[ -n "$(eval "echo -n \"${PH_OLDVALUE}\"")" && -d "$(eval "echo -n \"${PH_OLDVALUE}\"")" && \
				"$("$PH_SUDO" find "$(eval "echo -n \"${PH_OLDVALUE}\"")" -maxdepth 1 ! -wholename "$(eval "echo -n \"${PH_OLDVALUE}\"")" 2>/dev/null | wc -l)" -eq "0" ]]
			then
				if ! ph_run_with_rollback -c "ph_remove_empty_file -r -t directory -d '$(eval "echo -n \"${PH_OLDVALUE}\"")'"
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_NUM_CTRL" && "$(echo -n "$PH_CURVALUE_CMD_OPTS" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -eq "0" ]]
		then
			PH_END="$PH_OPTARG_VAL"
			PH_NOW="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk 'BEGIN { \
					count=0 \
				} { \
					for (i=1;i<=NF;i++) { \
						if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
							count++ \
						} \
					} \
				} END { \
					print count \
				}' 2>/dev/null)"
			if [[ "$PH_END" -ne "$PH_NOW" ]]
			then
				if [[ "$PH_NOW" -gt "$PH_END" ]]
				then
					PH_NEWVALUE="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk -v curval="$PH_NOW" 'BEGIN { \
							ORS = \"\" ; \
							compare = "/dev/input/eventPH_CTRL"curval \
						} { \
							for (i=1;i<=NF;i++) { \
								if ($(i+1) !~ compare && $i !~ compare) { \
									print $i ; \
									if (i<(NF-2)) { \
										print \" \" \
									} \
								} \
							} \
						}' 2>/dev/null)"
					while [[ "$((PH_NOW-1))" -gt "$PH_END" ]]
					do
						PH_NOW="$(echo -n "$PH_NEWVALUE" | nawk 'BEGIN { \
								count=0 \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
										count++ \
									} \
								} \
							} END { \
								print count \
							}' 2>/dev/null)"
						PH_NEWVALUE="$(echo -n "$PH_NEWVALUE" | nawk -v curval="$PH_NOW" 'BEGIN { \
								ORS = \"\" ; \
								compval = "/dev/input/eventPH_CTRL"curval \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($(i+1) !~ compval && $i !~ compval) { \
										print $i ; \
										if (i<(NF-2)) { \
											print \" \" \
										} \
									} \
								} \
							}' 2>/dev/null)"
					done
				else
					PH_NEWVALUE="$(echo -n "$PH_CURVALUE_CMD_OPTS" | nawk -v curval="$PH_NOW" 'BEGIN { \
							ORS = \"\" ; \
							ind = 0 ; \
							compval = "/dev/input/eventPH_CTRL"curval ; \
							printval = "/dev/input/eventPH_CTRL"(curval+1) \
						} { \
							for (i=1;i<=NF;i++) { \
								if ($(i+1) ~ compval) { \
									param = $i ; \
									ind = i ; \
									print $i \" \" \
								} else { \
									if (i==NF) { \
										if (i==(ind+1)) { \
											print $i \" \" param \" \" printval \
										} else { \
											print $i \
										} \
									} else { \
										if (i==(ind+1) && ind>0) { \
											print $i \" \" param \" \" printval \" \" \
										} else { \
											print $i \" \" \
										} \
									} \
								} \
							} \
						}' 2>/dev/null)"
					while [[ "$((PH_NOW+1))" -lt "$PH_END" ]]
					do
						PH_NOW="$(echo -n "$PH_NEWVALUE" | nawk 'BEGIN { \
								count=0 \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
										count++ \
									} \
								} \
							} END { \
								print count \
							}' 2>/dev/null)"
						PH_NEWVALUE="$(echo -n "$PH_NEWVALUE" | nawk -v curval="$PH_NOW" 'BEGIN { \
								ORS = \"\" ; \
								ind = 0 ; \
								compval = "/dev/input/eventPH_CTRL"curval ; \
								printval = "/dev/input/eventPH_CTRL"(curval+1) \
							} { \
								for (i=1;i<=NF;i++) { \
									if ($(i+1) ~ compval) { \
										param = $i ; \
										ind = i ; \
										print $i \" \" \
									} else { \
										if (i==NF) { \
											if (i==(ind+1)) { \
												print $i \" \" param \" \" printval \
											} else { \
												print $i \
											} \
										} else { \
											if (i==(ind+1) && ind>0) { \
												print $i \" \" param \" \" printval \" \" \
											} else { \
												print $i \" \" \
											} \
										} \
									} \
								} \
							}' 2>/dev/null)"
					done
				fi
				if ! ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_CMD_OPTS'${PH_NEWVALUE}\""
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_CMD_OPTS" && "$(echo -n "$PH_OPTARG_VAL" | grep -E "+([[:space:]])/dev/input/eventPH_CTRL[1-4]" >/dev/null ; echo "$?")" -eq "0" ]]
		then
			PH_NEWVALUE="$(echo -n "$PH_OPTARG_VAL" | nawk 'BEGIN { \
					count=0 \
				} { \
					for (i=1;i<=NF;i++) { \
						if ($i ~ /\/dev\/input\/eventPH_CTRL(1|2|3|4)/) { \
							count++ \
						} \
					} \
				} END { \
					print count \
				}' 2>/dev/null)"
			if [[ "$PH_CURVALUE_NUM_CTRL" != "$PH_NEWVALUE" ]]
			then
				if ! ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_NUM_CTRL'${PH_NEWVALUE}\""
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OPTARG_VAR" == "PH_${PH_APPU}_PKG" ]]
		then
			if ph_get_pkg_inst_state "$PH_OPTARG_VAL"
			then
				if ! ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PI
				then
					((PH_RET_CODE++))
					break
				fi
			else
				if ! ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PA
				then
					((PH_RET_CODE++))
					break
				fi
			fi
		fi
		if [[ "$PH_OLD_SET_FLAG" -eq "1" ]]
		then
			export "OLD_${PH_OPTARG_VAR}"="$PH_OPTARG_VAL"
		fi
	else
		ph_add_value_to_param -p PH_OPTIONS -v "${PH_APP}'${PH_OPTARG_VAR}'"
		ph_run_with_rollback -c true
	fi
done
[[ "$OPTIND" -eq "2" ]] && \
	PH_RET_CODE="1"
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"
if [[ "$PH_APP" != "LoginScript" ]]
then
	if [[ "$PH_OLD_SET_FLAG" -eq "1" ]]
	then
		unset "OLD_${PH_OPTARG_VAR}" "OLD_PH_${PH_APPU}_NUM_CTRL" "OLD_PH_${PH_APPU}_USE_CTRL" "OLD_PH_${PH_APPU}_CMD_OPTS"
	fi
	unset -n PH_OLDVALUE PH_CURVALUE PH_OLDVALUE_CMD_OPTS PH_OLDVALUE_USE_CTRL PH_OLDVALUE_NUM_CTRL PH_CURVALUE_CMD_OPTS PH_CURVALUE_USE_CTRL PH_CURVALUE_NUM_CTRL
	[[ -n "$PH_SUFFIX" ]] && \
		unset -n "PH_OLDVALUE${PH_SUFFIX}" "PH_CURVALUE${PH_SUFFIX}"
fi
return "$PH_RET_CODE"
}

function ph_mount_cifs_share {

declare PH_i
declare PH_APP
declare -u PH_APPU

PH_i=""
PH_APP="${1}"
PH_APPU="${PH_APP:0:4}"

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_i in USER PASS SRV DIR SUBDIR MPT
do
	if [[ -n "$(eval "echo -n \"\$OLD_PH_${PH_APPU}_CIFS_${PH_i}\"")" ]]
	then
		eval declare -n "PH_TMP_CIFS_${PH_i}=\"OLD_PH_${PH_APPU}_CIFS_${PH_i}\""
	else
		eval declare -n "PH_TMP_CIFS_${PH_i}=\"PH_${PH_APPU}_CIFS_${PH_i}\""
	fi
	eval "PH_TMP_CIFS_${PH_i}=\"$(ph_resolve_dynamic_value "$(eval "echo -n \"\$PH_TMP_CIFS_${PH_i}\"")")\""
done
if [[ -n "${PH_TMP_CIFS_MPT}" ]]
then

	if [[ "$(mount 2>/dev/null | nawk -v mstring="^${PH_TMP_CIFS_MPT}$" '$3 ~ mstring { \
			print \
		} { \
			next \
		}' | wc -l)" -eq "0" ]]
	then
		printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" \
			"--> Mounting CIFS share " "'${PH_TMP_CIFS_DIR}${PH_TMP_CIFS_SUBDIR}'" " from " "'${PH_TMP_CIFS_SRV}'" " on " "'${PH_TMP_CIFS_MPT}'"
		if "${PH_SUDO}" mount -t cifs -o username="${PH_TMP_CIFS_USER}" -o password="${PH_TMP_CIFS_PASS}" -o rw,uid="${PH_TMP_CIFS_USER}",gid="$(id -ng "${PH_RUN_USER}" 2>/dev/null)",file_mode="0770",dir_mode="0770" \
			"//${PH_TMP_CIFS_SRV}${PH_TMP_CIFS_DIR}${PH_TMP_CIFS_SUBDIR}" "${PH_TMP_CIFS_MPT}" 2>/dev/null
		then
			ph_set_result -m "An error occurred trying to mount '${PH_TMP_CIFS_DIR}${PH_TMP_CIFS_SUBDIR}' from '${PH_TMP_CIFS_SRV}' on '${PH_TMP_CIFS_MPT}'"
			unset -n PH_TMP_CIFS_USER PH_TMP_CIFS_PASS PH_TMP_CIFS_SRV PH_TMP_CIFS_DIR PH_TMP_CIFS_SUBDIR PH_TMP_CIFS_MPT
			ph_run_with_rollback -c false -m "Could not mount" || \
				return 1
		else
			ph_add_value_to_param -p PH_APP_UMOUNT_CIFS -v "${PH_APP}"
			ph_run_with_rollback -c true
		fi
	else
		ph_run_with_rollback -c true -m "Nothing to do"
	fi
fi
unset -n PH_TMP_CIFS_USER PH_TMP_CIFS_PASS PH_TMP_CIFS_SRV PH_TMP_CIFS_DIR PH_TMP_CIFS_SUBDIR PH_TMP_CIFS_MPT
return 0
}

function ph_umount_cifs_share {

declare PH_APP
declare PH_APP_CIFS_MPT

PH_APP="${1}"
PH_APP_CIFS_MPT=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_CIFS_MPT="$(ph_get_app_cifs_mpt -a "${PH_APP}" -r)"
printf "%8s%s\n" "" "--> Unmounting CIFS mounpoint '${PH_APP_CIFS_MPT}' for ${PH_APP}"
if [[ -n "${PH_APP_CIFS_MPT}" ]]
then
	if [[ "$(mount 2>/dev/null | nawk -v mstring="^${PH_APP_CIFS_MPT}$" '$3 ~ mstring { \
			print \
		} { \
			next \
		}' | wc -l)" -eq "1" ]]
	then
		if "${PH_SUDO}" umount -f "${PH_APP_CIFS_MPT}" 2>/dev/null
		then
			ph_set_result -m "An error occurred trying to unmount CIFS mountpoint '${PH_APP_CIFS_MPT}' for ${PH_APP}"
			ph_run_with_rollback -c false -m "Could not unmount" || \
				return 1
		else
			ph_add_value_to_param -p PH_APP_MOUNT_CIFS -v "${PH_APP}"
			ph_run_with_rollback -c true
		fi
	else
		ph_run_with_rollback -c true -m "Nothing to do"
	fi
fi
return 0
}

function ph_screen_input {

if [[ "$(echo "$*" | sed 's/[ ,/.]//g')" == *+([![:word:]])* ]]
then
	ph_set_result -a -m "Invalid input characters detected"
	return 1
fi
return 0
}

function ph_pieh_unconfigured_emul_conf {

declare PH_i
declare PH_MSG

PH_i=""
PH_MSG="configuration"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ ! -e "${PH_FILES_DIR}/stored/10-retropie_sh" && ! -e "${PH_FILES_DIR}/stored/autologin_conf" ]]
then
	return 0
else
	for PH_i in 10-retropie_sh autologin_conf
	do
		if [[ "$PH_i" == "autologin_conf" ]]
		then
			PH_MSG="tty ${PH_MSG}"
			printf "%8s%s\n" "" "--> Restoring Emulationstation's ${PH_MSG}"
			if [[ ! -d /etc/systemd/system/getty@tty1.service.d ]]
			then
				if ! ph_run_with_rollback -c "ph_create_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
				then
					ph_run_with_rollback -c false -m "Could not restore" || \
						return 1
				fi
			fi
			if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '${PH_FILES_DIR}/stored/${PH_i}' -d '/etc/systemd/system/getty@tty1.service.d/${PH_i//_/\.}'"
			then
				if ph_run_with_rollback -c "ph_enable_services 'getty@tty1'"
				then
					ph_run_with_rollback -c true && \
						continue
				fi
			fi
		else
			PH_MSG="LoginScript ${PH_MSG}"
			printf "%8s%s\n" "" "--> Restoring Emulationstation's ${PH_MSG}"
			if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '${PH_FILES_DIR}/stored/${PH_i}' -d '/etc/profile.d/$(sed 's/_/\./g' <<<"$PH_i")'"
			then
				ph_run_with_rollback -c true && \
					continue
			fi
		fi
		ph_run_with_rollback -c false -m "Could not restore" || \
			return 1
	done
fi
ph_add_value_to_param -p PH_CONFIGURED_STATE -v emul
return 0
}

function ph_pieh_configured_emul_conf {

declare PH_i
declare PH_MSG

PH_i=""
PH_MSG="configuration"

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ ! -f /etc/profile.d/10-retropie.sh && ! -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ]] && \
	return 0
[[ ( -f /etc/profile.d/10-retropie.sh && ! -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ) || \
	( ! -f /etc/profile.d/10-retropie.sh && -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ) ]] && \
	return 1
for PH_i in 10-retropie.sh autologin.conf
do
	if [[ "$PH_i" == "autologin.conf" ]]
	then
		PH_MSG="TTY ${PH_MSG}"
		printf "%8s%s\n" "" "--> Backing up Emulationstation's ${PH_MSG}"
		if ph_run_with_rollback -c "ph_copy_file -r -q -m -s '/etc/systemd/system/getty@tty1.service.d/${PH_i}' -d '${PH_FILES_DIR}/stored/$(sed 's/\./_/g' <<<"$PH_i")'"
		then
			if ph_run_with_rollback -c "ph_remove_empty_file -r -q -t directory -d '/etc/systemd/system/getty@tty1.service.d'"
			then
				if ph_run_with_rollback -c "ph_disable_services 'getty@tty1'"
				then
					ph_run_with_rollback -c true
					continue
				fi
			fi
		fi
	else
		PH_MSG="LoginScript ${PH_MSG}"
		printf "%8s%s\n" "" "--> Backing up Emulationstation's ${PH_MSG}"
		if ph_run_with_rollback -c "ph_copy_file -r -m -q -s '/etc/profile.d/${PH_i}' -d '${PH_FILES_DIR}/stored/$(sed 's/\./_/g' <<<"$PH_i")'"
		then
			ph_run_with_rollback -c true
			continue
		fi
	fi
	printf "%10s\033[31m%s\033[0m%s\n" "" "ERROR : " "Could not backup configuration"
	ph_run_with_rollback -c false || \
		return 1
done
ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v emul
return 0
}

function ph_show_emul_info {

declare PH_APP_USER

PH_APP_USER="$1"

[[ -z "$PH_APP_USER" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n\n" "" "--> Displaying info for Emulationstation (RetroPie)"
printf "%12s%s\n\n" "" "Game ROMS can either :"
printf "%14s%s\n" "" "- be copied locally under the directory '$(ph_get_cifs_mpt -a Emulationstation -r)'"
printf "%14s%s\n" "" "- be provided over CIFS by configuring the appropriate Emulationstation options"
printf "%12s%s\n\n" "" "Make sure to be logged in as user '${PH_APP_USER}' whenever you want to run proprietary Emulationstation tools !"
printf "%14s%s\n" "" "- Any tools delivered by Emulationstation are considered proprietary"
printf "%14s%s\n\n" "" "- Failure to do so could lead to permission issues requiring you to uninstall and reinstall Emulationstation"
ph_run_with_rollback -c true && \
	return $?
}

function ph_install_app {

declare PH_i
declare PH_APP
declare PH_APP_CMD
declare PH_APP_USER
declare PH_APP_PKG
declare PH_APP_STATE
declare PH_EMUL_HOME
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -u PH_APPU

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_CMD=""
PH_APP_USER=""
PH_APP_PKG=""
PH_APP_STATE=""
PH_EMUL_HOME=""
PH_OPTION=""
PH_APPU=""

OPTIND="1"

while getopts :a:c:u:p: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG"
                PH_APPU="${PH_APP:0:4}" ;;
			     c)
		[[ -n "$PH_APP_CMD" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     p)
		[[ -n "$PH_APP_PKG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "${PH_APP}" || ( -n "${PH_APP_USER}" && -n "${PH_APP_CMD}" && -n "${PH_APP_PKG}" && "${#}" -ne "8" ) || \
	( -z "${PH_APP_USER}" && -z "${PH_APP_CMD}" && -z "${PH_APP_PKG}" && "${#}" -ne "2" ) || \
	((( -n "${PH_APP_USER}" && (( -n "${PH_APP_CMD}" && -z "${PH_APP_PKG}" ) || ( -z "${PH_APP_CMD}" && -n "${PH_APP_PKG}" ))) || \
	( -n "${PH_APP_CMD}" && (( -n "${PH_APP_USER}" && -z "${PH_APP_PKG}" ) || ( -z "${PH_APP_USER}" && -n "${PH_APP_PKG}" )))) && "${#}" -ne "6" ) || \
	"${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
for PH_i in PKG USER
do
	declare -n PH_PARAM
	PH_PARAM="PH_APP_${PH_i}"
	if [[ -z "${PH_PARAM}" || "${PH_PARAM}" != "$("ph_get_app_$(echo -n "${PH_i}" | tr '[:upper:]' '[:lower:]')_from_app_name" "${PH_APP}")" ]]
	then
		PH_PARAM="$("ph_get_app_$(echo -n "${PH_i}" | tr '[:upper:]' '[:lower:]')_from_app_name" "${PH_APP}")"
	fi
	unset -n PH_PARAM
done
if ph_check_app_state_validity -a "$PH_APP" -q -s
then
	printf "%8s%s\n" "" "--> Checking application state of '${PH_APP}'"
	ph_run_with_rollback -c true -m "${PH_APP_STATE} (Nothing to do)" && \
		return 0
fi
ph_update_pkg_index || \
	return 1
printf "%8s%s\n" "" "--> Determining '${PH_APP}' package"
if [[ -n "$PH_APP_PKG" ]]
then
	ph_run_with_rollback -c true -m "$PH_APP_PKG"
	ph_run_with_rollback -c "ph_install_pkg '${PH_APP_PKG}'" || \
		return 1
	[[ "$PH_DISTRO" == "Debian" ]] && \
		ph_apt_clean
	if [[ "$(ph_check_object_existence -q -o sup ; echo "$?")" -eq "0" && "$(ph_check_app_state_validity -a "$PH_APP" -q -s ; echo "$?")" -eq "0" ]]
	then
		ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v PI || \
			return 1
	fi
	ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_CMD}'${PH_APP_USER}'${PH_APP_PKG}"
	return 0
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine"
	ph_set_result -r 0
fi
printf "%8s%s\n" "" "--> Attempting unpackaged installation"
case "$PH_APP" in Moonlight)
		ph_run_with_rollback -c true -m "$PH_APP"
		cd ~ >/dev/null 2>&1
		"$PH_SUDO" rm -r moonlight-embedded >/dev/null 2>&1
		"$PH_SUDO" rm "/var/tmp/${PH_APP}.compile" "/var/tmp/${PH_APP}.build" >/dev/null 2>&1
		ph_run_with_rollback -c "ph_git_clone_master -n 'moonlight-embedded' -d '${HOME}' -r 'https://github.com/irtimmer/moonlight-embedded.git'" || \
			return 1
		printf "%8s%s\n" "" "--> Configuring source"
		if cd ~/moonlight-embedded >/dev/null 2>&1
		then
			if git submodule update --init >/dev/null 2>&1
			then
				if mkdir build >/dev/null 2>&1
				then
					if cd build >/dev/null 2>&1
					then
						ph_run_with_rollback -c true
						printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m\n" "" "--> Generating a build for " "'${PH_APP}'" " (This may take a while)"
						if ! cmake ../ >"/var/tmp/${PH_APP}.build" >/dev/null 2>&1
						then
							ph_set_result -m "Could not generate a build for '${PH_APP}' (Logfile is '/var/tmp/${PH_APP}.build')"
							ph_run_with_rollback -c false -m "Could not generate"
							printf "%8s%s\n" "" "--> Displaying build log (Press 'q' to quit)"
							sleep 2
							if less "/var/tmp/${PH_APP}.build" 2>/dev/null
							then
								ph_run_with_rollback -c true
							else
								ph_run_with_rollback -c false -m "Could not display"
							fi
							cd ~ >/dev/null 2>&1
							return 1
						fi
						ph_run_with_rollback -c true -m "Built in '${HOME}/moonlight-embedded/build'"
						printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m\n" "" "--> Compiling " "'${PH_APP}'" "(This may take a while)"
						if ! make >"/var/tmp/${PH_APP}.compile" >/dev/null 2>&1
						then
							ph_set_result -m "Could not compile '${PH_APP}' (Logfile is '/var/tmp/${PH_APP}.compile')"
							ph_run_with_rollback -c false -m "Could not compile"
							printf "%8s%s\n" "" "--> Displaying compilation log (Press 'q' to quit)"
							sleep 2
							if less "/var/tmp/${PH_APP}.compile" 2>/dev/null
							then
								ph_run_with_rollback -c true
							else
								ph_run_with_rollback -c false -m "Could not display"
							fi
							cd ~ >/dev/null 2>&1
							return 1
						fi
						ph_run_with_rollback -c true -m "Build log is '/var/tmp/${PH_APP}.generate' and compilation log is '/var/tmp/${PH_APP}.compile'"
						printf "%8s%s\n" "" "--> Installing files"
						if "$PH_SUDO" make install >/dev/null 2>&1
						then
							ph_run_with_rollback -c true
							if [[ "$(ph_check_object_existence -q -o sup ; echo "$?")" -eq "0" && "$(ph_check_app_state_validity -a "$PH_APP" -q -s ; echo "$?")" -eq "0" ]]
							then
								ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v UI || \
									return 1
							fi
							ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_CMD}'${PH_APP_USER}'${PH_APP_PKG}"
							return 0
					
						else
							ph_set_result -m "Could not deploy the compiled version of '${PH_APP}'"
						fi
					else
						ph_set_result -m "Could not change directory to '${HOME}/moonlight-embedded/build'"
					fi
				else
					ph_set_result -m "Could not create build directory '${HOME}/moonlight-embedded/build'"
				fi
			else
				ph_set_result -m "Could not clone submodule(s) for repository 'moonlight-embedded'"
			fi
		else
			ph_set_result -m "Could not change directory to '${HOME}/moonlight-embedded'"
		fi ;;
	 Emulationstation)
		ph_run_with_rollback -c true -m "$PH_APP"
		PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
		printf "%8s%s\n" "" "--> Checking required '${PH_APP}' info"
		for PH_i in APP_USER EMUL_HOME
		do
			if [[ -z "$(eval "echo -n \"\$PH_${PH_i}\"")" ]]
			then
				case "$PH_i" in APP_USER)
					ph_set_result -m "Could not determine user account for '${PH_APP}'" ;;
						EMUL_HOME)
					ph_set_result -m "Could not determine home directory of user '${PH_APP_USER}'" ;;
				esac
				ph_run_with_rollback -c false -m "Could not determine" || \
					return 1
			else
				if [[ "$PH_i" == "APP_USER" ]]
				then
					PH_EMUL_HOME="$(getent passwd "$PH_APP_USER" 2>/dev/null | head -1 | cut -d':' -f6)"
				fi
			fi
		done
		ph_run_with_rollback -c true
		ph_run_with_rollback -c "ph_grant_pieh_access -u '${PH_APP_USER}'" || \
			return 1
		if cd "$PH_EMUL_HOME" >/dev/null 2>&1
		then
			"$PH_SUDO" rm -r RetroPie-Setup >/dev/null 2>&1
			ph_run_with_rollback -c "ph_git_clone_master -r 'https://github.com/RetroPie/RetroPie-Setup.git' -d '${PH_EMUL_HOME}' -n 'RetroPie-Setup' -a '--depth=1'" || \
				return 1
			printf "%8s%s\033[1;33m%s\033[0;0m\n\n" "" "--> Configuring the setup script for " "'${PH_APP}'"
			if "$PH_SUDO" chown -R "${PH_APP_USER}:$("$PH_SUDO" id -gn "$PH_APP_USER" 2>/dev/null)" "${PH_EMUL_HOME}/RetroPie-Setup" 2>/dev/null
			then
				if "$PH_SUDO" chmod +x "${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh" >/dev/null 2>&1
				then
					ph_run_with_rollback -c true
					printf "%8s%s\033[1;33m%s\033[0;0m\n\n" "" "--> Executing the setup script for " "'${PH_APP}'"
					printf "%10s\033[1;37m%s\033[1;33m%s\033[1;37m\n" "" "- The setup script will do a basic installation of " "'${PH_APP}'"
					printf "%10s%s\n" "" "- Note that running basic installation could take up to 30 minutes depending on system specs"
					printf "%10s%s\n" "" "- StartApp configuration from this script will be replaced by StartApp configuration from PieHelper"
					printf "%10s%s\033[1;33m%s\033[1;37m%s\n" "" "- Exit the script normally after basic installation completes and " "'${PH_APP}'" " installation will resume"
					printf "%10s%s\033[0;0m" "" "- Press Enter to continue"
					read -r 2>/dev/null
					clear
					if "$PH_SUDO" -E -u "$PH_APP_USER" sh -c "${PH_SUDO} ./retropie_setup.sh"
					then
						clear
						printf "%8s%s\033[1;33m%s\033[0;0m\n\n" "" "--> Executing the setup script for " "'${PH_APP}'"
						ph_run_with_rollback -c true -m "Success"
						if [[ -f "${PH_CONF_DIR}/${PH_APP}.conf" ]]
						then
							ph_autoconf_emul_base || \
								return 1
						fi
						if [[ -f /etc/profile.d/10-retropie.sh ]]
						then
							ph_run_with_rollback -c "ph_pieh_configured_emul_conf" || \
								return 1
						fi
						if [[ "$(ph_check_object_existence -q -o sup ; echo "$?")" -eq "0" && "$(ph_check_app_state_validity -a "$PH_APP" -q -s ; echo "$?")" -eq "0" ]]
						then
							ph_update_base_conf_file -a "$PH_APP" -f sup -c 3 -v UI || \
								return 1
						fi
						ph_show_emul_info "$PH_APP_USER"
						ph_add_value_to_param -p PH_UNINSTALL_APPS -v "${PH_APP}'${PH_APP_CMD}'${PH_APP_USER}'${PH_APP_PKG}"
						cd ~ >/dev/null 2>&1
						return 0
					else
						ph_set_result -m "An error occured running setup script '${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh' as '${PH_APP_USER}'"
					fi
				else
					ph_set_result -m "Could not set execute permission on '${PH_EMUL_HOME}/RetroPie-Setup/retropie_setup.sh'"
				fi
			else
				ph_set_result -m "Could not recursively set ownership of '${PH_EMUL_HOME}/RetroPie-Setup' to '${PH_APP_USER}:$("$PH_SUDO" id -gn "$PH_APP_USER" 2>/dev/null)'"
			fi
		else
			ph_set_result -m "Could not change directory to '${PH_EMUL_HOME}'"
		fi ;;
	*)
		ph_set_result -m "Unpackaged installation is not supported for '${PH_APP}' (Set '${PH_APP}' option 'PH_${PH_APPU}_PKG_NAME' to the correct package name and try again)" ;;
esac
cd ~ >/dev/null 2>&1
ph_run_with_rollback -c false -m "Could not complete installation" || \
	return 1
}

function ph_autoconf_emul_base {

declare PH_APP
declare PH_APP_USER
declare PH_EMUL_HOME
declare PH_EMUL_DIR_INIT
declare PH_EMUL_SETUP_DIR_INIT

declare PH_APP="Emulationstation"
declare PH_APP_USER=""
declare PH_EMUL_HOME="$(getent passwd "$PH_APP_USER" 2>/dev/null | head -1 | cut -d':' -f6)"
declare PH_EMUL_DIR_INIT=""
declare PH_EMUL_SETUP_DIR_INIT=""

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Determining the base directory of " "'${PH_APP}'"
declare PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
if [[ -f /etc/profile.d/10-retropie.sh ]]
then
	PH_EMUL_DIR_INIT="$(nawk -F'"' '$1 ~ /bash/ { \
			print $2 \
		}' /etc/profile.d/10-retropie.sh 2>/dev/null)"
	if [[ -n "$PH_EMUL_DIR_INIT" ]]
	then
		PH_EMUL_DIR_INIT="${PH_EMUL_DIR_INIT%%/configs*}"
	fi
else
	if [[ -d /opt/retropie ]]
	then
		PH_EMUL_DIR_INIT="/opt/retropie"
	fi
fi
if [[ -n "$PH_EMUL_DIR_INIT" ]]
then
	ph_run_with_rollback -c true -m "${PH_EMUL_DIR_INIT}"
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine -> Set '${PH_APP}' option 'PH_EMUL_DIR' manually using 'confopts_ph.sh' or the PieHelper menu"
	ph_set_result -r 0
fi
printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m\n" "" "--> Determining the setup directory of " "'${PH_APP}'" " (This may take a while)"
if [[ -d "${PH_EMUL_HOME}/RetroPie" ]]
then
	PH_EMUL_SETUP_DIR_INIT="${PH_EMUL_HOME}/RetroPie"
else
	PH_EMUL_SETUP_DIR_INIT="$("$PH_SUDO" find / -type d ! -fstype nfs -name RetroPie 2>/dev/null)"
fi
if [[ -n "$PH_EMUL_SETUP_DIR_INIT" ]]
then
	ph_run_with_rollback -c true -m "${PH_EMUL_DIR_SETUP_INIT}"
else
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine -> Set '${PH_APP}' option 'PH_EMUL_SETUP_DIR' manually using 'confopts_ph.sh' or the PieHelper menu"
	ph_set_result -r 0
fi
if [[ -n "$PH_EMUL_DIR_INIT" ]]
then
	ph_run_with_rollback -c "ph_set_option_to_value ${PH_APP} -r \"PH_EMUL_DIR'${PH_EMUL_DIR_INIT}\"" || \
		return 1
fi
if [[ -n "$PH_EMUL_SETUP_DIR_INIT" ]]
then
	ph_run_with_rollback -c "ph_set_option_to_value ${PH_APP} -r \"PH_EMUL_SETUP_DIR'${PH_EMUL_SETUP_DIR_INIT}\"" || \
		return 1
fi
return 0
}

function ph_uninstall_app {

declare PH_i
declare PH_APP
declare PH_APP_PKG
declare PH_APP_STR_TTY
declare PH_APP_INST_STATE
declare PH_APP_CMD
declare PH_APP_USER
declare PH_APP_USER_HOME
declare PH_PATH
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_i=""
PH_APP=""
PH_APP_PKG=""
PH_APP_STR_TTY=""
PH_APP_INST_STATE=""
PH_APP_CMD=""
PH_APP_USER=""
PH_APP_USER_HOME=""
PH_PATH=""
PH_OPTION=""

OPTIND="1"

while getopts :a:c:u:p: PH_OPTION
do
        case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}" ;;
			c)
		[[ -n "${PH_APP_CMD}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_CMD="${OPTARG}" ;;
			u)
		[[ -n "${PH_APP_USER}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_USER="${OPTARG}" ;;
			p)
		[[ -n "${PH_APP_PKG}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_PKG="${OPTARG}" ;;
			*)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || ( -n "${PH_APP_USER}" && -n "${PH_APP_CMD}" && -n "${PH_APP_PKG}" && "${#}" -ne "8" ) || \
	( -z "${PH_APP_USER}" && -z "${PH_APP_CMD}" && -z "${PH_APP_PKG}" && "${#}" -ne "2" ) || \
	((( -n "${PH_APP_USER}" && (( -n "${PH_APP_CMD}" && -z "${PH_APP_PKG}" ) || ( -z "${PH_APP_CMD}" && -n "${PH_APP_PKG}" ))) || \
	( -n "${PH_APP_CMD}" && (( -n "${PH_APP_USER}" && -z "${PH_APP_PKG}" ) || ( -z "${PH_APP_USER}" && -n "${PH_APP_PKG}" )))) && "${#}" -ne "6" ) || \
	"${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "${PH_APP}" == "PieHelper" ]]
then
	ph_unconfigure_pieh -r -b || \
		return 1
	"${PH_SUDO}" rm -r "${PH_BASE_DIR}" 2>/dev/null
	printf "\033[1;37m%s\n" "Sorry to see you go..."
	printf "%s\033[33m%s\033[37m%s\n\n" "Thank you for using " "'PieHelper'" " !"
	printf "%s\033[33m%s\033[37m%s\033[0m" "Press " "'Enter'" " to reboot into the graphical environment"
	read -r 2>/dev/null
	"${PH_SUDO}" chvt 1 2>/dev/null
	"${PH_SUDO}" init 6
fi
for PH_i in CMD USER
do
	declare -n PH_PARAM
	PH_PARAM="PH_APP_${PH_i}"
	if [[ -z "${PH_PARAM}" || "${PH_PARAM}" != "$("ph_get_app_$(echo -n "${PH_i}" | tr '[:upper:]' '[:lower:]')_from_app_name" "${PH_APP}")" ]]
	then
		PH_PARAM="$("ph_get_app_$(echo -n "${PH_i}" | tr '[:upper:]' '[:lower:]')_from_app_name" "${PH_APP}")"
	fi
	unset -n PH_PARAM
done
PH_APP_USER_HOME="$(getent passwd "${PH_APP_USER}" 2>/dev/null | head -1 | cut -d':' -f6)"
[[ "${PH_APP}" == "Bash" ]] && \
	PH_APP_CMD="bash"
PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the installation state of " "'${PH_APP}'"
PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "${PH_APP}")"
if [[ "${PH_APP_INST_STATE}" == @(uninst|*U) ]]
then
	ph_run_with_rollback -c true -m "Nothing to do"
	return "${?}"
else
	ph_run_with_rollback -c true -m "${PH_APP_INST_STATE}"
	printf "%8s%s\n" "" "--> Checking the application name"
	if [[ "${PH_APP}" == "Bash" ]]
	then
		ph_set_result -m "Could not uninstall '${PH_APP}' since it is a dependency for 'PieHelper'"
		ph_run_with_rollback -c false -m "Could not uninstall" || \
			return 1
	else
		ph_run_with_rollback -c true -m "${PH_APP}"
		printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Checking if " "'${PH_APP}'" " is a dependency"
		if [[ "${PH_APP}" == "X11" ]]
		then
			for PH_i in $(ph_get_app_list_by_state -s Supported -t minimum)
			do
				[[ "${PH_i}" == "${PH_APP}" ]] && \
					continue
				if [[ "$(ph_get_app_graphical_prop -a "${PH_i}" -c "$(ph_get_app_cmd_from_app_name "${PH_i}")")" == "yes" ]]
				then
					ph_set_result -m "Could not uninstall '${PH_APP}' since one or more supported applications depend on it"
					ph_run_with_rollback -c false -m "Could not uninstall" || \
						return 1
				fi
			done
		fi
		ph_run_with_rollback -c true -m "No"
	fi
	if ph_check_app_state_validity -a "${PH_APP}" -q -r
	then
		ph_run_with_rollback -c "ph_do_app_action stop '${PH_APP}' forced" || \
			return 1
	fi
	printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Checking if " "'${PH_APP}'" " is the Start application"
	if [[ "${PH_PIEH_STARTAPP}" == "${PH_APP}" ]]
	then
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Yes -> Removing the Start application"
		ph_set_result -r 0
		ph_set_app_for_start none || \
			return 1
	else
		ph_run_with_rollback -c true -m "No"
	fi
	printf "%8s%s\033[1;33m%s\033[0m%s\n" "" "--> Checking if " "'${PH_APP}'" " is a packaged application"
	case "${PH_APP_INST_STATE}" in pkg|P*)
		ph_run_with_rollback -c true -m "Yes ('${PH_APP_PKG}')"
		ph_update_pkg_index || \
			return 1
		if ! ph_run_with_rollback -c "ph_remove_pkg '${PH_APP_PKG}'"
		then
			return 1
		else
			[[ "${PH_DISTRO}" == "Debian" ]] && \
				ph_apt_clean
		fi ;;
			unpkg|U*)
		ph_run_with_rollback -c true -m "No"
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking if packageless removal is supported for " "'${PH_APP}'"
		if [[ "${PH_APP}" == @(Moonlight|Emulationstation) ]]
		then
			ph_run_with_rollback -c true -m "Yes"
			case "${PH_APP}" in Moonlight)
				printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Determining the build repository location for " "'${PH_APP}'"
				if [[ ! -d "${HOME}/moonlight-embedded" ]]
				then
					if ! PH_PATH="$("${PH_SUDO}" find / ! -o \( -fstype cifs -fstype nfs \) -prune -type d -name moonlight-embedded 2>/dev/null)"
					then
						ph_set_result -m "An error occurred trying to determine the build repository location for '${PH_APP}'"
						ph_run_with_rollback -c false -m "Could not uninstall" || \
							return 1
					fi
				else
					PH_PATH="${HOME}/moonlight-embedded"
				fi
				if [[ -d "${PH_PATH}/build" ]]
				then
					ph_run_with_rollback -c true -m "${PH_PATH}/build"
				else
					ph_set_result -m "An error occurred trying to locate the build repository of '${PH_APP}'"
					ph_run_with_rollback -c false -m "Could not uninstall" || \
						return 1
				fi
				if cd "${PH_PATH}/build" 2>/dev/null
				then
					printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Uninstalling " "'${PH_APP}'"
					if ! "${PH_SUDO}" cat install_manifest.txt 2>/dev/null | xargs -I '{}' "${PH_SUDO}" rm {} >/dev/null 2>&1
					then
						ph_set_result -m "An error occurred trying to uninstall unpackaged application '${PH_APP}'"
						ph_run_with_rollback -c false -m "Could not uninstall" || \
							return 1
					fi
					if cd "${OLDPWD}" 2>/dev/null
					then
						ph_run_with_rollback -c true
					else
						ph_set_result -m "An error occurred trying to change directory to '${OLDPWD}'"
						ph_run_with_rollback -c false -m "Could not uninstall" || \
							return 1
					fi
				else
					ph_set_result -m "An error occurred trying to change directory to '${PH_PATH}/build'"
					ph_run_with_rollback -c false -m "Could not uninstall" || \
						return 1
				fi ;;
					Emulationstation)
				printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Determining the setup script location for " "'${PH_APP}'"
				if [[ ! -f "${PH_EMUL_SETUP_DIR}-Setup/retropie_setup.sh" ]]
				then
					if ! PH_PATH="$("${PH_SUDO}" find / ! -o \( -fstype cifs -fstype nfs \) -prune -type f -perm -o=x -name retropie_setup.sh 2>/dev/null)"
					then
						ph_set_result -m "An error occurred trying to determine the setup script location for '${PH_APP}'"
						ph_run_with_rollback -c false -m "Could not uninstall" || \
							return 1
					fi
					PH_PATH="${PH_PATH%/*}"
				else
					PH_PATH="${PH_EMUL_SETUP_DIR}-Setup"
				fi
				ph_run_with_rollback -c true -m "${PH_PATH}/retropie_setup.sh"
				ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_EMUL_DIR'\" -r \"PH_EMUL_SETUP_DIR'\"" || \
					return 1
				printf "%8s%s\033[1;33m%s\033[37m\n\n" "" "--> Uninstalling " "'${PH_APP}'"
				printf "%12s%s\033[33m%s\033[37m\n" "" "- Use the setup script to uninstall " "'${PH_APP}'"
				printf "%12s%s\033[33m%s\033[37m%s\n\n" "" "- Exit the script normally after it finishes and " "'${PH_APP}'" " removal will resume"
				printf "%12s%s\033[0m" "" "Press Enter to continue"
				read -r 2>/dev/null
				clear
				if "${PH_SUDO}" "${PH_PATH}/retropie_setup.sh"
				then
					ph_run_with_rollback -c true
				else
					ph_set_result -m "An error occurred trying to uninstall '${PH_APP}' with '${PH_PATH}/retropie-setup.sh'"
					ph_run_with_rollback -c false -m "Could not uninstall" || \
						return 1
				fi ;;
					*)
				: ;;
			esac
		else
			ph_set_result -m "Could not uninstall '${PH_APP}' since installation was packageless but packageless removal is not supported"
			ph_run_with_rollback -c false -m "Could not uninstall" || \
				return 1
		fi ;;
			*)
		: ;;
	esac
fi
case "${PH_APP}" in Moonlight|Emulationstation)
	ph_run_with_rollback -c "ph_undo_git_clone '${PH_PATH}'" || \
		return 1
	if [[ "${PH_APP}" == "Moonlight" ]]
	then
		printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing cache directory " "'${PH_APP_USER_HOME}/.cache'" " for " "'${PH_APP}'"
		if ph_run_with_rollback -c "ph_store_file -r -f '${PH_APP_USER_HOME}/.cache'"
		then
			ph_run_with_rollback -c true
		else
			ph_run_with_rollback -c false -m "Could not uninstall" || \
				return 1
		fi
	fi ;;
		Kodi)
	printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing preferences directory " "'${PH_APP_USER_HOME}/.kodi'" " for " "'${PH_APP}'"
	if ph_run_with_rollback -c "ph_store_file -r -f '${PH_APP_USER_HOME}/.kodi'"
	then
		ph_run_with_rollback -c true
	else
		ph_run_with_rollback -c false -m "Could not uninstall"
	fi ;;
		*)
	: ;;
esac
for PH_i in $(nawk -F'=' 'BEGIN { \
		ORS = " " \
	} \
	$1 ~ /^PH_/ { \
		print $1 \
	}' "${PH_CONF_DIR}/${PH_APP}.conf" 2>/dev/null)
do
	ph_set_option_to_default_value "${PH_i}" || \
		return 1
done
if [[ "${PH_APP_STR_TTY}" != @(-|1) ]]
then
	ph_run_with_rollback -c "ph_undo_setup_tty -a '${PH_APP}' -t '${PH_APP_STR_TTY}' -u '${PH_APP_USER}'" || \
		return 1
fi
ph_run_with_rollback -c "ph_remove_app_from_integration_file -a '${PH_APP}'" || \
	return 1
ph_add_value_to_param -p PH_INSTALL_APPS -v "${PH_APP}'${PH_APP_CMD}'${PH_APP_USER}'${PH_APP_PKG}"
return 0
}

function ph_unintegrate_app {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_APP_STATE
declare PH_APP_INST_STATE
declare PH_APP_STR_TTY
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY
declare -a PH_PARAMS

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_USER=""
PH_APP_CMD=""
PH_APP_STATE=""
PH_APP_INST_STATE=""
PH_APP_STR_TTY=""
PH_OPTION=""
PH_APP_TTY="0"

OPTIND="1"

while getopts :a:u:t:c:i: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_TTY="$OPTARG"
		[[ "$PH_APP_TTY" -eq "0" ]] && \
			PH_APP_STR_TTY="-" || \
			PH_APP_STR_TTY="$PH_APP_TTY" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1 
                PH_APP_INST_SATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "integrated" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Halted -t exact)
	do
		ph_unintegrate_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		for PH_i in USER TTY CMD INST_STATE
		do
			declare -n PH_VAR="PH_APP_${PH_i}"
			if [[ ( "$PH_i" != "TTY" && -n "$PH_VAR" ) || \
				( "$PH_i" == "TTY" && "$PH_VAR" -gt "1" ) ]]
			then
				case "$PH_i" in USER)
					PH_PARAMS+=("-u" "'${PH_VAR}'") ;;
						TTY)
					PH_PARAMS+=("-t" "'${PH_VAR}'") ;;
						CMD)
					PH_PARAMS+=("-c" "'${PH_VAR}'") ;;
						INST_STATE)
					PH_PARAMS+=("-i" "'${PH_VAR}'") ;;
				esac
			fi
			unset -n PH_VAR 2>/dev/null
		done
		[[ "${#PH_PARAMS[@]}" -gt "0" ]] && \
			PH_APP="$(ph_get_app_name_from_base_conf_file "${PH_PARAMS[@]}")"
	fi
fi
unset PH_PARAMS
printf "%8s%s\n" "" "--> Checking application name parameter"
if [[ -z "$PH_APP" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid name"
	ph_set_result -r 1 -m "A valid name is mandatory for unintegrating an application"
	return 1
else
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_APP_STATE" in Supported|Unused|Reserved)
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid name"
			ph_set_result -r 0 -w -m "Application already unintegrated"
			return 0 ;;
				Integrated|Running|Halted)
			printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_APP')" ;;
	esac
	ph_set_result -r 0
fi
if [[ "$PH_APP" == "PieHelper" ]]
then
	printf "%8s%s\n" "" "--> Checking if PieHelper is being (un)configured"
	if [[ -f "${PH_TMP_DIR}/.unconfigure_in_progress" || -f "${PH_TMP_DIR}/.configure_in_progress" ]]
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK : 'Unconfigure' action in progress"
		ph_set_result -r 0
	else
		printf "%10s\033[31m%s\033[0m\n" "" "ERROR : 'Unconfigure' action not in progress"
		ph_set_result -r 1 -m "Integration for 'PieHelper' is mandatory while configuration state remains 'Configured'"
		return 1
	fi
fi
if [[ -z "$PH_APP_STR_TTY" ]]
then
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
else
	printf "%8s%s\n" "" "--> Checking the tty parameter"
	if [[ "$PH_APP" != "$(ph_get_app_name_from_app_tty "$PH_APP_TTY")" ]]
	then
		PH_APP_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid TTY -> Setting to 'TTY${PH_APP_TTY}'"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK ('TTY${PH_APP_TTY}')"
	fi
	ph_set_result -r 0
fi
if [[ -z "$PH_APP_USER" ]]
then
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
else
	printf "%8s%s\n" "" "--> Checking run account parameter"
	if [[ "$PH_APP_USER" != "$(ph_get_app_user_from_app_name "$PH_APP")" ]]
	then
		PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
		printf "%10s\033[31m%s\033[0m\n" "" "Warning : Invalid run account -> Setting to '$PH_APP_USER'"
	else
		printf "%10s\033[32m%s\033[0m\n" "" "OK ('$PH_APP_USER')"
	fi
	ph_set_result -r 0
fi
ph_run_with_rollback -c "ph_do_app_action stop '${PH_APP}' forced" || \
	return 1
if [[ "${PH_PIEH_STARTAPP}" == "${PH_APP}" ]]
then
	ph_run_with_rollback -c "ph_set_app_for_start none" || \
		return 1
fi
if [[ "${PH_APP_TTY}" -gt "1" ]]
then
	ph_run_with_rollback -c "ph_undo_setup_tty -a '${PH_APP}' -t '${PH_APP_TTY}' -u '${PH_APP_USER}'" || \
		return 1
fi
ph_run_with_rollback -c "ph_remove_app_items -a '${PH_APP}' -t unintegrate" || \
	return 1
ph_run_with_rollback -c "ph_remove_app_from_integration_file -a '${PH_APP}'" || \
	return 1
ph_add_value_to_param -p PH_INT_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
return 0
}

function ph_unsupport_app {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_APP_PKG
declare PH_APP_INST_STATE
declare PH_APP_STATE
declare PH_APP_EXEC
declare PH_ANSWER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_FOUND_FLAG
declare -i PH_COUNT
declare -l PH_il

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_USER=""
PH_APP_CMD=""
PH_APP_PKG=""
PH_APP_INST_STATE=""
PH_APP_STATE=""
PH_APP_EXEC=""
PH_ANSWER=""
PH_OPTION=""
PH_FOUND_FLAG="1"
PH_COUNT="0"
PH_il=""

OPTIND="1"

while getopts :a:c:u:i:p: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             p)
		[[ -n "$PH_APP_PKG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "supported" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Supported -t exact)
	do
		ph_unsupport_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	for PH_i in USER INST_STATE PKG CMD
	do
		if [[ -z "$(eval "echo -n \"\$PH_APP_${PH_i}\"")" ]]
		then
			eval "PH_APP_${PH_i}=\"$("ph_get_app_${PH_il}_from_app_name" "$PH_APP")\""
		fi
	done
fi
printf "%8s%s\n" "" "--> Checking the application state of ${PH_APP}"
PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
case "$PH_APP_STATE" in Integrated|Halted|Running)
	ph_set_result -m "Could not unsupport application ${PH_APP} when it's still integrated" ;;
			Supported)
	ph_run_with_rollback -c true -m "${PH_APP_STATE}"
	if [[ "$PH_APP" == "PieHelper" ]]
	then
		printf "%8s%s\n" "" "--> Checking if PieHelper is being (un)configured"
		if [[ -f "${PH_TMP_DIR}/.unconfigure_in_progress" || -f "${PH_TMP_DIR}/.configure_in_progress" ]]
		then
			ph_run_with_rollback -c true -m "yes"
		else
			ph_set_result -m "PieHelper should be unsupported by running either 'confpieh_ph.sh -u' or 'confapps_ph.sh -a PieHelper -p unsup'"
			ph_run_with_rollback -c false -m "no" || \
				return 1
		fi
	fi
	if ! ph_check_app_state_validity -a "$PH_APP" -q -d
	then
		ph_run_with_rollback -c "ph_remove_oos_app_code '${PH_APP}'" || \
			return 1
	fi
	if [[ "$PH_APP" != "PieHelper" ]]
	then
		PH_ANSWER=""
		PH_COUNT="0"
		while [[ "$PH_ANSWER" != @(y@(|es)|n@(|o)) ]]
		do
			[[ "$PH_COUNT" -gt "0" ]] && \
				printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
			printf "%8s%s\033[1;33m%s\033[0;0m%s\n\n" "" "--> Do you also want to uninstall " "'${PH_APP}'" " ? "
			printf "%10s\033[1;37m%s\033[1;33m%s\033[1;37m%s\033[0;0m\n\n" "" "- Do not uninstall " "'${PH_APP}'" " if applications outside the PieHelper framework still require it"
			printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m%s" "" "Uninstall " "'${PH_APP}'" " (y/n)" " ? "
			read -r PH_ANSWER 2>/dev/null
			((PH_COUNT++))
		done
		ph_run_with_rollback -c true -m "$PH_ANSWER"
		if [[ "$PH_ANSWER" == y@(|es) ]]
		then
			ph_run_with_rollback -c "ph_uninstall_app -a '${PH_APP}'" || \
				return 1
		fi
		ph_run_with_rollback -c "ph_revoke_pieh_access -u '${PH_APP_USER}'" || \
			return 1
		if [[ "$(nawk -v user "^${PH_APP_USER}$" 'BEGIN { \
				count = "0" \
			} \
			$2 ~ user { \
				count++ \
			} { \
				next \
			} END {
				if (count > 1) { \
					printf "no" \
				} else { \
					printf "yes" \
				} \
			}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)" == "yes" && "$PH_APP_USER" != "root" ]]
		then
			PH_ANSWER=""
			PH_COUNT="0"
			while [[ "$PH_ANSWER" != @(y@(|es)|n@(|o)) ]]
			do
				[[ "$PH_COUNT" -gt "0" ]] && \
					printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
				printf "%8s%s\033[1;33m%s\033[0;0m%s\n\n" "" "--> Do you also want to remove user " "'${PH_APP_USER}'" " ?"
				printf "%10s\033[1;37m%s\033[1;33m%s\033[1;37m%s\n" "" "- PieHelper access for user " "'${PH_APP_USER}'" " is revoked but the user might still have system access"
				printf "%10s%s\n" "" "- You should not remove the user if :"
				printf "%12s%s\n" "" "- If the account is still required for other reasons"
				printf "%12s%s\033[1;33m%s\033[0m\n\n" "" "- If you want to keep the data in the user's home directory " "'$(getent passwd ${PH_APP_USER} 2>/dev/null | head -1 | cut -d':' -f6)'"
				printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m%s" "" "Remove " "'${PH_APP_USER}'" " (y/n)" " ? "
				read -r PH_ANSWER 2>/dev/null
				((PH_COUNT++))
			done
			ph_run_with_rollback -c true "$PH_ANSWER"
			if [[ "$PH_ANSWER" == y@(|es) ]]
			then
				ph_run_with_rollback -c "ph_remove_app_user -a '${PH_APP}' -u '${PH_APP_USER}'" || \
					return 1
			fi
		fi
	fi
	ph_run_with_rollback -c "ph_remove_app_from_support_file -a '${PH_APP}' -u '${PH_APP_USER}' -i '${PH_APP_INST_STATE}' -c '${PH_APP_CMD}'" || \
		return 1
	if [[ "$PH_APP" == "X11" ]]
	then
		printf "%8s%s\n" "" "--> Checking for applications dependent on ${PH_APP}"
		for PH_i in $(ph_get_app_list_by_state -s Supported -t minimum)
		do
			[[ "$PH_i" == "$PH_APP" ]] && \
				continue
			if [[ "$(ph_get_app_graphical_prop -a "$PH_i" -c "$(ph_get_app_cmd_from_app_name "$PH_i")")" == "yes" ]]
			then
				PH_FOUND_FLAG="0"
				break
			fi
		done
		if [[ "$PH_FOUND_FLAG" -eq "1" ]]
		then
			ph_run_with_rollback -c true -m "none"
		else
			ph_set_result -m "Could not unsupport ${PH_APP} since at least one other supported application depends on it"
			ph_run_with_rollback -c false -m "Could not unsupport" || \
				return 1
		fi
	else
		printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Checking for unused dependencies of " "'${PH_APP}'"
		PH_APP_GRAPH="$(ph_get_app_graphical_prop -a "$PH_APP" -c "$PH_APP_CMD")"
		if [[ "$PH_APP_GRAPH" == "yes" && "$PH_APP" != "X11" ]]
		then
			for PH_i in $(ph_get_app_list_by_state -s Supported -t minimum)
			do
				[[ "$PH_i" == "X11" ]] && \
					continue
				if [[ "$(ph_get_app_graphical_prop -a "$PH_i" -c "$(ph_get_app_cmd_from_app_name "$PH_i")")" == "yes" ]]
				then
					PH_FOUND_FLAG="0"
					break
				fi
			done
			if [[ "$PH_FOUND_FLAG" -eq "1" ]]
			then
				ph_run_with_rollback -c true -m "yes (X11)"
				while [[ "$PH_ANSWER" != @(y@(|es)|n@(|o)) ]]
				do
					[[ "$PH_COUNT" -gt "0" ]] && \
						printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
					printf "%8s%s\033[1;33m%s\033[0;0m%s\n\n" "" "--> Do you also want to unsupport " "'X11'" " ?"
					printf "%10s\033[1;37m%s\n" "" "- X11 is the graphical environment application and can be used on it's own or be a requirement for other applications"
					printf "%10s%s\n" "" "- X11 should not be unsupported if :"
					printf "%12s%s\n" "" "- You still want to use the graphical environment"
					printf "%12s%s\033[0;0m\n\n" "" "- Applications outside the PieHelper framework still require it"
					printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0;0m%s" "" "Unsupport " "'X11'" " (y/n)" " ? "
					read -r PH_ANSWER 2>/dev/null
					((PH_COUNT++))
				done
				ph_run_with_rollback -c true -m "$PH_ANSWER"
				if [[ "$PH_ANSWER" == y@(|es) ]]
				then
					ph_run_with_rollback -c "ph_unsupport_app -a X11" || \
						return 1
				fi
			else
				ph_run_with_rollback -c true -m "none"
			fi
		else
			ph_run_with_rollback -c true -m "none"
		fi
	fi
	ph_run_with_rollback -c "ph_remove_app_items -a '${PH_APP}' -t unsupport" || \
		return 1
	ph_add_value_to_param -p PH_SUP_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_CMD}'${PH_APP_PKG}" ;;
			*)
	ph_run_with_rollback -c true -m "Nothing to do"
esac
return 0
}

function ph_remove_app_from_support_file {
	
declare PH_i
declare PH_APP
declare PH_APP_CMD
declare PH_APP_USER
declare PH_APP_INST_STATE
declare PH_REMOVE_STRING
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -l PH_il

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_CMD=""
PH_APP_USER=""
PH_APP_INST_STATE=""
PH_REMOVE_STRING=""
PH_OPTION=""
PH_COUNT="0"
PH_il=""

OPTIND="1"

while getopts :a:u:c:i: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
			     i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing application " "'${PH_APP}'" " from configuration file " "'${PH_CONF_DIR}/supported_apps'"
PH_REMOVE_STRING="${PH_APP}"
for PH_i in USER INST_STATE CMD
do
	PH_il="$PH_i"
	declare -n PH_VAR="PH_APP_${PH_i}"
	if [[ -z "$PH_VAR" ]]
	then
		PH_VAR="$(eval "ph_get_app_${PH_il}_from_app_name \"$PH_APP\"")"
		if [[ -n "$PH_VAR" ]]
		then
			PH_REMOVE_STRING="${PH_REMOVE_STRING}\t${PH_VAR}"
		fi
	else
		PH_REMOVE_STRING="${PH_REMOVE_STRING}\t${PH_VAR}"
	fi
	unset -n PH_VAR
done
[[ "${PH_REMOVE_STRING}" == "${PH_APP}" ]] && \
	PH_REMOVE_STRING="${PH_REMOVE_STRING}\t.*"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
                    1)
	if ! ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/supported_apps' -l '${PH_REMOVE_STRING}'"
	then
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi ;;
                    *)
	ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/supported_apps' is corrupted -> Found multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_ADD_APPS_TO_SUP_FILE -v "${PH_APP}'${PH_APP_USER}'${PH_APP_INST_STATE}'${PH_APP_CMD}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_remove_app_from_integration_file {
	
declare PH_APP
declare PH_APP_STR_TTY
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_STR_TTY=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"

while getopts :a:t: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ -n "$PH_APP_STR_TTY" || "$OPTARG" != @(+([[:digit:]])|-) || \
			( "$OPTARG" == +([[:digit:]]) && ( "$OPTARG" -le "1" || "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" )) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_STR_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || ( -n "$PH_APP_STR_TTY" && "$#" -ne "4" ) || \
	( -z "$PH_APP_STR_TTY" && "$#" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing application " "'${PH_APP}'" " from configuration file " "'${PH_CONF_DIR}/integrated_apps'"
[[ -z "$PH_APP_STR_TTY" ]] && \
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
		    1)
	if ! ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\t${PH_APP_STR_TTY}'"
	then
		ph_run_with_rollback -c false -m "Could not remove" || \
			return 1
	fi ;;
		    *)
	ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/integrated_apps' is corrupted -> Found multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_ADD_APPS_TO_INT_FILE -v "${PH_APP}'${PH_APP_STR_TTY}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_get_app_name_from_app_pkg {

declare PH_APP
declare PH_APP_PKG
declare -u PH_APPU

PH_APP=""
PH_APP_PKG="$1"
PH_APPU=""

[[ -z "$PH_APP_PKG" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_APP in $(ph_get_app_list_by_state -s Unused -t minimum)
do
	PH_APPU="${PH_APP:0:4}"
	declare -n PH_PKG="PH_${PH_APPU}_PKG"
	if [[ "$PH_APP_PKG" == "$PH_PKG" ]]
	then
		echo -n "$PH_APP"
		unset -n PH_PKG
		return 0
	fi
	unset -n PH_PKG
done
return 1
}

function ph_get_app_pkg_from_executable {

declare PH_APP_PKG
declare PH_APP_EXEC

PH_APP_PKG=""
PH_APP_EXEC="${1}"

[[ -z "${PH_APP_EXEC}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if PH_APP_PKG="$(dpkg -S "${PH_APP_EXEC}" 2>/dev/null | cut -d':' -f1)"
then
	echo -n "${PH_APP_PKG}"
	return 0
fi
ph_set_result -m "An error occurred trying to determine the package for executable '${PH_APP_EXEC}'"
return 1
}

function ph_support_app {

declare PH_i
declare PH_APP
declare PH_APP_EXEC
declare PH_APP_CMD
declare PH_APP_GRAPH
declare PH_APP_PKG
declare PH_APP_NEW_PKG
declare PH_APP_USER
declare PH_APP_STATE
declare PH_APP_INST_STATE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -i PH_ANSWER
declare -i PH_APP_PKG_CHANGED_FLAG
declare -i PH_FORCE_SUPPORT_FLAG
declare -l PH_APPL
declare -u PH_APPU

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_EXEC=""
PH_APP_CMD=""
PH_APP_GRAPH=""
PH_APP_PKG=""
PH_APP_NEW_PKG=""
PH_APP_USER=""
PH_APP_STATE=""
PH_APP_INST_STATE=""
PH_OPTION=""
PH_COUNT="0"
PH_ANSWER="0"
PH_APP_PKG_CHANGED_FLAG="1"
PH_FORCE_SUPPORT_FLAG="1"
PH_APPL=""
PH_APPU=""

OPTIND="1"
PH_PASS_APP_USER=""

while getopts :a:c:u:p:i:f PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             p)
		[[ -n "$PH_APP_PKG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
                             i)
		[[ -n "${PH_APP_INST_STATE}" || "${OPTARG}" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             f)
		[[ "$PH_FORCE_SUPPORT_FLAG" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_FORCE_SUPPORT_FLAG="0" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "default" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Default -t exact)
	do
		ph_support_app -a "$PH_APP" || \
			return 1
	done
	return 0
fi
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the application state of " "'${PH_APP}'"
PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
case "$PH_APP_STATE" in Supported|Integrated|Running|Halted)
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?" ;;
			Default|Out-of-scope)
	ph_run_with_rollback -c true -m "$PH_APP_STATE"
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the start command of " "'${PH_APP}'"
	if ! ph_check_app_state_validity -a "$PH_APP" -q -d
	then
		if [[ -z "$PH_APP_CMD" ]]
		then
			ph_set_result -m "Cannot support out-of-scope application '${PH_APP}' without a valid start command"
			ph_run_with_rollback -c false -m "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_CMD"
		ph_update_pkg_index || \
			return 1
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the package of " "'${PH_APP}'"
		if [[ -z "$PH_APP_PKG" || "$(ph_check_pkg_validity "$PH_APP_PKG" ; echo "$?")" -ne "0" ]]
		then
			ph_set_result -m "Cannot support out-of-scope application '${PH_APP}' without a valid package name"
			ph_run_with_rollback -c false "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_PKG"
	else
		if [[ -n "$PH_APP_CMD" && "$PH_APP_CMD" != "$(ph_get_app_cmd_from_app_name "$PH_APP")" ]]
		then
			PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known start command -> Set to '${PH_APP_CMD}'"
			ph_set_result -r 0
		else
			[[ -z "$PH_APP_CMD" ]] && \
				PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
			ph_run_with_rollback -c true -m "'${PH_APP_CMD}'"
		fi
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the package of " "'${PH_APP}'"
		if [[ -n "$PH_APP_PKG" && "$PH_APP_PKG" != "$(ph_get_app_pkg_from_app_name "$PH_APP")" ]]
		then
			PH_APP_PKG="$(ph_get_app_pkg_from_app_name "$PH_APP")"
			if [[ -n "$PH_APP_PKG" ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known package -> Set to '${PH_APP_PKG}'"
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Mismatch with known installation method -> Set to none" 
			fi
			ph_set_result -r 0
		else
			[[ -z "$PH_APP_PKG" ]] && \
				PH_APP_PKG="$(ph_get_app_pkg_from_app_name "$PH_APP")"
			if [[ -z "$PH_APP_PKG" ]]
			then
				ph_run_with_rollback -c true -m "Unpackaged"
			else
				ph_run_with_rollback -c true -m "${PH_APP_PKG}"
			fi
		fi
	fi
	if [[ -z "$PH_APP_INST_STATE" ]]
	then
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the installation state of " "'${PH_APP}'"
		if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf_file -a "$PH_APP" -c "$PH_APP_CMD")"
		then
			ph_run_with_rollback -c false -m "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
	fi
	declare -a PH_PARAMS
	[[ "$PH_APP_INST_STATE" == P* ]] && \
		PH_PARAMS+=("-p" "'${PH_APP_PKG}'")
	for PH_i in USER PKG
	do
		declare -n PH_VAR="PH_APP_${PH_i}"
		[[ -n "$PH_VAR" ]] && \
			PH_PARAMS+=("-$(cut -c1<<<"$PH_i" | tr "[:upper:]" "[:lower:]")" "'${PH_VAR}'")
		unset -n PH_VAR
	done
	if ! ph_check_app_user -a "$PH_APP" -i "$PH_APP_INST_STATE" "${PH_PARAMS[@]}"
	then
		unset PH_PARAMS
		return 1
	fi
	unset PH_PARAMS
	PH_APP_USER="$PH_PASS_APP_USER"
	unset PH_PASS_APP_USER
	PH_APP_GRAPH="$(ph_get_app_graphical_prop -a "$PH_APP" -c "$PH_APP_CMD")"
	PH_APP_EXEC="$(ph_get_app_executable -a "$PH_APP" -c "$PH_APP_CMD")"
	if [[ "$PH_APP" != "PieHelper" ]]
	then
		while true
		do
			PH_COUNT="0"
			printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the executable location of " "'${PH_APP}'"
			while true
			do
				PH_ANSWER="0"
				if [[ ! -x "$PH_APP_EXEC" ]]
				then
					[[ "$PH_COUNT" -eq "0" ]] && \
						printf "%10s\033[33m%s\033[0m\n" "" "Warning : Not found"
					printf "%8s%s\n\n" "" "--> How do you wish to proceed ?"
					printf "%12s\033[1;37m%s\033[0m\n" "" "1. Install ${PH_APP}"
					printf "%12s\033[1;37m%s\033[0m\n" "" "2. Enter the full pathname of executable '${PH_APP_EXEC##*/}' manually"
					printf "%12s\033[1;37m%s\033[0m\n" "" "3. Run a full system scan for '${PH_APP_EXEC##*/}'"
					if [[ "$PH_FORCE_SUPPORT_FLAG" -eq "0" ]]
					then
						printf "%12s\033[1;37m%s\033[0m\n" "" "4. Skip installation of ${PH_APP} for now (Disabled for dependencies)"
					else
						printf "%12s\033[1;37m%s\033[0m\n" "" "4. Skip installation of ${PH_APP} for now"
					fi
					printf "%12s\033[1;37m%s\033[0m\n\n" "" "5. Quit and rollback changes"
					printf "%12s%s" "" "Your choice : "
					read -r PH_ANSWER 2>/dev/null
					ph_screen_input "$PH_ANSWER" || \
						return 1
					PH_COUNT="$((PH_COUNT+1))"
					[[ "$PH_ANSWER" -ge "1" && "$PH_ANSWER" -le "5" ]] && \
						ph_run_with_rollback -c true
					case "$PH_ANSWER" in 1)
						break ;;
							     2)
						printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0m" "" "--> Please enter the full pathname of " "'${PH_APP_EXEC##*/}'" " (Leave empty to return to the previous menu) :"
						read -r PH_APP_EXEC 2>/dev/null
						ph_screen_input "$PH_APP_EXEC" || \
							return 1
						[[ -z "$PH_APP_EXEC" ]] && \
							ph_run_with_rollback -c true && \
							continue ;;
							     3)
						printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0m\n" "" "--> Scanning for executable " "'${PH_APP_EXEC##*/}'" " (This may take a while)"
						PH_APP_EXEC="$("$PH_SUDO" find / -type f -perm -o=x \( ! -fstype nfs -a ! -fstype cifs \) -name "${PH_APP_EXEC##*/}" 2>/dev/null)" ;;
							     4)
						if [[ "$PH_FORCE_SUPPORT_FLAG" -eq "0" ]]
						then
							printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
							continue
						else
							printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping installation but ${PH_APP} will not function until it is installed"
							ph_set_result -r 0
							break 2
						fi ;;
							     5)
						ph_quit_with_rollback ;;
							     *)
						printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
						continue ;;
					esac
					if [[ -x "$PH_APP_EXEC" ]]
					then
						ph_run_with_rollback -c true -m "Found as and changing to '${PH_APP_EXEC}'"
						PH_APP_CMD="$(echo "$PH_APP_CMD" | nawk -v app="$PH_APP" -v newpath="$PH_APP_EXEC" -v appgraph="$PH_APP_GRAPH" 'BEGIN { \
								i = "2" \
							} { \
								if (appgraph == "yes") { \
									if (app == "X11") { \
										printf newpath \
									} else { \
										printf $1 " " newpath ; \
										i++ \
									} \
								} else { \
									printf newpath \
								} ; \
								for (j=i;j<=NF;j++) { \
									printf " " $j \
								} \
							}')"
						if PH_APP_NEW_PKG="$(ph_get_app_pkg_from_executable "${PH_APP_EXEC}")"
						then
							if [[ "${PH_APP_NEW_PKG}" != "${PH_APP_PKG}" ]]
							then
								PH_APP_PKG="${PH_APP_NEW_PKG}"
								PH_APP_PKG_CHANGED_FLAG="0"
							fi
						else
							ph_set_result -m "An error occurred trying to determine the package name of file '${PH_APP_EXEC}'"
							ph_run_with_rollback -c false -m "Could not change" || \
								return 1
						fi
						break 2
					else
						continue 2
					fi
				else
					ph_run_with_rollback -c true -m "Found"
					break 2
				fi
			done
			ph_run_with_rollback -c "ph_install_app -a '${PH_APP}' -u '${PH_APP_USER}'" || \
				return 1
		done
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Rechecking the installation state of " "'${PH_APP}'"
		if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf_file -a "$PH_APP" -p "$PH_APP_PKG" -c "$PH_APP_CMD")"
		then
			ph_run_with_rollback -c false -m "Could not support" || \
				return 1
		fi
		ph_run_with_rollback -c true -m "$PH_APP_INST_STATE"
	fi
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking for dependencies of " "'${PH_APP}'"
	if [[ "$PH_APP_GRAPH" == "yes" && "$PH_APP" != "X11" ]]
	then
		ph_run_with_rollback -c true -m "X11"
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the application state of " "'X11'"
		PH_APP_STATE="$(ph_get_app_state_from_app_name X11)"
		if [[ "$PH_APP_STATE" == "Default" ]]
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : 'X11' is currently unsupported -> Supporting"
			ph_set_result -r 0
			ph_run_with_rollback -c "ph_support_app -a X11 -f" || \
				return 1
		else
			ph_run_with_rollback -c true -m "$PH_APP_STATE"
		fi
	else
		ph_run_with_rollback -c true -m "none"
	fi
	ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t support" || \
		return 1
	if [[ "$PH_APP_PKG_CHANGED_FLAG" -eq "0" ]]
	then
		PH_APPU="${PH_APP:0:4}"
		ph_run_with_rollback -c "ph_set_option_to_value '${PH_APP}' -r \"PH_${PH_APPU}_PKG'${PH_APP_NEW_PKG}\"" || \
			return 1
	fi
	ph_run_with_rollback -c "ph_add_app_to_support_file -a '${PH_APP}' -u '${PH_APP_USER}' -i '${PH_APP_INST_STATE}' -c '${PH_APP_CMD}'" || \
		return 1
	if ! ph_check_app_state_validity -a "$PH_APP" -q -d
	then
		ph_run_with_rollback -c "ph_create_oos_app_code '${PH_APP}'" || \
			return 1
	fi
	ph_add_value_to_param -p PH_UNSUP_APPS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_CMD}'${PH_APP_PKG}'${PH_APP_INST_STATE}"
	return 0 ;;
			*)
	PH_APPL="${PH_APP:0:4}"
	ph_set_result -m "Could not support '${PH_APP}' since it is using a reserved shortname '${PH_APPL}'" ;;
esac
ph_run_with_rollback -c false -m "Could not support" || \
	return 1
}

function ph_modify_app_script {

declare PH_APP
declare PH_APP_SCRIPT
declare PH_APP_USER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY
declare -i PH_APP_CUR_TTY
declare -i PH_RET_CODE

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_SCRIPT=""
PH_APP_USER=""
PH_OPTION=""
PH_APP_TTY="0"
PH_APP_CUR_TTY="0"
PH_RET_CODE="0"

OPTIND="1"

while getopts :a:t: PH_OPTION
do
	case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTARG="$PH_OLDOPTARG" && \
			OPTIND="$PH_OLDOPTIND" && \
			return 1
		PH_APP="$OPTARG" ;;
			     t)
		[[ "$PH_APP_TTY" -gt "0" || "$OPTARG" -le "1" || "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" ]] && \
			OPTARG="$PH_OLDOPTARG" && \
			OPTIND="$PH_OLDOPTIND" && \
			return 1
		PH_APP_TTY="$OPTARG" ;;
			     *)
		OPTARG="$PH_OLDOPTARG"
		OPTIND="$PH_OLDOPTIND"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTARG="$PH_OLDOPTARG"
OPTIND="$PH_OLDOPTIND"

[[ -z "$PH_APP" || "$PH_APP_TTY" -eq "0" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "$PH_APP" in Kodi)
	PH_APP_SCRIPT="/usr/bin/kodi"
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_CUR_TTY="$("$PH_SUDO" nawk '$0 ~ /\/bin\/chvt [0-9]/ { \
			print $NF ; \
			exit \
		}' "$PH_APP_SCRIPT" 2>/dev/null)"
	printf "%8s%s\n" "" "--> Modifying ${PH_APP} script '${PH_APP_SCRIPT}' to use 'tty${PH_APP_TTY}'"
	if "$PH_SUDO" nawk -v tty="$PH_APP_TTY" 'BEGIN {
			flag = "0"
		}
		$0 ~ /\/bin\/chvt [0-9]/ {
			for (i=1;i<=NF;i++) { 
				if ($i == "/bin/chvt") {
					flag = "1" ;
					printf "%s", $i " "
				} else {
					if (flag == "1") {
						printf tty
					} else {
						printf "%s", $i " "
					}
				}
			} ;
			printf "\n" ;
			next
		} {
			print
		}' "$PH_APP_SCRIPT" >"${PH_TMP_DIR}/kodi_tmp" 2>/dev/null
	then
		"$PH_SUDO" chown "${PH_APP_USER}:$(id -gn "$PH_RUN_USER" 2>/dev/null)" "${PH_TMP_DIR}/kodi_tmp" 2>/dev/null || \
			PH_RET_CODE="1"
		"$PH_SUDO" chmod 774 "${PH_TMP_DIR}/kodi_tmp" 2>/dev/null || \
			PH_RET_CODE="1"
		if [[ "$PH_RET_CODE" -eq "0" ]]
		then
			"$PH_SUDO" mv "${PH_TMP_DIR}/kodi_tmp" "$PH_APP_SCRIPT" 2>/dev/null || \
				PH_RET_CODE="1"
		fi
	else
		PH_RET_CODE="1"
	fi ;;
		  *)
	return "$PH_RET_CODE" ;;
esac
if [[ "$PH_RET_CODE" -ne "0" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Could not modify script"
	[[ "$PH_APP" == "Kodi" ]] && \
		"$PH_SUDO" rm "${PH_TMP_DIR}/kodi_tmp" 2>/dev/null
	ph_set_result -r 1 -m "An error occurred modifying '${PH_APP}' script '${PH_APP_SCRIPT}'"
else
	ph_add_value_to_param -p PH_MODIFY_APPS_SCRIPT -v "${PH_APP}'${PH_APP_CUR_TTY}"
	ph_run_with_rollback -c true
fi
return "$PH_RET_CODE"
}

function ph_get_app_inst_state_from_app_conf_file {

declare PH_APP
declare PH_APP_PKG
declare PH_APP_CMD
declare PH_APP_EXEC
declare PH_APP_INST_STATE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_PKG_RECEIVED_FLAG

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_APP_PKG=""
PH_APP_CMD=""
PH_APP_EXEC=""
PH_APP_INST_STATE=""
PH_OPTION=""
PH_PKG_RECEIVED_FLAG="1"

OPTIND="1"

while getopts :a:c:p: PH_OPTION
do
        case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}" ;;
                             p)
		[[ -n "${PH_APP_PKG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_PKG_RECEIVED_FLAG="0"
                PH_APP_PKG="${OPTARG}" ;;
                             c)
		[[ -n "${PH_APP_CMD}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_CMD="${OPTARG}" ;;
                             *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || "${#}" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "${PH_PKG_RECEIVED_FLAG}" -eq "1" ]] && \
	PH_APP_PKG="$(ph_get_app_pkg_from_app_name "${PH_APP}")"
if [[ -n "${PH_APP_PKG}" ]]
then
	ph_update_pkg_index || \
		return 1
	if ph_check_pkg_validity "${PH_APP_PKG}"
	then
		if ph_get_pkg_inst_state "${PH_APP}"
		then
			PH_APP_INST_STATE="PI"
		else
			PH_APP_INST_STATE="PU"
		fi
	else
		ph_set_result -m "Configuration file '${PH_CONF_DIR}/${PH_APP}.conf' contains an invalid package name '${PH_APP_PKG}'"
		return 1
	fi
else
	if [[ "${PH_APP}" == "PieHelper" ]]
	then
		PH_APP_INST_STATE="UI"
	else
		[[ -z "${PH_APP_CMD}" ]] && \
			PH_APP_CMD="$(ph_get_app_cmd_from_app_name "${PH_APP}")"
		if [[ -n "${PH_APP_CMD}" ]]
		then
			PH_APP_EXEC="$(ph_get_app_executable -a "${PH_APP}" -c "${PH_APP_CMD}")"
		else
			ph_set_result -m "Could not determine the application's installation state without a valid start command"
			return 1
		fi
		if [[ -x "${PH_APP_EXEC}" ]]
		then
			PH_APP_INST_STATE="UI"
		else
			PH_APP_INST_STATE="UU"
		fi
	fi
fi
echo -n "${PH_APP_INST_STATE}"
return 0
}

function ph_add_app_to_support_file {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_PKG
declare PH_APP_CMD
declare PH_APP_INST_STATE
declare PH_PARAM
declare PH_PARAMS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -l PH_il

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_USER=""
PH_APP_PKG=""
PH_APP_CMD=""
PH_APP_INST_STATE=""
PH_PARAM=""
PH_PARAMS=""
PH_OPTION=""
PH_COUNT="0"
PH_il=""

OPTIND="1"

while getopts :a:c:u:i: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ ( -z "$PH_APP_INST_STATE" && "$#" -ne "6" ) || ( -n "$PH_APP_INST_STATE" && "$#" -ne "8" ) || \
	-z "$PH_APP" || -z "$PH_APP_USER" || -z "$PH_APP_CMD" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Adding application " "'${PH_APP}'" " to configuration file " "'${PH_CONF_DIR}/supported_apps'"
if [[ -z "$PH_APP_INST_STATE" ]]
then
	if ! PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_conf_file -a "$PH_APP" -c "$PH_APP_CMD")"
	then
		ph_run_with_rollback -c false -m "Could not add" || \
			return 1
	fi
fi
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
		if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/supported_apps' -l '${PH_APP}\\t${PH_APP_USER}\\t${PH_APP_INST_STATE}\\t${PH_APP_CMD}'"
		then
			ph_run_with_rollback -c false -m "Could not add" || \
				return 1
		fi ;;
		    1)
		for PH_i in USER INST_STATE CMD
		do
			PH_il="$PH_i"
			declare -n PH_VAR="PH_APP_${PH_i}"
			PH_PARAM=""
			if [[ "$PH_VAR" != "$(eval "ph_get_app_${PH_il}_from_app_name \"$PH_APP\"")" ]]
			then
				case "${PH_i}" in USER)
					PH_PARAM="-c 2 -v '${PH_VAR}'" ;;
						  INST_STATE)
					PH_PARAM="-c 3 -v '${PH_VAR}'" ;;
						  CMD)
					PH_PARAM="-c 4 -v '${PH_VAR}'" ;;
				esac
			fi
			if [[ -n "$PH_PARAM" ]]
			then
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="$PH_PARAM" || \
					PH_PARAMS="${PH_PARAMS} ${PH_PARAM}"
			fi
			unset -n PH_VAR
		done
		if [[ -z "$PH_PARAMS" ]]
		then
			ph_run_with_rollback -c true -m "Nothing to do" && \
				return "$?"
		else
			ph_update_base_conf_file -a '${PH_APP}' -q -f sup ${PH_PARAMS} || \
				return 1
		fi ;;
		    *)
		ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/supported_apps' is corrupted -> Multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_REMOVE_APPS_FROM_SUP_FILE -v "${PH_APP}'${PH_APP_USER}'${PH_APP_INST_STATE}'${PH_APP_CMD}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_update_base_conf_file {

declare PH_APP
declare PH_APP_USER
declare PH_APP_INST_STATE
declare PH_APP_CMD
declare PH_APP_STR_TTY
declare PH_VAL_VALUE
declare PH_FILE
declare PH_FILE_SHORTNAME
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_VAL_COLUMN
declare -i PH_INDEX
declare -i PH_QUIESCE
declare -a PH_VAL_VALUES
declare -a PH_VAL_COLUMNS

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_USER=""
PH_APP_INST_STATE=""
PH_APP_CMD=""
PH_APP_STR_TTY=""
PH_VAL_VALUE=""
PH_FILE=""
PH_FILE_SHORTNAME=""
PH_OPTION=""
PH_VAL_COLUMN="0"
PH_INDEX="0"
PH_QUIESCE="1"

OPTIND="1"

while getopts :a:f:c:v:q PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			unset PH_VAL_VALUES PH_VAL_COLUMNS && \
			return 1
                PH_APP="$OPTARG" ;;
                             f)
		[[ -n "$PH_FILE_SHORTNAME" || "$OPTARG" != @(sup|int) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			unset PH_VAL_VALUES PH_VAL_COLUMNS && \
			return 1
                PH_FILE_SHORTNAME="$OPTARG" ;;
                             c)
                PH_VAL_COLUMNS+=("$OPTARG") ;;
                             v)
                PH_VAL_VALUES+=("$OPTARG") ;;
                             q)
		[[ "$PH_QUIESCE" -eq "0" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			unset PH_VAL_VALUES PH_VAL_COLUMNS && \
			return 1
		PH_QUIESCE="0" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		unset PH_VAL_VALUES PH_VAL_COLUMNS
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$PH_FILE_SHORTNAME" != @(cont|os|sup|int|@(default|allowed)s) || "$#" -lt "6" || "${#PH_VAL_VALUES[@]}" -eq "0" || "${#PH_VAL_COLUMNS[@]}" -ne "${#PH_VAL_VALUES[@]}" || \
	( "$PH_FILE_SHORTNAME" == "int" && ( "${#PH_VAL_VALUES[@]}" -ne "1" || "$#" -gt "9" )) || \
	( "$PH_FILE_SHORTNAME" == "sup" && ( "$#" -gt "17" || ( "${#PH_VAL_VALUES[@]}" -lt "1" || "${#PH_VAL_VALUES[@]}" -gt "3" ))) ]] && \
	unset PH_VAL_VALUES PH_VAL_COLUMNS && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_FILE="$(ph_get_filename_from_shortname "$PH_FILE_SHORTNAME")"
if [[ "$PH_FILE" == "supported_apps" ]]
then
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_INST_STATE="$(ph_get_app_user_from_app_name "$PH_APP")"
	PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
else
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
fi
[[ "$PH_QUIESCE" -eq "1" ]] && \
	printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Updating information for ${PH_APP} in configuration file " "'${PH_CONF_DIR}/${PH_FILE}'"
while true
do
	if [[ "$PH_FILE" == "supported_apps" ]]
	then
		if ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\t${PH_APP_USER}\t${PH_APP_INST_STATE}\t${PH_APP_CMD}'"
		then
			for PH_INDEX in "${!PH_VAL_VALUES[@]}"
			do
				PH_VAL_COLUMN="${PH_VAL_COLUMNS["$PH_INDEX"]}"
				PH_VAL_VALUE="${PH_VAL_VALUES["$PH_INDEX"]}"
				case "$PH_VAL_COLUMN" in 2)
					PH_APP_USER="$PH_VAL_VALUE" ;;
					     		 3)
					PH_APP_INST_STATE="$PH_VAL_VALUE" ;;
							 4)
					PH_APP_CMD="$PH_VAL_VALUE" ;;
				esac
			done
			unset PH_VAL_VALUES PH_VAL_COLUMNS
			if ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\\t${PH_APP_USER}\\t${PH_APP_INST_STATE}\\t${PH_APP_CMD}'"
			then
				break
			fi
		fi
	else
		if ph_run_with_rollback -c "ph_remove_line_from_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\t${PH_APP_STR_TTY}'"
		then
			PH_APP_STR_TTY="${PH_VAL_VALUES[0]}"
			unset PH_VAL_VALUES PH_VAL_COLUMNS
			if ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/${PH_FILE}' -l '${PH_APP}\\t${PH_APP_STR_TTY}'"
			then
				break
			fi
		fi
	fi
	unset PH_VAL_VALUES PH_VAL_COLUMNS
	[[ "$PH_QUIESCE" -eq "1" ]] && \
		ph_run_with_rollback -c false -m "Could not update"
	return 1
done
[[ "$PH_QUIESCE" -eq "1" ]] && \
	ph_run_with_rollback -c true
return 0
}

function ph_add_app_to_integration_file {

declare PH_APP
declare PH_APP_STR_TTY
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_STR_TTY=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"

while getopts :a:t: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ -n "$PH_APP_STR_TTY" || (( "$OPTARG" != @(+([[:digit:]])|-) ) && \
			( "$OPTARG" == +([[:digit:]]) && "$OPTARG" -le "1" && "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" )) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_STR_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || ( -n "$PH_APP_STR_TTY" && "$#" -ne "4" ) || \
	( -z "$PH_APP_STR_TTY" && "$#" -ne "2" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -z "$PH_APP_STR_TTY" ]] && \
	PH_APP_STR_TTY="-"
printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Adding application " "'${PH_APP}'" " to configuration file " "'${PH_CONF_DIR}/integrated_apps'"
PH_COUNT="$(nawk -v app="^${PH_APP}$" 'BEGIN { \
		count = "0" \
	} \
	$1 ~ app { \
		count++ ; \
		next \
	} { \
		next \
	} END { \
		print count \
	}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)"
case "$PH_COUNT" in 0)
		if ! ph_run_with_rollback -c "ph_add_line_to_file -f '${PH_CONF_DIR}/integrated_apps' -l '${PH_APP}\\t${PH_APP_STR_TTY}'"
		then
			ph_set_result -m "An error occurred adding ${PH_APP} to configuration file '${PH_CONF_DIR}/integrated_apps'"
			ph_run_with_rollback -c false -m "Could not add" || \
				return 1
		fi ;;
		   1)
		if [[ "$PH_APP_STR_TTY" == "$(ph_get_app_tty_from_app_name "$PH_APP")" ]]
		then
			ph_run_with_rollback -c true -m "Nothing to do" && \
				return "$?"
		else
			ph_update_base_conf_file -a '${PH_APP}' -q -f int -c 2 -v '${PH_APP_STR_TTY}' || \
				return 1
		fi ;;
		    *)
		ph_set_result -a -m "Configuration file '${PH_CONF_DIR}/integrated_apps' is corrupted -> Multiple instances of '${PH_APP}'" ;;
esac
ph_add_value_to_param -p PH_REMOVE_APPS_FROM_INT_FILE -v "${PH_APP}'${PH_APP_STR_TTY}"
ph_run_with_rollback -c true && \
	return "$?"
}

function ph_get_app_inst_state_from_app_name {

declare PH_APP
declare PH_FILE
declare PH_APP_INST_STATE

PH_APP="${1}"
PH_FILE=""
PH_APP_INST_STATE=""

[[ -z "${PH_APP}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_FILE in "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps_${PH_FILE_SUFFIX}"
do
	PH_APP_INST_STATE="$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
			printf $3 ; \
			exit 0 \
		} { \
			next \
		}' "${PH_FILE}" 2>/dev/null)"
	[[ -n "${PH_APP_INST_STATE}" ]] && \
		break
done
[[ "${PH_APP_INST_STATE}" != @(P|U)@(I|U) ]] && \
	return 1
echo -n "${PH_APP_INST_STATE}"
return 0
}

function ph_check_app_user {

declare PH_i
declare PH_APP
declare PH_APP_PKG
declare PH_APP_INST_STATE
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -i PH_CREATE_FLAG

PH_i=""
PH_APP=""
PH_APP_PKG=""
PH_APP_INST_STATE=""
PH_OPTION=""
PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_COUNT="0"
PH_CREATE_FLAG="1"

OPTIND="1"

while getopts :a:p:u:i: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     p)
		[[ -n "$PH_APP_PKG" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_PKG="$OPTARG" ;;
			     u)
		[[ -n "$PH_PASS_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_PASS_APP_USER="$OPTARG" ;;
			     i)
		[[ -n "$PH_APP_INST_STATE" || "$OPTARG" != @(P|U)@(I|U) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_INST_STATE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" && -z "$PH_APP_INST_STATE" && ( -z "$PH_APP_PKG" && "$PH_APP_INST_STATE" == P* ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the user account for " "'${PH_APP}'"
if [[ "$PH_APP" == "PieHelper" ]]
then
	PH_PASS_APP_USER="$PH_RUN_USER"
else
	while true
	do
		PH_COUNT="$((PH_COUNT+1))"
		if [[ -n "${PH_PASS_APP_USER}" && "$(ph_check_user_validity "${PH_PASS_APP_USER}"; echo "${?}")" -ne "0" ]]
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : User name '${PH_PASS_APP_USER}' contains invalid characters"
			PH_PASS_APP_USER=""
		else
			if ! ph_check_user_state "$PH_PASS_APP_USER"
			then
				if [[ -n "$PH_PASS_APP_USER" ]]
				then
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : User account '${PH_PASS_APP_USER}' does not exist -> Creating"
				else
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : No user provided"
					if [[ "$PH_COUNT" -eq "1" && "$PH_APP_INST_STATE" == "PI" ]]
					then
						ph_set_result -r 0
						printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Attempting to determine the user for " "'${PH_APP}'" " from package " "'${PH_APP_PKG}'"
						PH_PASS_APP_USER="$(systemctl show "$PH_APP_PKG" 2>/dev/null | nawk -F'=' '$1 ~ /^U(ser|ID)$/ && $2 !~ /\[not set\]/ { \
								printf $2 ; \
								exit 0 \
							}')"
						if [[ -n "$PH_PASS_APP_USER" ]]
						then
							if [[ "$PH_PASS_APP_USER" == +([[:digit:]]) ]]
							then
								PH_PASS_APP_USER="$(getent passwd "$PH_PASS_APP_USER" 2>/dev/null | head -1 | cut -d':' -f1)"
							fi
							break
						else
							printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not determine"
						fi
					fi
				fi
				ph_set_result -r 0
			fi
		fi
		if [[ -z "$PH_PASS_APP_USER" ]]
		then
			printf "%8s%s\033[1;33m%s\033[0m\n\n" "" "--> Please enter a valid user account for application " "'${PH_APP}'"
			printf "%10s\033[1;37m%s\033[0m\n" "" "- Entering an existing account will update the account's secondary group membership to include the following groups : 'tty,audio,video,input'"
			printf "%10s\033[1;37m%s\033[0m\n" "" "- Entering an non-existent account will create a user and corresponding UPG (User Private Group)"
			printf "%10s\033[1;37m%s\033[0m\n" "" "- Usernames must be alphanumeric and can optionally contain dash and underscore characters as well as a trailing dollar sign"
			printf "%10s\033[1;37m%s\033[33m%s\033[0m\n" "" "- Leave empty to use the default of " "'${PH_RUN_USER}'"
			printf "%10s\033[1;37m%s\033[0m\n\n" "" "- Or enter 'quit' to stop and rollback all changes"
			printf "%8s%s" "" "User account : "
			read -r PH_PASS_APP_USER 2>/dev/null
			case "$PH_PASS_APP_USER" in "")
				PH_PASS_APP_USER="$PH_RUN_USER" ;;
					quit)
				ph_quit_with_rollback ;;
					*)
				continue ;;
			esac
		else
			PH_CREATE_FLAG="0"
		fi
		break
	done
fi
ph_run_with_rollback -c true -m "$PH_PASS_APP_USER"
if [[ "$PH_PASS_APP_USER" != @(${PH_RUN_USER}|root) ]]
then
	if [[ "$PH_CREATE_FLAG" -eq "0" ]]
	then
		ph_run_with_rollback -c "ph_create_app_user -a '${PH_APP}' -u '${PH_PASS_APP_USER}'" || \
			return 1
	else
		ph_run_with_rollback -c "ph_set_user_group_membership '${PH_PASS_APP_USER}'" || \
			return 1
	fi
	ph_run_with_rollback -c "ph_grant_pieh_access -u '${PH_PASS_APP_USER}'" || \
		return 1
fi
return 0
}

function ph_quit_with_rollback {

[[ "${#}" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

ph_set_result -r 0 -w -m "Quitting at user request"
ph_show_result
ph_rollback_changes
exit "${?}"
}

function ph_remove_app_user {

declare PH_APP
declare PH_APP_USER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_APP=""
PH_APP_USER=""
PH_OPTION=""
PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"

OPTIND="1"

while getopts :a:u: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Removing user account " "'${PH_APP_USER}'"
if ! ph_check_user_state "$PH_APP_USER"
then
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
else
	if "$PH_SUDO" userdel -r "$PH_APP_USER" 2>/dev/null
	then
		ph_add_value_to_param -p PH_CREATE_APP_USER -v "${PH_APP}'${PH_APP_USER}"
		ph_run_with_rollback -c true && \
			return "$?"
	else
		ph_set_result -m "An error occurred trying to remove user '${PH_APP_USER}'"
	fi
fi
ph_run_with_rollback -c false -m "Could not remove" || \
	return 1
}

function ph_create_app_user {

declare PH_APP
declare PH_APP_USER
declare PH_APP_USER_PASS
declare PH_APP_USER_PASS_REPEAT
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP=""
PH_APP_USER=""
PH_APP_USER_PASS=""
PH_APP_USER_PASS_REPEAT=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"

while getopts :a:u: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
			     u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

while [[ -z "$PH_APP_USER_PASS" || "$(ph_check_password_validity "$PH_APP_USER_PASS" ; echo "$?")" -ne "0" ||
	"$PH_APP_USER_PASS" != "$PH_APP_USER_PASS_REPEAT" ]]
do
	[[ "$PH_COUNT" -gt "0" ]] && \
		ph_set_result -r 0
	printf "%8s%s\033[1;33m%s\033[0;0m\n\n" "" "--> Please enter a password for user " "'${PH_APP_USER}'"
	printf "%10s\033[1;37m%s\033[0;0m\n" "" "- Passwords may not contain single quote (') or blank characters such as space or tab"
	printf "%10s\033[1;37m%s\033[0;0m\n" "" "- Entered passwords will not be displayed"
	printf "%10s\033[1;37m%s\033[0;0m\n\n" "" "- Or enter 'quit' to stop and rollback all changes"
	printf "%8s%s" "" "User password : "
	read -rs PH_APP_USER_PASS 2>/dev/null
	ph_screen_input "$PH_APP_USER_PASS" || \
		return 1
	PH_COUNT="$((PH_COUNT+1))"
	case "$PH_APP_USER_PASS" in "")
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords may not be empty" ;;
			quit)
		ph_quit_with_rollback ;;
			*)
		if ! ph_check_password_validity "$PH_APP_USER_PASS"
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords may not contain single quote (') or space characters"
		else
			ph_run_with_rollback -c true
			printf "%8s%s" "" "Please re-enter the password : "
			read -rs PH_APP_USER_PASS_REPEAT 2>/dev/null
			ph_screen_input "$PH_APP_USER_PASS_REPEAT" || \
				return 1
			if [[ "$PH_APP_USER_PASS" == "$PH_APP_USER_PASS_REPEAT" ]]
			then
				ph_run_with_rollback -c true
				printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Creating user account " "'${PH_APP_USER}'"
				if "$PH_SUDO" useradd -d "/home/${PH_APP_USER}" -m -c "PieHelper application ${PH_APP}" -s /bin/bash \
					-G tty,audio,video,input "$PH_APP_USER" >/dev/null 2>&1
				then
					if "$PH_SUDO" "${PH_SCRIPTS_DIR}/app/setpasswd.expect" "$PH_APP_USER" "$PH_APP_USER_PASS" >/dev/null 2>&1
					then
						ph_add_value_to_param -p PH_REMOVE_APP_USER -v "${PH_APP}'${PH_APP_USER}"
						ph_run_with_rollback -c true -m "$PH_APP_USER" && \
							return "$?"
					else
						ph_set_result -m "An error occurred trying to set the password for user '${PH_APP_USER}'"
					fi
				else
					ph_set_result -m "An error occurred trying to create user '${PH_APP_USER}'"
				fi
				break
			else
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Passwords do not match -> Try again"
			fi
		fi
		continue ;;
	esac
done
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_revoke_pieh_access {

declare PH_APP_USER
declare PH_PARAMS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP_USER=""
PH_PARAMS=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"

while getopts :u:q PH_OPTION
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
                             q)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_COUNT="$(nawk -v user="^${PH_APP_USER}$" 'BEGIN { \
		count= "0" \
	} \
	$2 ~ user { \
		count++ \
	} { \
		next \
	} END { \
		printf count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) && "$PH_COUNT" -eq "1" ]]
then
	ph_run_with_rollback -c "ph_user_acls -p remove -u '${PH_APP_USER}' -t immediate ${PH_PARAMS}" || \
		return 1
	ph_run_with_rollback -c "ph_remove_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" || \
		return 1
	ph_add_value_to_param -p PH_GRANT_APPS_ACCESS -v "${PH_APP_USER}'${PH_PARAMS}"
fi
return 0
}

function ph_grant_pieh_access {

declare PH_APP_USER
declare PH_PARAMS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_APP_USER=""
PH_PARAMS=""
PH_OPTION=""
PH_COUNT="0"

OPTIND="1"

while getopts :u:q PH_OPTION
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER="$OPTARG" ;;
                             q)
		[[ -n "$PH_PARAMS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_PARAMS="-q" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_COUNT="$(nawk -v user="^${PH_APP_USER}$" 'BEGIN { \
		count= "0" \
	} \
	$2 ~ user { \
		count++ \
	} { \
		next \
	} END { \
		printf count \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
if [[ "$PH_APP_USER" != @(root|${PH_RUN_USER}) && "$PH_COUNT" -eq "0" ]]
then
	ph_run_with_rollback -c "ph_user_acls -p create -u '${PH_APP_USER}' -t immediate ${PH_PARAMS}" || \
		return 1
	ph_run_with_rollback -c "ph_create_user_sudo_rights -u '${PH_APP_USER}' ${PH_PARAMS}" || \
		return 1
	ph_add_value_to_param -p PH_REVOKE_APPS_ACCESS -v "${PH_APP_USER}'${PH_PARAMS}"
fi
return 0
}

function ph_integrate_app {

declare PH_i
declare PH_APP
declare PH_APP_CMD
declare PH_APP_STATE
declare PH_APP_INST_STATE
declare PH_APP_USER
declare PH_APP_STR_TTY
declare PH_PARAMS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_CMD=""
PH_APP_STATE=""
PH_APP_INST_STATE=""
PH_APP_USER=""
PH_APP_STR_TTY=""
PH_PARAMS=""
PH_OPTION=""
PH_APP_TTY="0"

OPTIND="1"

while getopts :a:t:c:u: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG"
		if [[ "$PH_APP_TTY" -eq "0" ]]
		then
			PH_APP_STR_TTY="-"
		else
			PH_APP_STR_TTY="$PH_APP_TTY"
		fi ;;
                             c)
		[[ -n "$PH_APP_CMD" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_CMD="$OPTARG" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || "$#" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "$PH_APP" == "supported" ]]
then
	for PH_APP in $(ph_get_app_list_by_state -s Supported -t exact)
	do
		ph_integrate_app -a "$PH_APP" || \
			return 1
	done
	return 0
else
	if [[ -z "$PH_APP" ]]
	then
		for PH_i in CMD USER TTY
		do
			declare -n PH_VAR="PH_APP_${PH_i}"
			case "$PH_i" in CMD)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-c '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -c '${PH_VAR}'" ;;
					USER)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-u '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -u '${PH_VAR}'" ;;
					TTY)
				[[ -z "$PH_PARAMS" ]] && \
					PH_PARAMS="-t '${PH_VAR}'" || \
					PH_PARAMS="${PH_PARAMS} -t '${PH_VAR}'" ;;
			esac
			unset -n PH_VAR
		done
		if [[ -n "$PH_PARAMS" ]]
		then
			! PH_APP="$(ph_get_app_name_from_base_conf_file ${PH_PARAMS})" && \
				return 1
		fi
	fi
fi
[[ "$PH_APP" == "Emulationstation" ]] && \
	PH_APP_USER="$(ls -lad "$PH_EMUL_SETUP_DIR" 2>/dev/null | nawk '{ \
			print $3 \
		}')"
PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
## prompt here if empty
# [[ -z "$PH_APP" ]]
# optional only if other prompt [[ "$PH_APP_TTY" -eq "0" ]]

printf "%8s%s\n" "" "--> Checking application name parameter"
if [[ -z "$PH_APP" ]]
then
	printf "%10s\033[31m%s\033[0m\n" "" "ERROR : Invalid application name"
	ph_set_result -r 1 -m "A valid name is mandatory for integrating an application"
	return 1
else
	ph_run_with_rollback -c true -m "${PH_APP}"
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the application state of " "'${PH_APP}'"
	PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_APP")"
	case "$PH_APP_STATE" in Supported)
			ph_run_with_rollback -c true -m "${PH_APP_STATE}" ;;
				Integrated|Halted|Running)
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid application state"
			ph_set_result -r 0
			return 0 ;;
				*)
			ph_set_result -m "Could not integrate application ${PH_APP} since it has not been priorly supported"
			ph_run_with_rollback -c false -m "Could not integrate" || \
				return 1 ;;
	esac
fi
if [[ -n "${PH_APP_STR_TTY}" ]]
then
	printf "%8s%s\n" "" "--> Checking the tty parameter"
	ph_set_result -r 0
	if [[ "$PH_APP" == "PieHelper" ]]
	then
		if [[ "$PH_APP_TTY" -ne "2" ]]
		then
			PH_APP_TTY="2"
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid TTY -> Setting to 'tty${PH_APP_TTY}'"
		else
			ph_run_with_rollback -c true -m "tty${PH_APP_TTY}"
		fi
	else
		if [[ "$PH_APP_TTY" -lt "3" || "$PH_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" ]]
		then
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid tty -> Allocating new tty"
			ph_allocate_new_tty "$PH_APP"
			PH_APP_TTY="$?"
			[[ "$PH_APP_TTY" -eq "1" ]] && \
				return 1
		else
			if cut -f3 "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | grep -E "^${PH_APP_TTY}$" >/dev/null
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid tty -> Allocating new tty"
				ph_allocate_new_tty "$PH_APP"
				PH_APP_TTY="$?"
				[[ "$PH_APP_TTY" -eq "1" ]] && \
					return 1
			else
				ph_run_with_rollback -c true -m "tty${PH_APP_TTY}"
			fi
		fi
	fi
else
	[[ "$PH_APP" == "PieHelper" ]] && \
		PH_APP_TTY="2"
fi
ph_run_with_rollback -c "ph_create_app_items -a '${PH_APP}' -t integrate" || \
	return 1
if [[ "$PH_APP_TTY" -ne "0" ]]
then
	ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -u '${PH_APP_USER}' -t '${PH_APP_TTY}'" || \
		return 1
else
	ph_run_with_rollback -c "ph_add_app_to_integration_file -a '${PH_APP}' -t '${PH_APP_TTY}'" || \
		return 1
fi
[[ "$PH_APP" == "PieHelper" ]] && \
	PH_RUN_USER="$PH_APP_USER"
ph_run_with_rollback -c "ph_secure_pieh -t delayed" || \
	return 1
ph_add_value_to_param -p PH_UNINT_APPS -v "${PH_APP}"
return 0
}

function ph_ensure_app_tty {

declare PH_APP
declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP="$1"
PH_APP_USER=""
PH_APP_STR_TTY=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
if [[ "$PH_APP_STR_TTY" == "-" ]]
then
	ph_allocate_new_tty "$PH_APP"
	PH_APP_STR_TTY="$?"
	[[ "$PH_APP_STR_TTY" -eq "1" ]] && \
		return 1
	PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
	ph_run_with_rollback -c "ph_setup_tty -a '${PH_APP}' -t '${PH_APP_STR_TTY}' -u '${PH_APP_USER}'" || \
		return 1
fi
return 0
}

function ph_undo_setup_tty {

declare PH_APP
declare PH_APP_USER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_APP_USER=""
PH_OPTION=""
PH_APP_TTY="0"

OPTIND="1"

while getopts :a:u:t: PH_OPTION
do
        case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}" ;;
                             u)
		[[ -n "${PH_APP_USER}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_USER="${OPTARG}" ;;
                             t)
		[[ "${PH_APP_TTY}" -gt "0" || "${OPTARG}" -le "1" || "${OPTARG}" -gt "${PH_PIEH_MAX_TTYS}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_TTY="${OPTARG}" ;;
                             *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || "${#}" -lt "2" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ "${PH_APP_TTY}" -eq "0" ]] && \
	PH_APP_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
[[ -z "${PH_APP_USER}" ]] && \
	PH_APP_USER="$(ph_get_app_user_from_app_name "${PH_APP}")"
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Deallocating " "'tty${PH_APP_TTY}'"
if ph_update_base_conf_file -a "${PH_APP}" -q -f int -c 2 -v "-"
then
	ph_run_with_rollback -c true
	printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing the LoginScript for " "'${PH_APP}'" " as " "'/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
	if ph_run_with_rollback -c "ph_store_file -r -f '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
	then
		ph_run_with_rollback -c true
		printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Removing the autologin configuration for " "'${PH_APP}'" " as " "'/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
		if ph_run_with_rollback -c "ph_store_file -r -f '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
		then
			if "${PH_SUDO}" systemctl daemon-reload >/dev/null 2>&1
			then
				ph_run_with_rollback -c true
				if [[ "$("${PH_SUDO}" find "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/"* -maxdepth 1 -print 2>/dev/null | wc -l)" -eq "0" ]]
				then
					ph_run_with_rollback -c "ph_remove_empty_file -r -t directory -d '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d'" || \
						return 1
				fi
				ph_add_value_to_param -p PH_SETUP_TTYS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
				return 0
			else
				ph_set_result -m "An error occurred trying to reload systemd configuration"
			fi
		fi
	fi
	ph_run_with_rollback -c false -m "Could not remove" || \
		return 1
fi
ph_run_with_rollback -c false -m "Could not deallocate" || \
	return 1
}

function ph_setup_tty {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_APP_TTY
declare -i PH_RET_CODE
declare -l PH_APPL

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_APP_USER=""
PH_APP_CMD=""
PH_OPTION=""
PH_APP_TTY="0"
PH_RET_CODE="0"
PH_APPL=""

OPTIND="1"

while getopts :a:u:t: PH_OPTION
do
        case "$PH_OPTION" in a)
		[[ -n "$PH_APP" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP="$OPTARG"
		PH_APPL="${PH_APP:0:4}" ;;
                             u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
                             t)
		[[ "$PH_APP_TTY" -gt "0" || "$OPTARG" -le "1" || "$OPTARG" -gt "$PH_PIEH_MAX_TTYS" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_TTY="$OPTARG" ;;
                             *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP" || -z "$PH_APP_USER" || "$PH_APP_TTY" -eq "0" || "$#" -ne "6" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_CMD="${PH_SCRIPTS_DIR}/start${PH_APPL}.sh"
if [[ ! -d "/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d" ]]
then
	ph_run_with_rollback -c "ph_create_empty_file -r -t directory -d '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d'" || \
		return 1
fi
printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Installing the autologin configuration for " "'${PH_APP}'" " as " "'/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
if ph_run_with_rollback -c "ph_create_empty_file -q -r -t file -d '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf'"
then
	for PH_i in '[Service]' 'ExecStart=' "ExecStart=-/sbin/agetty --autologin ${PH_APP_USER} --noclear tty${PH_APP_TTY} \$TERM"
	do
		if ! ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/systemd/system/getty@tty${PH_APP_TTY}.service.d/autologin.conf' -l '${PH_i}'"
		then
			ph_run_with_rollback -c false -m "Could not install" || \
				return 1
		fi
	done
	if "$PH_SUDO" systemctl daemon-reload >/dev/null 2>&1
	then
		ph_run_with_rollback -c true
		if [[ "$PH_FILE_SUFFIX" == "_GL" && "$PH_APP" == "Kodi" ]]
		then
			ph_run_with_rollback -c "ph_modify_app_script -a '${PH_APP}' -t '${PH_APP_TTY}'" || \
				return 1
		fi
		if ph_run_with_rollback -c "ph_copy_file -s '${PH_TEMPLATES_DIR}/LoginScript.template' -d '${PH_CONF_DIR}/LoginScript.conf'"
		then
			ph_run_with_rollback -c "ph_set_option_to_value LoginScript -r \"PH_APP_TTY'tty${PH_APP_TTY}\" -r \"PH_APP_USER'${PH_APP_USER}\" -r \"PH_APP_CMD'${PH_APP_CMD}\"" || \
				return 1
			printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Installing the LoginScript for " "'${PH_APP}'" " as " "'/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
			if ph_run_with_rollback -c "ph_copy_file -q -r -m -s '${PH_CONF_DIR}/LoginScript.conf' -d '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh'"
			then
				if "$PH_SUDO" chown "${PH_APP_USER}:$(id -gn "$PH_APP_USER" 2>/dev/null)" "/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh" 2>/dev/null
				then
					ph_run_with_rollback -c true
					ph_run_with_rollback -c "ph_add_app_to_integration_file -a '${PH_APP}' -t '${PH_APP_TTY}'" || \
						return 1
					ph_add_value_to_param -p PH_UNDO_SETUP_TTYS -v "${PH_APP}'${PH_APP_USER}'${PH_APP_TTY}"
					return 0
				else
					ph_set_result -m "An error occurred trying to set ownership of file '/etc/profile.d/PieHelper_tty${PH_APP_TTY}.sh' to '${PH_APP_USER}:$(id -gn "$PH_APP_USER" 2>/dev/null)'"
				fi
			fi
		fi
	else
		ph_set_result -m "An error occurred trying to reload systemd configuration"
	fi
fi
ph_run_with_rollback -c false -m "Could not install" || \
	return 1
}

function ph_set_app_for_start {

declare PH_APP
declare PH_APP_STR_TTY
declare PH_OLD_STARTAPP
declare -i PH_COLUMNS
declare -i PH_COUNT

PH_APP="$1"
PH_APP_STR_TTY=""
PH_OLD_STARTAPP="$PH_PIEH_STARTAPP"
PH_COLUMNS="$(tput cols 2>/dev/null)"
PH_COUNT="0"

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\n" "" "--> Checking current StartApp"
ph_run_with_rollback -c true -m "$PH_OLD_STARTAPP"
if [[ "$PH_APP" == "prompt" ]]
then
	printf "%8s%s\n" "" "--> Please choose the application to start on system boot"
	declare -a PH_APP_READ=($(ph_get_app_list_by_state -s Integrated -t minimum))
	while true
	do
		[[ "$PH_COUNT" -gt "0" ]] && \
			printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
		nawk '{
			printf "%10s\033[1;37m%s%s\033[0;0m\n", "", NR ". ", $1
		}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null
		printf "%10s\033[1;37m%s%s\033[0;0m\n" "" "${#PH_APP_READ[@]}. " "none"
		printf "%10s\033[1;37m%s%s\033[0;0m\n\n" "" "$(("${#PH_APP_READ[@]}"+1)). " "Keep the current StartApp : '${PH_PIEH_STARTAPP}'"
		printf "%8s%s" "" "Your choice : "
		read -r PH_APP_READ[0] 2>/dev/null
		((PH_COUNT++))
		ph_screen_input "${PH_APP_READ[0]}" || \
			return 1
		case "${PH_APP_READ[0]}" in $(cat -n "${PH_CONF_DIR}/integrated_apps" 2>/dev/null | nawk '{ \
				print $1 \
			}' | paste -d "|" -s))
			PH_APP="$(nawk -v line="${PH_APP_READ[0]}" '{ \
					if (NR == line) { \
						print $1 \
					} \
				}' "${PH_CONF_DIR}/integrated_apps" 2>/dev/null)" ;;
					    "${#PH_APP_READ[@]}")
			PH_APP="none" ;;
					    "$(("${#PH_APP_READ[@]}"+1))")
			unset PH_APP_READ 2>/dev/null
			ph_run_with_rollback -c true -m "Skipping" && \
				return "$?" ;;
		esac
		if [[ -n "$PH_APP" ]]
		then
			unset PH_APP_READ
			ph_run_with_rollback -c true -m "$PH_APP"
			break
		fi
	done
fi
printf "%8s%s\n" "" "--> Comparing old and new values for StartApp"
if [[ "$PH_PIEH_STARTAPP" == "$PH_APP" ]]
then
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
else
	ph_run_with_rollback -c true
fi
if [[ "$PH_APP" != "none" ]]
then
	ph_ensure_app_tty "$PH_APP" || \
		return 1
	PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
fi
ph_run_with_rollback -c "ph_set_tty_for_boot '${PH_APP_STR_TTY}'" || \
	return 1
ph_run_with_rollback -c "ph_set_option_to_value PieHelper -r \"PH_PIEH_STARTAPP'${PH_APP}\"" || \
	return 1
ph_add_value_to_param -p PH_STARTAPP -v "$PH_OLD_STARTAPP"
return 0
}

function ph_get_app_name_from_login_script {

declare PH_APP
declare PH_APP_STR_TTY
declare -l PH_APPL
declare -l PH_COMPAREAPPL

PH_APP_STR_TTY="$1"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_COMPAREAPPL="$("$PH_SUDO" nawk -F\' '$1 ~ /^PH_APP_CMD=$/ { \
		print substr($2,index($2,"start")+5,index($2,".")-(index($2,"start")+5)) \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh" 2>/dev/null)"
for PH_APP in $(ph_get_app_list_by_state -s Integrated -t minimum)
do
	PH_APPL="${PH_APP:0:4}"
	[[ "$PH_APPL" == "$PH_COMPAREAPPL" ]] && \
		break
done
[[ -z "$PH_APP" ]] && \
	return 1
echo -n "$PH_APP"
return 0
}

function ph_get_app_user_from_autologin {

declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP_USER=""
PH_APP_STR_TTY="$1"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" nawk '$0 ~ /autologin/ && $1 ~ /^ExecStart=/ { \
		print $3 \
	}' "/etc/systemd/system/getty@tty${PH_APP_STR_TTY}.service.d/autologin.conf" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_tty_from_autologin {

declare PH_APP_STR_TTY
declare -i PH_CUR_APP_TTY

PH_APP_STR_TTY="$1"
PH_CUR_APP_TTY="0"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_CUR_APP_TTY="$("$PH_SUDO" nawk '$0 ~ /autologin/ && $1 ~ /^ExecStart=/ { \
		print substr($5,4,length($5)-3) \
	}' "/etc/systemd/system/getty@tty${PH_APP_STR_TTY}.service.d/autologin.conf" 2>/dev/null)"
echo -n "$PH_CUR_APP_TTY"
[[ "$PH_CUR_APP_TTY" -le "1" || "$PH_CUR_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_STR_TTY" != "$PH_CUR_APP_TTY" ]] && \
	return 1
return 0
}

function ph_get_app_user_from_app_tty {

declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP_USER=""
PH_APP_STR_TTY="$1"

[[ "$PH_APP_STR_TTY" != @(+([[:digit:]])|-) || "$#" -ne "1" || \
	( "$PH_APP_STR_TTY" == +([[:digit:]]) && ( "$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" )) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(ph_get_app_user_from_app_name "$(ph_get_app_name_from_app_tty "$PH_APP_STR_TTY")")"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_user_from_login_script {

declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP_USER=""
PH_APP_STR_TTY="$1"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" nawk 'BEGIN { \
		FS = "\x27" \
	} \
	$1 ~ /^PH_APP_USER=/ { \
		printf $2 \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh" 2>/dev/null)"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_get_app_tty_from_login_script {

declare PH_APP_STR_TTY
declare -i PH_CUR_APP_TTY

PH_APP_STR_TTY="$1"
PH_CUR_APP_TTY="0"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_CUR_APP_TTY="$("$PH_SUDO" nawk 'BEGIN { \
		FS = "\x27" \
	} \
	$1 ~ /^PH_APP_TTY=/ { \
		printf substr($2,4,length($2)-3) \
	}' "/etc/profile.d/PieHelper_tty${PH_APP_STR_TTY}.sh" 2>/dev/null)"
echo -n "$PH_CUR_APP_TTY"
[[ "$PH_CUR_APP_TTY" -le "1" || "$PH_CUR_APP_TTY" -gt "$PH_PIEH_MAX_TTYS" || "$PH_APP_STR_TTY" != "$PH_CUR_APP_TTY" ]] && \
	return 1
return 0
}

function ph_get_app_user_from_login_script_owner {

declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP_USER=""
PH_APP_STR_TTY="$1"

[[ "$PH_APP_STR_TTY" == "-" || "$#" -ne "1" || \
	"$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$("$PH_SUDO" find /etc/profile.d -mount -name "PieHelper_tty${PH_APP_STR_TTY}.sh" -exec ls -la {} \; 2>/dev/null | nawk '{ \
		print $3 \
	}')"
[[ -z "$PH_APP_USER" ]] && \
	return 1
echo -n "$PH_APP_USER"
return 0
}

function ph_check_app_integration_data_validity {

declare PH_APP
declare PH_APP_USER
declare PH_APP_STR_TTY

PH_APP="$1"
PH_APP_USER=""
PH_APP_STR_TTY=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_USER="$(ph_get_app_user_from_app_name "$PH_APP")"
PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "$PH_APP")"
if [[ "$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
		printf NF ; \
		exit 0 \
	}' "$PH_CONF_DIR/integrated_apps" 2>/dev/null)" -ne "2" || \
	"$(ph_check_user_state "$PH_APP_USER" ; echo "$?")" -ne "0" || \
	"$PH_APP_STR_TTY" != @(+([[:digit:]])|-) || \
	( "$PH_APP_STR_TTY" == +([[:digit:]]) && ( "$PH_APP_STR_TTY" -le "1" || "$PH_APP_STR_TTY" -gt "$PH_PIEH_MAX_TTYS" )) ]]
then
	return 1
else
	return 0
fi
}

function ph_check_app_support_data_validity {

declare PH_APP
declare PH_APP_INST_STATE
declare PH_APP_CMD

PH_APP="$1"
PH_APP_INST_STATE=""
PH_APP_CMD=""

[[ -z "$PH_APP" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "$PH_APP")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "$PH_APP")"
if [[ "$(nawk -v app="^${PH_APP}$" '$1 ~ app { \
		printf NF ; \
		exit 0 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)" -lt "4" || \
	"$PH_APP_INST_STATE" != @(P|U)@(I|U) || \
	! -x "$(ph_get_app_executable -a "$PH_APP" -c "$PH_APP_CMD")" ]]
then
	return 1
else
	return 0
fi
}

function ph_show_report {

[[ "$#" -gt "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "\n\033[36m%s\033[0m\n" "- Verifying the configuration of PieHelper"
printf "\n%2s\033[31m%s\033[0m%s\n\n" "" "FAILED : " "Critical configuration issues detected"
nawk '$1 ~ /^OR$/ {
		printf "\n%s\033[36m%s\033[0m\n\n", "", $0 ;
		next
	} {
		printf "%s%s\n", "", $0
	}' "${PH_TMP_DIR}/.reported_issues" 2>/dev/null
printf "\n%2s\033[31m%s\033[0m\n" "" "They need to be resolved for normal operation to continue"
printf "%2s\033[31m%s\033[0m\n\n" "" "Fix issues manually or run '${PH_SUDO} ${PH_SCRIPTS_DIR}/confpieh_ph.sh -v' to attempt automatic repair"
exit 1
}

function ph_repair_pieh {

declare PH_i
declare PH_APP
declare PH_APP2
declare PH_APP_USER
declare PH_APPS
declare PH_INTAPPS
declare PH_SUPAPPS
declare PH_ANSWER
declare PH_NEED_BOOT
declare PH_MOVE_SCRIPTS_REGEX
declare -l PH_APPL
declare -l PH_APPL2
declare -u PH_APPU
declare -i PH_APP_TTY

PH_i=""
PH_APP=""
PH_APP2=""
PH_APP_USER=""
PH_APPS=""
PH_INTAPPS=""
PH_SUPAPPS=""
PH_ANSWER=""
PH_NEED_BOOT="no"
PH_MOVE_SCRIPTS_REGEX=""
PH_APPL=""
PH_APPL2=""
PH_APPU=""
PH_APP_TTY="0"

printf "\n\033[36m%s\033[0m\n\n" "- Verifying PieHelper configurations"
printf "%2s%s\n\n" "" "This will :"
printf "%4s%s\n" "" "- Verify the existence of all 'Unique' files and exit with an error if any are missing"
printf "%4s%s\n" "" "- Verify the existence of all 'Optional' files and display a warning if any are missing"
printf "%4s%s\n" "" "- Attempt to stop all 'Running' applications and exit with an error if unsuccessful"
printf "%4s%s\n" "" "- Verify the integrity of the base configuration files and repair any anomalies found (User input may be required)"
printf "%4s%s\n" "" "- Unallocate and clear configurations of all TTYs used by PieHelper ('2'->'$PH_PIEH_MAX_TTYS')"
printf "%4s%s\n" "" "- Generate new 'Derivate' files based on base configuration file content (Option values will be preserved)"
printf "%4s%s\n" "" "- Allocate 'TTY2' to 'PieHelper'"
printf "%4s%s\n" "" "- Recursively remove all files and directories under your installation directory not related to PieHelper"
printf "%4s%s\n" "" "- Reapply default ownership and permissions and reconfigure all required ACLs and sudo rights"
printf "%4s%s\n\n" "" "- Reboot your system if required"
while [[ "$PH_ANSWER" != @(y|n) ]]
do
	[[ "$PH_COUNT" -gt "0" ]] && printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
	printf "%8s%s\033[1;37m%s\033[0;0m%s" "" "--> Continue verification of PieHelper " "(y/n)" " ? "
	read -r PH_ANSWER 2>/dev/null
	ph_screen_input "$PH_ANSWER" || \
		return 1
	((PH_COUNT++))
done
printf "%10s\033[32m%s\033[0m\n" "" "OK"
ph_set_result -r 0
if [[ "$PH_ANSWER" == "n" ]]
then
	ph_set_result -w -m "Quit at user request"
	ph_show_result
	return "$?"
fi
"$PH_SUDO" rm "${PH_TMP_DIR}/.first_run" 2>/dev/null
for PH_i in "$PH_SCRIPTS_DIR" "$PH_MAIN_DIR" "${PH_MAIN_DIR}/expect" "$PH_FILES_DIR" "$PH_MENUS_DIR" "$PH_CONF_DIR" "${PH_CONF_DIR}/distros" \
	"${PH_FUNCS_DIR}" "${PH_FUNCS_DIR}/distros" "${PH_MAIN_DIR}/post_cmds" "${PH_MAIN_DIR}/pre_cmds" "$PH_MNT_DIR" \
	"$PH_TMP_DIR" "$PH_BUILD_DIR" "$PH_SNAPSHOT_DIR" "$PH_TEMPLATES_DIR" "$PH_EXCLUDES_DIR" "${PH_FILES_DIR}/stored"
do
	ph_check_object_existence -o "$PH_i" || \
		return 1
done
for PH_i in LoginScript StartScript StopScript RestartScript StartScriptPieH StopScriptPieH RestartScriptPieH MovetoPieHScript \
	MovefromPieHScript MoveScript Kodi_conf Moonlight_conf PieHelper_conf Emulationstation_conf Bash_conf X11_conf Controllers_conf \
	OOSapp_conf
do
	ph_check_object_existence -o "${PH_TEMPLATES_DIR}/${PH_i}.template" || \
		return 1
done
for PH_i in default_apps_X default_apps_GL
do
	ph_check_object_existence -o "${PH_FILES_DIR}/${PH_i}" || \
		return 1
done
for PH_i in Support System Applications Main SystemRetaineds SystemRetained SystemInteractive PS3 PS4 XBOX360 XBOXSX
do
	ph_check_object_existence -o "${PH_MENUS_DIR}/${PH_i}.lst" || \
		return 1
done
for PH_i in confopts_ph confoper_ph confapps_ph confctrl_ph listblue_ph listmoon_ph confgena_ph confpieh_ph app/post_cmds/Kodi-POST \
	app/post_cmds/PieHelper-POST app/pre_cmds/PieHelper-PRE app/pre_cmds/Kodi-PRE
do
	ph_check_object_existence -o "${PH_SCRIPTS_DIR}/${PH_i}.sh" || \
		return 1
done
for PH_i in "${PH_CHECK_SUPPORTED[@]}"
do
	ph_check_object_existence -o "${PH_CONF_DIR}/distros/${PH_i}.conf" || \
		return 1
done
for PH_i in "${PH_SUPPORTED_DISTROS[@]}"
do
	ph_check_object_existence -o "${PH_FUNCS_DIR}/distros/functions.${PH_i}" || \
		return 1
done
for PH_i in functions.main functions.update functions.user
do
	ph_check_object_existence -o "${PH_FUNCS_DIR}/${PH_i}" || \
		return 1
done
ph_check_object_existence -o "${PH_SCRIPTS_DIR}/../app/expect/confctrls.expect" || \
	return 1
for PH_i in README.md TODO CODE_OF_CONDUCT.md INSTALL LICENSE
do
	ph_check_object_existence -o "${PH_BASE_DIR}/${PH_i}"
done
PH_MOVE_SCRIPTS_REGEX="$(ph_get_move_scripts_regex)"
"$PH_SUDO" rm "${PH_BASE_DIR}/"!(@(README.md|TODO|CODE_OF_CONDUCT.md|INSTALL|HOWTO|LICENSE|@(build|snapshot|function|script|file)s|tmp|mnt|main|conf|.git|.github)) 2>/dev/null
"$PH_SUDO" rm "${PH_SCRIPTS_DIR}/"!(@(app|@(@(conf|list)*_ph|@(re|)start*|stop*|${PH_MOVE_SCRIPTS_REGEX})\.sh)) 2>/dev/null
"$PH_SUDO" rm "${PH_MAIN_DIR}/"!(@(@(pre|post)_cmds|main.sh|expect)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MAIN_DIR}/expect/"!(@(setpasswd|confctrls)\.expect) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MAIN_DIR}/pre_cmds/"!(@(Kodi|PieHelper)-PRE\.sh) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MAIN_DIR}/post_cmds/"!(@(Kodi|PieHelper)-POST\.sh) 2>/dev/null
"$PH_SUDO" rm "${PH_FUNCS_DIR}/"!(@(distros|functions@(main|\.@(user|update)))) 2>/dev/null
"$PH_SUDO" rm -r "${PH_FUNCS_DIR}/distros/"!(functions\.@($(sed 's/ /\|/g'<<<"${PH_SUPPORTED_DISTROS[@]}"))) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/"!(@(menus|excludes|templates|stored|VERSIONS|default_apps_@(X|GL))) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/stored/"!(@(autologin|logind)_conf|10-retropie_sh) 2>/dev/null
"$PH_SUDO" rm -r "${PH_EXCLUDES_DIR}/"!(@(tar|kodi)\.excludes) 2>/dev/null
"$PH_SUDO" rm -r "${PH_TEMPLATES_DIR}/"!(@(@(Login|@(S|Res)tart|Stop|Move@(to|from)PieH|Move)Script|@(@(Res|S)tart|Stop)ScriptPieH|@(Kodi|Moonlight|PieHelper|Emulationstation|Bash|X11|Controllers|OOSapp)_conf)\.template) 2>/dev/null
"$PH_SUDO" rm "${PH_CONF_DIR}/"!(@(distros|@(supported|integrated)_apps|OS\.defaults|VERSION|controller_cli_ids)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_CONF_DIR}/distros/"!(@($(sed 's/ /\|/g'<<<${PH_CHECK_SUPPORTED[@]}))\.conf) 2>/dev/null
"$PH_SUDO" rm -r "${PH_MENUS_DIR}/"!(*\.lst) 2>/dev/null
"$PH_SUDO" rm -r "${PH_TMP_DIR}/"!(\.@(first_run|gitignore|stored_options)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_BUILD_DIR}/"!(@(PieHelper*\.tar|\.gitignore)) 2>/dev/null
"$PH_SUDO" rm -r "${PH_SNAPSHOT_DIR}/"!(@(PieHelper*\.tar|\.gitignore)) 2>/dev/null
"$PH_SUDO" rm "${PH_MNT_DIR}/"!(\.gitignore) 2>/dev/null
if ! ph_check_object_existence -o sup
then
	ph_create_base_conf_file sup
	ph_support_app -a PieHelper
else
	printf "%8s%s\n" "" "--> Checking support for application 'PieHelper'"
	if ! nawk -v app="^PieHelper$" '$1 ~ app { exit 1 } { next }' "$PH_CONF_DIR/supported_apps" 2>/dev/null
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n" "" "--> Checking 'PieHelper' support data integrity"
		if ph_check_app_support_data_validity PieHelper
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
			ph_support_app -a PieHelper
		fi
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Supporting"
		ph_support_app -a PieHelper
	fi
fi
. "$PH_CONF_DIR"/PieHelper.conf >/dev/null 2>&1
if ! ph_check_object_existence -o int
then
	ph_create_base_conf_file int
	ph_integrate_app -a PieHelper
else
	printf "%8s%s\n" "" "--> Checking integration for application 'PieHelper'"
	if ! nawk -v app=^"PieHelper"$ '$1 ~ app { exit 1 } { next }' "$PH_CONF_DIR"/integrated_apps 2>/dev/null
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
		printf "%8s%s\n" "" "--> Checking 'PieHelper' integration data integrity"
		if ph_check_app_integration_data_validity PieHelper
		then
			printf "%10s\033[32m%s\033[0m\n" "" "OK"
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted integration data found -> Reintegrating"
			ph_integrate_app -a PieHelper
		fi
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Integrating"
		ph_integrate_app -a PieHelper
	fi
fi
PH_RUN_USER="$(ph_get_app_user_from_app_name PieHelper)"
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the PATH and LD_LIBRARY_PATH extension of " "'PieHelper'"
if [[ ! -f "/etc/profile.d/PieHelper-path.sh" ]]
then
	printf "%10s\033[33m%s\033[0m\n" "" "Warning (Not found) -> Creating"
	ph_pieh_configured_path_conf || return 1
	source /etc/profile.d/PieHelper-path.sh >/dev/null 2>&1
	PH_NEED_BOOT="yes"
else
	printf "%10s\033[32m%s\033[0m\n" "" "OK (Found)"
fi
PH_INTAPPS="$(nawk 'BEGIN { ORS =  " " } $1 !~ /^PieHelper$/ { print $1 }' "$PH_CONF_DIR/integrated_apps" 2>/dev/null)"
PH_SUPAPPS="$(nawk 'BEGIN { ORS =  " " } $1 !~ /^PieHelper$/ { print $1 }' "$PH_CONF_DIR/supported_apps" 2>/dev/null)"
for PH_APP in $(echo -n "$PH_INTAPPS")
do
        printf "%8s%s\n" "" "--> Checking support for integrated application '$PH_APP'"
        for PH_APP2 in $(echo -n "$PH_SUPAPPS")
        do
                if [[ "$PH_APP" == "$PH_APP2" ]]
                then
                        printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
                        printf "%8s%s\n" "" "--> Checking integrated application '$PH_APP' support data integrity"
			if ph_check_app_support_data_validity "$PH_APP"
			then
                        	printf "%10s\033[32m%s\033[0m\n" "" "OK"
			else
                                printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
				ph_support_app -a "$PH_APP"
				. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
                        fi
                        continue 2
                fi
        done
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Supporting"
	ph_support_app -a "$PH_APP"
	. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
	[[ -z "$PH_APPS" ]] && PH_APPS="$PH_APP" || PH_APPS="$PH_APPS $PH_APP"
done
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
	for PH_APP2 in $(echo -n "$PH_INTAPPS")
	do
		[[ "$PH_APP" == "$PH_APP2" ]] && continue 2
	done
        printf "%8s%s\n" "" "--> Checking unintegrated application '$PH_APP' support data integrity"
	if ph_check_app_support_data_validity "$PH_APP"
	then
		printf "%10s\033[32m%s\033[0m\n" "" "OK"
	else
		printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted support data found -> Resupporting"
		ph_support_app -a "$PH_APP"
		. "$PH_CONF_DIR"/"$PH_APP".conf >/dev/null 2>&1
	fi
done
[[ -n "$PH_APPS" ]] && PH_SUPAPPS="$PH_SUPAPPS $PH_APPS"
if ! ph_stop_all_running_apps forced
then
	ph_show_result
	return "$?"
fi
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
        printf "%8s%s\n" "" "--> Checking integration for supported application '$PH_APP'"
        for PH_APP2 in $(echo -n "$PH_INTAPPS")
        do
                if [[ "$PH_APP" == "$PH_APP2" ]]
                then
                        printf "%10s\033[32m%s\033[0m\n" "" "OK (Yes)"
                        printf "%8s%s\n" "" "--> Checking supported application '$PH_APP' integration data integrity"
			if ph_check_app_integration_data_validity "$PH_APP"
			then
                        	printf "%10s\033[32m%s\033[0m\n" "" "OK"
			else
                                printf "%10s\033[33m%s\033[0m\n" "" "Warning : Corrupted integration data found -> Reintegrating"
				ph_integrate_app -a "$PH_APP"
                        fi
                        continue 2
                fi
        done
	printf "%10s\033[33m%s\033[0m\n" "" "Warning : No -> Skipping"
done
printf "%8s%s\n" "" "--> Clearing 'TTY2' -> 'TTY$PH_PIEH_MAX_TTYS' configurations"
for ((PH_i=2;PH_i<="$PH_PIEH_MAX_TTYS";PH_i++))
do
        rm -r /etc/systemd/system/getty@tty"$PH_i".service.d 2>/dev/null
        rm -r /etc/profile.d/PieHelper_tty"$PH_i".sh 2>/dev/null
done
for PH_APP in "PieHelper" $(echo -n "$PH_INTAPPS")
do
	nawk -v app=^"$PH_APP"$ '$1 ~ app { print $1 "\t" $2 "\t" "-" ; next } { print }' "$PH_CONF_DIR/integrated_apps" >/tmp/integrated_apps_tmp 2>/dev/null
	[[ "$?" -eq "0" ]] && mv /tmp/integrated_apps_tmp "$PH_CONF_DIR/integrated_apps" 2>/dev/null
done
printf "%10s\033[32m%s\033[0m\n" "" "OK"
ph_run_with_rollback -c "ph_store_all_options"
for PH_APP in Controllers PieHelper ${PH_SUPAPPS}
do
	ph_create_app_conf_file "$PH_APP"
	. "${PH_CONF_DIR}/${PH_APP}.conf"
	mv "${PH_CONF_DIR}/${PH_APP}.conf" "${PH_CONF_DIR}/temp" 2>/dev/null
done
if [[ "$PH_DISTRO" == "Debian" ]]
then
        PH_DISTRO_REL="$(lsb_release -a 2>/dev/null | nawk '$1 ~ /^Codename:/ { printf $2 }')"
	if [[ ! -L "$PH_CONF_DIR/distros/$PH_DISTRO.conf" ]]
	then
		ph_create_empty_file -t link -s "$PH_CONF_DIR/distros/$PH_DISTRO_REL.conf" -d "$PH_CONF_DIR/distros/$PH_DISTRO.conf"
	fi
fi
for PH_i in cont os defaults alloweds
do
	ph_create_base_conf_file "$PH_i"
done
for PH_APP in PieHelper Controllers $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_alloweds "$PH_APP"
done
for PH_APP in PieHelper Controllers $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_defaults "$PH_APP"
done
ph_run_with_rollback -c "ph_retrieve_stored_options"
ph_setup_tty -a "PieHelper" -u "$PH_RUN_USER" -t "2"
printf "%8s%s\n" "" "--> Generating 'Derivate' miscellaneous files"
"$PH_SUDO" rm "${PH_EXCLUDES_DIR}/"* 2>/dev/null
cat >"${PH_EXCLUDES_DIR}/tar.excludes" <<EOF
./.git
./.github
./builds/PieHelper*
./snapshots/PieHelper*
./files/stored/autologin_conf
./files/stored/logind_conf
./files/stored/10-retropie_sh
./tmp/*
./mnt/*/*
EOF
cat >"${PH_EXCLUDES_DIR}/kodi.excludes" <<EOF
./.kodi/temp/*
./.kodi/addons/temp/*
EOF
rm -r "${PH_EXCLUDES_DIR}/"!(@(tar|kodi).excludes) 2>/dev/null
"$PH_SUDO" rm "${PH_FILES_DIR}/"!(@(exclude|template)s) 2>/dev/null
mkdir "$PH_TEMPLATES_DIR}/temp" 2>/dev/null
mv "${PH_TEMPLATES_DIR}/"+(LoginScript|StartScript|StopScript|RestartScript|StartScriptPieH|StopScriptPieH|RestartScriptPieH|MovetoPieHScript|MovefromPieHScript|MoveScript|Kodi_conf|Moonlight_conf|PieHelper_conf|Emulationstation_conf|Bash_conf|X11_conf|Controllers_conf|OOSapp_conf)".template" "${PH_TEMPLATES_DIR}/temp" 2>/dev/null
"$PH_SUDO" rm -r "${PH_TEMPLATES_DIR}/"!(temp) 2>/dev/null
mv "${PH_TEMPLATES_DIR}/temp/"* "$PH_TEMPLATES_DIR" 2>/dev/null
rmdir "${PH_TEMPLATES_DIR}/temp" 2>/dev/null
printf "%10s\033[32m%s\033[0m\n" "" "OK"
mkdir "$PH_SCRIPTS_DIR/temp" 2>/dev/null
mv "${PH_SCRIPTS_DIR}/"@(conf|list)*.sh "${PH_SCRIPTS_DIR}/temp" 2>/dev/null
for PH_APP in "PieHelper" $(echo -n "$PH_INTAPPS")
do
        ph_create_app_scripts "$PH_APP"
        PH_APPL="${PH_APP:0:4}"
        mv "$PH_SCRIPTS_DIR/start$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        mv "$PH_SCRIPTS_DIR/stop$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        mv "$PH_SCRIPTS_DIR/restart$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
        for PH_APP2 in $(echo -n "$PH_INTAPPS")
	do
		PH_APPL2="${PH_APP2:0:4}"
		if [[ "$PH_APP" != "$PH_APP2" ]]
		then
			mv "$PH_SCRIPTS_DIR/$PH_APPL""to$PH_APPL2.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
			mv "$PH_SCRIPTS_DIR/$PH_APPL2""to$PH_APPL.sh" "$PH_SCRIPTS_DIR/temp" 2>/dev/null
		fi
	done
done
rm -r "$PH_SCRIPTS_DIR/"!(temp) 2>/dev/null
mv "$PH_SCRIPTS_DIR/temp/"* "$PH_SCRIPTS_DIR" 2>/dev/null
rmdir "$PH_SCRIPTS_DIR/temp" 2>/dev/null
mkdir -p "$PH_MENUS_DIR/temp" 2>/dev/null
mv "$PH_MENUS_DIR/"@(Support.lst|Main.lst|PS3.lst|PS4.lst|System.lst|Applications.lst|SystemRetaineds.lst|SystemRetained.lst|SystemInteractive.lst|XBOX360.lst|XBOXSX.lst) "$PH_MENUS_DIR/temp" 2>/dev/null
rm -r "$PH_MENUS_DIR/"!(temp) 2>/dev/null
for PH_APP in $(echo -n "$PH_SUPAPPS")
do
	ph_create_app_menus "$PH_APP"
done
mv "$PH_MENUS_DIR/temp/"* "$PH_MENUS_DIR/" 2>/dev/null
ph_link_app_to_menu -a PieHelper
rmdir "$PH_MENUS_DIR/temp" 2>/dev/null
ph_set_app_for_start PieHelper
rm /etc/sudoers.d/020_pieh-* 2>/dev/null
ph_secure_pieh -t never
if [[ "$PH_NEED_BOOT" == "yes" ]]
then
	ph_show_result
	printf "\n%s\033[1;33m%s\033[0m%s\n\n" "A reboot is required since the PATH and LD_LIBRARY_PATH extension for " "'PieHelper'" " was reinstalled"
	printf "%s" "Press 'Enter' to reboot and continue"
	read -r 2>/dev/null
	chvt 1
	init 6
fi
ph_show_result
return "$?"
}

function ph_start_services {

declare PH_SERVICES
declare PH_SERVICE

PH_SERVICES="${*}"
PH_SERVICE=""

[[ "${#}" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_SERVICE in ${PH_SERVICES}
do
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Starting systemd service " "'${PH_SERVICE}'"
	if systemctl is-active "${PH_SERVICE}" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
		while true
		do
        		if "${PH_SUDO}" systemctl start "${PH_SERVICE}" >/dev/null 2>&1
			then
        			if "${PH_SUDO}" systemctl daemon-reload >/dev/null 2>&1
				then
					break
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			else
				ph_set_result -m "An error occurred trying to start systemd service '${PH_SERVICE}'"
			fi
			ph_run_with_rollback -c false -m "Could not start" || \
				return 1
		done
		ph_add_value_to_param -p PH_STOP_SERVICES -v "${PH_SERVICE}"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_enable_services {

declare PH_SERVICES
declare PH_SERVICE

PH_SERVICES="${*}"
PH_SERVICE=""

[[ "${#}" -lt "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

for PH_SERVICE in ${PH_SERVICES}
do
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Enabling systemd service " "'${PH_SERVICE}'"
	if systemctl is-enabled "${PH_SERVICE}" >/dev/null 2>&1
	then
		ph_run_with_rollback -c true -m "Nothing to do"
	else
		while true
		do
        		if "${PH_SUDO}" systemctl enable "${PH_SERVICE}" >/dev/null 2>&1
			then
        			if "${PH_SUDO}" systemctl daemon-reload >/dev/null 2>&1
				then
					break
				else
					ph_set_result -m "An error occurred trying to reload systemd configuration"
				fi
			else
				ph_set_result -m "An error occurred trying to enable systemd service '${PH_SERVICE}'"
			fi
			ph_run_with_rollback -c false -m "Could not enable" || \
				return 1
		done
		ph_add_value_to_param -p PH_DISABLE_SERVICES -v "${PH_SERVICE}"
		ph_run_with_rollback -c true
	fi
done
return 0
}

function ph_pieh_configured_path_conf {

[[ "$#" -ne "0" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[0m\n" "" "--> Creating the PATH and LD_LIBRARY_PATH extension for " "'${PH_APP}'" " as " "'/etc/profile.d/PieHelper-path.sh'"
if [[ ! -f /etc/profile.d/PieHelper-path.sh ]]
then
	if ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/profile.d/PieHelper-path.sh'"
	then
		if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/profile.d/PieHelper-path.sh' -l 'export \"LD_LIBRARY_PATH=/usr/local/lib:\${LD_LIBRARY_PATH}\"'"
		then
			if ph_run_with_rollback -c "ph_add_line_to_file -r -f '/etc/profile.d/PieHelper-path.sh' -l 'export \"PATH=/usr/local/bin:${PH_SCRIPTS_DIR}:\${PATH}\"'"
			then
				ph_add_value_to_param -p PH_UNCONFIGURED_STATE -v "path"
				ph_run_with_rollback -c true && \
					return "$?"
			fi
		fi
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
ph_run_with_rollback -c false -m "Could not create" || \
	return 1
}

function ph_set_user_group_membership {

declare PH_i
declare PH_APP_USER
declare PH_APP_USER_GROUPS
declare PH_APP_USER_CUR_GROUPS
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP_USER=""
PH_APP_USER_GROUPS=""
PH_APP_USER_CUR_GROUPS=""
PH_OPTION=""

OPTIND="1"

while getopts :u:g: PH_OPTION
do
        case "$PH_OPTION" in u)
		[[ -n "$PH_APP_USER" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
                PH_APP_USER="$OPTARG" ;;
			     g)
		[[ -n "$PH_APP_USER_GROUPS" || -z "$OPTARG" ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_APP_USER_GROUPS="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_APP_USER" || -z "$PH_APP_USER_GROUPS" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Ensuring secondary group membership of groups " "'${PH_APP_USER_GROUPS}'" " for user " "'${PH_APP_USER}'"
PH_APP_USER_CUR_GROUPS="$(groups "$PH_APP_USER" 2>/dev/null | nawk 'BEGIN { \
		OFS = "," \
	} { \
		for (i=3;i<=NF;i++) { \
			if (NF==i) { \
				printf $i \
			} else { \
				printf "%s", $i "," \
			} \
		} \
	}')"
if [[ "$( (for PH_i in ${PH_APP_USER_CUR_GROUPS//,/ }; \
do \
	echo "$PH_i"; \
done) | sort -u)" != "$( (for PH_i in ${PH_APP_USER_GROUPS//,/ } ${PH_APP_USER_CUR_GROUPS//,/ }; \
	do \
		echo "$PH_i"; \
	done) | sort -u)" ]]
then
	PH_APP_USER_GROUPS="$( (for PH_i in ${PH_APP_USER_GROUPS//,/ } ${PH_APP_USER_CUR_GROUPS//,/ }; \
	do \
		echo "$PH_i"; \
	done) | sort -u)"
	if "$PH_SUDO" usermod -G "$PH_APP_USER_GROUPS" "$PH_APP_USER" >/dev/null 2>&1
	then
		ph_add_value_to_param -p PH_GROUPS -v "${PH_APP_USER}'${PH_APP_USER_CUR_GROUPS}"
		ph_run_with_rollback -c true -m "${PH_APP_USER_GROUPS}"
	else
		ph_set_result -m "An error occurred trying to ensure secondary group membership of groups '${PH_APP_USER_GROUPS}' for user '${PH_APP_USER}'"
		ph_run_with_rollback -c false -m "Could not ensure" || \
			return 1
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_unblacklist_kernel_module {

declare PH_MODULE

PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Unblacklisting kernel module " "'${PH_MODULE}'"
if "$PH_SUDO" grep -E "^blacklist ${PH_MODULE}$" /etc/modprobe.d/xboxdrv-blacklist.conf >/dev/null 2>&1
then
	if ! ph_run_with_rollback -c "ph_remove_line_from_file -r -f '/etc/modprobe.d/xboxdrv-blacklist.conf' -l 'blacklist ${PH_MODULE}'"
	then
		ph_run_with_rollback -c false -m "Could not unblacklist" || \
			return 1
	else
		ph_add_value_to_param -p PH_BLACKLIST_MODULES -v "$PH_MODULE"
		ph_run_with_rollback -c true && \
			return "$?"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return "$?"
fi
}

function ph_blacklist_kernel_module {

declare PH_MODULE

PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	ph_run_with_rollback -c "ph_unload_kernel_module '${PH_MODULE}'" || \
		return 1
fi
printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Blacklisting kernel module " "'${PH_MODULE}'"
if [[ ! -f /etc/modprobe.d/xboxdrv-blacklist.conf ]]
then
	if ! ph_run_with_rollback -c "ph_create_empty_file -r -q -t file -d '/etc/modprobe.d/xboxdrv-blacklist.conf'"
	then
		ph_run_with_rollback -c false -m "Could not blacklist" || \
			return 1
	fi
fi
if ! "$PH_SUDO" grep -E "^blacklist ${PH_MODULE}$" /etc/modprobe.d/xboxdrv-blacklist.conf >/dev/null 2>&1
then
	if ph_run_with_rollback -c "ph_add_line_to_file -r -f /etc/modprobe.d/xboxdrv-blacklist.conf -l 'blacklist ${PH_MODULE}'"
	then
		ph_add_value_to_param -p PH_UNBLACKLIST_MODULES -v "$PH_MODULE"
		ph_run_with_rollback -c true && \
			return "$?"
	fi
else
	ph_run_with_rollback -c true -m "Nothing to do" && \
		return 0
fi
ph_run_with_rollback -c false -m "Could not blacklist" || \
	return 1
}

function ph_load_kernel_module {

declare PH_MODULE

PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Loading kernel module " "'${PH_MODULE}'"
if ! grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	if ! "$PH_SUDO" modprobe "$PH_MODULE" >/dev/null 2>&1
	then
		ph_run_with_rollback -c false -m "Could not load" || \
			 return 1
	fi
	ph_add_value_to_param -p PH_UNLOAD_MODULES -v "$PH_MODULE"
	ph_run_with_rollback -c true
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_unload_kernel_module {

declare PH_MODULE

PH_MODULE="$1"

[[ -z "$PH_MODULE" || "$#" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Unloading kernel module " "'${PH_MODULE}'"
if grep -E "^${PH_MODULE}([[:space:]])+.*$" /proc/modules >/dev/null 2>&1
then
	if ! "$PH_SUDO" rmmod "$PH_MODULE" >/dev/null 2>&1
	then
		ph_run_with_rollback -c false -m "Could not unload" || \
			return 1
	fi
	ph_add_value_to_param -p PH_LOAD_MODULES -v "$PH_MODULE"
	ph_run_with_rollback -c true
else
	ph_run_with_rollback -c true -m "Nothing to do"
fi
return 0
}

function ph_get_app_list_by_state {

declare PH_i
declare PH_APP
declare PH_REQ_APP_STATE
declare PH_STATE_MATCH_TYPE
declare PH_REQ_APP_STATE_PARAM
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_INDEX

PH_OLDOPTARG="$OPTARG"
PH_OLDOPTIND="$OPTIND"
PH_i=""
PH_APP=""
PH_REQ_APP_STATE=""
PH_STATE_MATCH_TYPE=""
PH_REQ_APP_STATE_PARAM=""
PH_OPTION=""
PH_INDEX="0"

OPTIND="1"

while getopts :s:t: PH_OPTION
do
	case "$PH_OPTION" in s)
		[[ -n "$PH_REQ_APP_STATE" || "$OPTARG" != @(Integrated|Supported|Default|Running|Halted|Unused|Out-of-scope|Reserved) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_REQ_APP_STATE="$OPTARG" ;;
			     t)
		[[ -n "$PH_STATE_MATCH_TYPE" || "$OPTARG" != @(exact|minimum) ]] && \
			OPTIND="$PH_OLDOPTIND" && \
			OPTARG="$PH_OLDOPTARG" && \
			return 1
		PH_STATE_MATCH_TYPE="$OPTARG" ;;
			     *)
		OPTIND="$PH_OLDOPTIND"
		OPTARG="$PH_OLDOPTARG"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="$PH_OLDOPTIND"
OPTARG="$PH_OLDOPTARG"

[[ -z "$PH_REQ_APP_STATE" || -z "$PH_STATE_MATCH_TYPE" || "$#" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -a PH_APP_LIST
case "$PH_REQ_APP_STATE" in Integrated)
	PH_REQ_APP_STATE_PARAM="-i" ;;
			    Supported)
	PH_REQ_APP_STATE_PARAM="-s" ;;
			    Default)
	PH_REQ_APP_STATE_PARAM="-d" ;;
			    Halted)
	PH_REQ_APP_STATE_PARAM="-h" ;;
			    Running)
	PH_REQ_APP_STATE_PARAM="-r" ;;
			    Unused)
	PH_REQ_APP_STATE_PARAM="-u" ;;
			    Reserved)
	PH_REQ_APP_STATE_PARAM="-v" ;;
			    Out-of-scope)
	PH_REQ_APP_STATE_PARAM="-o" ;;
esac
for PH_APP in $(nawk 'BEGIN { \
		ORS = " " \
	} { \
		print $1 \
	}' "${PH_CONF_DIR}/supported_apps" "${PH_FILES_DIR}/default_apps${PH_FILE_SUFFIX}" 2>/dev/null)
do
	for PH_i in "${PH_APP_LIST[@]}"
	do
		[[ "$PH_i" == "$PH_APP" ]] && \
			continue 2
	done
	if [[ "$PH_STATE_MATCH_TYPE" == "exact" ]]
	then
		if [[ "${PH_REQ_APP_STATE}" == "Unused" ]]
		then
			if [[ "$(ph_get_app_state_from_app_name "$PH_APP")" == @(Default|Out-of-scope) ]]
			then
				PH_APP_LIST+=("$PH_APP")
			fi
		else
			if [[ "$(ph_get_app_state_from_app_name "$PH_APP")" == "$PH_REQ_APP_STATE" ]]
			then
				PH_APP_LIST+=("$PH_APP")
			fi
		fi
	else
		if ph_check_app_state_validity -a "$PH_APP" -q "${PH_REQ_APP_STATE_PARAM}"
		then
			PH_APP_LIST+=("$PH_APP")
		fi
	fi
done
for PH_INDEX in "${!PH_APP_LIST[@]}"
do
	if [[ "${PH_APP_LIST["${PH_INDEX}"]}" == "PieHelper" ]]
	then
		unset PH_APP_LIST["${PH_INDEX}"]
		echo -n PieHelper
		echo -n " "
		break
	fi
		
done
for PH_INDEX in "${!PH_APP_LIST[@]}"
do
	echo -n "${PH_APP_LIST["${PH_INDEX}"]}"
	[[ "${PH_INDEX}" -ne "${#PH_APP_LIST[@]}" ]] && \
		echo -n " "
done
unset PH_APP_LIST
return 0
}

function ph_configure_pieh {

declare PH_i
declare PH_ANSWER
declare PH_RUN_GROUP
declare PH_CONF_STATE
declare PH_MODE
declare -i PH_COUNT
declare -i PH_DISTRO_FLAG
declare -u PH_DISTROU

PH_i=""
PH_ANSWER=""
PH_RUN_GROUP=""
PH_CONF_STATE=""
PH_MODE="normal"
PH_COUNT="0"
PH_DISTRO_FLAG="1"
PH_DISTROU=""

PH_ROLLBACK_USED="yes"

[[ "${#}" -gt "1" || ( "${#}" -eq "1" && "${1}" != "-b" ) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

[[ -n "${1}" ]] && \
	PH_MODE="batch"
if [[ "${PH_MODE}" == "normal" ]]
then
	PH_CONF_STATE="$(ph_get_pieh_conf_state -q)"
	if [[ "${PH_CONF_STATE}" == "configured" ]]
	then
		ph_set_result -r 0 -w -m "PieHelper is already ${PH_CONF_STATE}"
		return 0
	fi
	[[ -z "${PH_RUN_USER}" ]] && \
		PH_RUN_USER="$(whoami 2>/dev/null)"
	printf "%2s\033[1;37m%s\n\n" "" "This will :"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\033[1;33m%s\033[1;37m%s\n" "" "- Configure " "'${PH_RUN_USER}'" " as the user account for the " "'PieHelper'" " application"
	printf "%4s%s\n" "" "- Install all required packages"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\n" "" "- Detect and backup existing StartApp configurations made by " "'Emulationstation'" " (RetroPie)"
	printf "%4s%s\n" "" "- Create all base configuration files"
	printf "%4s%s\033[1;33m%s\033[1;37m\n" "" "- Install the PATH and LD_LIBRARY_PATH extension for " "'PieHelper'"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\n" "" "- Setup " "'PieHelper'" " as a Supported application"
	printf "%4s%s\n" "" "- Create all items for controller management"
	printf "%4s%s\n" "" "- Change a few system related settings"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\n" "" "- Setup " "'PieHelper'" " as an Integrated application"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\n" "" "- Configure " "'PieHelper'" " as the system's StartApp"
	printf "%4s%s\n" "" "- Disable the graphical environment"
	printf "%4s%s\n" "" "- Allow you to update your system"
	printf "%4s%s\033[1;33m%s\033[1;37m%s\033[0m\n\n" "" "- Reboot the system into the " "'PieHelper'" " menu"
	while [[ "${PH_ANSWER}" != @(y@(es|)|n@(o|)) ]]
	do
		[[ "${PH_COUNT}" -gt "0" ]] && \
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
		printf "%8s%s\033[1;33m%s\033[0m%s\033[1;33m%s\033[1;37m%s\033[0m%s" "" "--> Continue configuring " "'PieHelper'" " under account " "'${PH_RUN_USER}'" " (y/n)" " ? "
		read -r PH_ANSWER 2>/dev/null
		ph_screen_input "${PH_ANSWER}" || \
			return 1
		((PH_COUNT++))
	done
	ph_run_with_rollback -c true -m "${PH_ANSWER}"
	if [[ "${PH_ANSWER}" == n@(o|) ]]
	then
		ph_set_result -w -m "Quitting at user request"
		ph_show_result
		return "${?}"
	fi
	if [[ "${PH_RUN_USER}" != "root" ]]
	then
		printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking privilege elevation rights of user " "'${PH_RUN_USER}'"
		if [[ -n "${PH_SUDO}" ]]
		then
			ph_run_with_rollback -c true
		else
			ph_set_result -m "Run PieHelper as root or manually configure full sudo rights for user '${PH_RUN_USER}' as '/etc/sudoers.d/020_pieh-${PH_RUN_USER}' prior to installation"
			ph_run_with_rollback -c false -m "Not found" || \
				return 1
		fi
	fi
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the Linux distribution"
	for PH_i in "${PH_SUPPORTED_DISTROS[@]}"
	do
		if [[ "${PH_DISTRO}" == "${PH_i}" ]]
		then
			PH_DISTRO_FLAG="0"
			break
		fi
	done
	if [[ "${PH_DISTRO_FLAG}" -eq "0" ]]
	then
		PH_DISTROU="${PH_DISTRO}"
		ph_run_with_rollback -c true -m "${PH_DISTRO}"
		ph_update_pkg_index || \
			return 1
	else
		ph_set_result -m "Linux distro '${PH_DISTRO}' is currently not supported"
		ph_run_with_rollback -c false -m "${PH_DISTRO}" || \
			return 1
	fi
	ph_run_with_rollback -c "ph_create_empty_file -t file -d '${PH_TMP_DIR}/.configure_in_progress'" || \
		return 1
	ph_run_with_rollback -c "ph_install_pkg lsb-release" || \
		return 1
fi
PH_RUN_GROUP="$(id -gn "${PH_RUN_USER}" 2>/dev/null)"
if [[ "$(declare -p "PH_SUPPORTED_${PH_DISTROU}_RELS" 2>/dev/null)" == declare* ]]
then
	printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the release of Linux distro " "'${PH_DISTRO}'"
	if [[ ! -f "${PH_CONF_DIR}/distros/${PH_DISTRO_REL}.conf" ]]
	then
		ph_set_result -m "Release '${PH_DISTRO_REL}' of distribution '${PH_DISTRO}' is currently not supported"
		ph_run_with_rollback -c false -m "$PH_DISTRO_REL" || \
			return 1
	else
		ph_run_with_rollback -c true -m "${PH_DISTRO_REL}"
	fi
	if [[ ! -L "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" ]]
	then
		ph_run_with_rollback -c "ph_create_empty_file -t link -s '${PH_CONF_DIR}/distros/${PH_DISTRO_REL}.conf' -d '${PH_CONF_DIR}/distros/${PH_DISTRO}.conf'" || \
			return 1
	fi
	printf "%8s%s\n" "" "--> Loading release-dependent codebase"
	if source "${PH_CONF_DIR}/distros/${PH_DISTRO}.conf" 2>/dev/null
	then
		ph_run_with_rollback -c true
	else
		ph_set_result -m "An error occured trying to load codebase file '${PH_CONF_DIR}/distros/${PH_DISTRO}.conf'"
		ph_run_with_rollback -c false -m "Could not load" || \
			return 1
	fi
fi
printf "%8s%s\033[1;33m%s\033[0m\n" "" "--> Checking the parent directory of " "'PieHelper'"
if [[ "${PH_BASE_DIR}" == "${PH_INST_DIR}/PieHelper" ]]
then
	if "${PH_SUDO}" chmod -R 750 "${PH_BASE_DIR}" >/dev/null 2>&1
	then
		if "${PH_SUDO}" chown -R "${PH_RUN_USER}:${PH_RUN_GROUP}" "${PH_BASE_DIR}" >/dev/null 2>&1
		then
			ph_run_with_rollback -c true
			ph_run_with_rollback -c "ph_set_user_group_membership -u '${PH_RUN_USER}' -g 'tty,audio,video,input'" || \
				return 1
			if [[ "${PH_MODE}" == "normal" ]]
			then
				for PH_i in acl xboxdrv git make bluez bluez-tools expect less at ${PH_DISTRO_PKGS}
				do
					ph_run_with_rollback -c "ph_install_pkg '${PH_i}'" || \
						return 1
				done
			fi
			printf "%8s%s\033[1;33m%s\033[1;37m%s\033[0m\n" "" "--> Checking for the presence of " "'Emulationstation'" " (RetroPie)"
			if [[ -f /usr/bin/emulationstation ]]
			then
				ph_run_with_rollback -c true -m "Found"
				ph_run_with_rollback -c "ph_pieh_configured_emul_conf" || \
					return 1
			else
				ph_run_with_rollback -c true -m "Not found"
			fi
			for PH_i in sup defaults alloweds int os cont
			do
				ph_create_base_conf_file "${PH_i}" || \
					return 1
			done
			ph_run_with_rollback -c "ph_pieh_configured_path_conf" || \
				return 1
			ph_run_with_rollback -c "ph_support_app -a PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_create_app_items -a Controllers -t support" || \
				return 1
			ph_run_with_rollback -c "ph_blacklist_kernel_module xpad" || \
				return 1
			for PH_i in uinput joydev
			do
				ph_run_with_rollback -c "ph_load_kernel_module '${PH_i}'" || \
					return 1
			done
			ph_run_with_rollback -c "ph_pieh_configured_logind_conf" || \
				return 1
			for ((PH_COUNT=2;PH_COUNT<="${PH_PIEH_MAX_TTYS}";PH_COUNT++))
			do
				ph_run_with_rollback -c "ph_disable_services 'getty@tty${PH_COUNT}'" || \
					return 1
			done
			ph_run_with_rollback -c "ph_enable_services 'getty@tty1'" || \
				return 1
			ph_run_with_rollback -c "ph_integrate_app -a PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_set_app_for_start PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_set_bootenv multi-user.target" || \
				return 1
			ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.first_run'" || \
				return 1
			ph_run_with_rollback -c "ph_remove_empty_file -t file -d '${PH_TMP_DIR}/.configure_in_progress'" || \
				return 1
			if [[ "${PH_MODE}" == "normal" ]]
			then
				PH_ANSWER=""
				PH_COUNT="0"
				while [[ "${PH_ANSWER}" != @(y@(es|)|n@(o|)) ]]
				do
					[[ "${PH_COUNT}" -gt "0" ]] && \
						printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
					printf "%8s%s\033[1;37m%s\n\n" "" "--> Perform full system update before reboot " "(Recommended)"
					printf "%12s%s\n" "" "- System updates can take a long time depending on the system's current version and configuration"
					printf "%12s%s\033[0m\n\n" "" "- Please note that system updates are not reversible"
					printf "%12s%s\033[1;37m%s\033[0m%s" "" "Perform update " "(y/n)" " ? "
					read -r PH_ANSWER 2>/dev/null
					ph_screen_input "${PH_ANSWER}" || \
						return 1
					((PH_COUNT++))
				done
				ph_run_with_rollback -c true -m "${PH_ANSWER}"
				if [[ "${PH_ANSWER}" == y@(es|) ]]
				then
					ph_update_system || \
						return 1
				fi
				printf "%8s%s\n" "" "--> Displaying the user manual"
				sleep 2
				if less "${PH_BASE_DIR}/HOWTO" 2>/dev/null
				then
					ph_run_with_rollback -c true -m "${PH_SCRIPTS_DIR}/../HOWTO"
				else
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : Could not display"
					ph_set_result -r 0
				fi
				printf "\n\033[1;37m%s\033[0m\n" "Press Enter to reboot into the PieHelper menu"
				read -r 2>/dev/null
				"${PH_SUDO}" init 6
			fi
		else
			ph_set_result -m "Could not recursively set ownership of directory '${PH_BASE_DIR}' to '${PH_RUN_USER}:${PH_RUN_GROUP}'"
		fi
	else
		ph_set_result -m "Could not recursively set permissions for directory '${PH_BASE_DIR}' to '750'"
	fi
else
	ph_set_result -m "The directory that contains PieHelper should be called 'PieHelper' (Correct by running '${PH_SUDO} mv ${PH_BASE_DIR} ${PH_BASE_DIR%/*}/PieHelper')"
	ph_run_with_rollback -c false -m "Incorrect parent" || \
		return 1
fi
return 0
}

function ph_get_filename_from_shortname {

declare PH_FILE_SHORTNAME
declare PH_FILE

PH_FILE_SHORTNAME="${1}"
PH_FILE=""

[[ "${PH_FILE_SHORTNAME}" != @(cont|os|int|sup|@(default|allowed)s) || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "${PH_FILE_SHORTNAME}" in cont)
		PH_FILE="controller_cli_ids" ;;
			os)
		PH_FILE="OS.defaults" ;;
			int)
		PH_FILE="integrated_apps" ;;
			sup)
		PH_FILE="supported_apps" ;;
			defaults|alloweds)
		PH_FILE="options.${PH_FILE_SHORTNAME}" ;;
esac
echo -n "${PH_FILE}"
return 0
}

function ph_set_bootenv {

declare PH_ENV
declare PH_ENV_ACTION

PH_ENV="${1}"
PH_ENV_ACTION=""

[[ -z "${PH_ENV}" || "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if [[ "${PH_ENV}" == "multi-user.target" ]]
then 
	PH_ENV_ACTION="disable"
	printf "%8s%s\n" "" "--> Disabling the graphical environment"
else
	PH_ENV_ACTION="enable"
	printf "%8s%s\n" "" "--> Enabling the graphical environment"
fi
if "${PH_SUDO}" systemctl set-default "${PH_ENV}" >/dev/null 2>&1
then
	[[ "${PH_ENV}" == "graphical.target" ]] && \
		PH_ENV="multi-user.target" || \
		PH_ENV="graphical.target"
	ph_add_value_to_param -p PH_BOOTENV -v "${PH_ENV}"
	ph_run_with_rollback -c true && \
		return "${?}"
fi
ph_set_result -m "An error occured trying to ${PH_ENV_ACTION} the graphical environment"
ph_run_with_rollback -c false -m "Could not ${PH_ENV_ACTION}" || \
	return 1
}

function ph_do_app_routine {

declare PH_i
declare PH_APP
declare PH_APP_CMD
declare PH_APP_PKG
declare PH_APP_SCOPE
declare PH_APP_USER
declare PH_APP_STR_TTY
declare PH_APP_INST_STATE
declare PH_APP_STATE
declare PH_REQ_APP_STATE
declare PH_REQ_APP_STATE_PARAM
declare PH_DISP_APP_STATE
declare PH_ITEM
declare PH_ITEMS
declare PH_LIST
declare PH_FILE
declare PH_STRING
declare PH_CMD
declare PH_SKIPPING
declare PH_ROUTINE
declare PH_HEADER
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -i PH_COUNT
declare -i PH_TOT_LIST_MEMBERS
declare -i PH_SKIP_LIST_MEMBERS
declare -i PH_RET_CODE
declare -u PH_APPU

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_i=""
PH_APP=""
PH_APP_CMD=""
PH_APP_PKG=""
PH_APP_SCOPE=""
PH_APP_USER=""
PH_APP_STR_TTY=""
PH_APP_INST_STATE=""
PH_APP_STATE=""
PH_REQ_APP_STATE=""
PH_REQ_APP_STATE_PARAM=""
PH_DISP_APP_STATE=""
PH_ITEM=""
PH_ITEMS=""
PH_LIST=""
PH_FILE="integrated_apps"
PH_STRING=""
PH_CMD=""
PH_SKIPPING="no"
PH_ROUTINE=""
PH_HEADER=""
PH_OPTION=""
PH_COUNT="0"
PH_TOT_LIST_MEMBERS="0"
PH_SKIP_LIST_MEMBERS="0"
PH_RET_CODE="0"
PH_APPU=""

OPTIND="1"

while getopts :a:c:p:r:s:l:u:t: PH_OPTION
do
        case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP="${OPTARG}" ;;
			     c)
		[[ -n "${PH_APP_CMD}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_CMD="${OPTARG}" ;;
			     p)
		[[ -n "${PH_APP_PKG}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_PKG="${OPTARG}" ;;
			     r)
		[[ -n "${PH_ROUTINE}" || ( "${OPTARG}" != @(inst|uninst|sup|unsup|int|unint|conf|unconf|start|unstart|update|list|info|tty) && \
			"${OPTARG}" != @(mk|rm)_@(conf_file|defaults|alloweds|menus|scripts|cifs_mpt|all) ) ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_ROUTINE="${OPTARG}" ;;
			     s) 
		[[ -n "${PH_APP_SCOPE}" || "${OPTARG}" != @(oos|def|inst|uninst|pkg|unpkg|PI|PU|UI|UU) ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_SCOPE="${OPTARG}" ;;
			     l)
		[[ -n "${PH_LIST}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		for PH_i in ${OPTARG//,/ }
		do
			if [[ "${PH_i}" != @(def|sup|int|hal|run|str|all) ]]
			then
				OPTARG="${PH_OLDOPTARG}"
				OPTIND="${PH_OLDOPTIND}"
				exit 1
			fi
		done
                PH_LIST="${OPTARG}" ;;
			     u)
		[[ -n "${PH_APP_USER}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_USER="${OPTARG}" ;;
			     t)
		[[ -n "${PH_APP_STR_TTY}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
                PH_APP_STR_TTY="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
        esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_ROUTINE}" || ( -z "${PH_APP}" && -z "${PH_LIST}" ) || "${#}" -gt "14" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

declare -a PH_ROUTINE_OPTS
for PH_i in CMD PKG USER STR_TTY
do
	declare -n PH_PARAM
	PH_PARAM="PH_APP_${PH_i}"
	if [[ -n "${PH_PARAM}" ]]
	then
		case "${PH_PARAM}" in none)
			PH_PARAM="" ;;
				auto)
			unset -n PH_PARAM
			continue ;;
				prompt)
			PH_COUNT="0"
			case "${PH_i}" in CMD)
				PH_ITEM="valid start command" ;;
					  PKG)
				PH_ITEM="valid package" ;;
					  USER)
				PH_ITEM="valid user account" ;;
					  STR_TTY)
				PH_ITEM="tty" ;;
					  *)
				: ;;
			esac
			PH_PARAM=""
			while [[ -z "${PH_PARAM}" || ( "${PH_i}" == "PKG" && "$(ph_check_pkg_validity "${PH_PARAM}"; echo "${?}")" -ne "0" ) || \
				( "${PH_i}" == "USER" && "$(ph_check_user_validity "${PH_PARAM}"; echo "${?}")" -ne "0" ) ]]
			do
				[[ "${PH_COUNT}" -gt "0" ]] && \
					printf "\n%10s\033[33m%s\033[0m\n" "" "Warning : Invalid response"
				printf "%8s%s\033[1;33m%s\033[37m%s\033[0m%s" "" "--> Please enter a ${PH_ITEM} for " "'${PH_APP}'" " ('s' to skip) " ": "
				read -r "PH_PARAM" 2>/dev/null
				[[ ( "${PH_i}" == "PKG" && -z "${PH_PARAM}" ) || "${PH_PARAM}" == "s" ]] && \
					break
				((PH_COUNT++))
			done
			if [[ -z "${PH_PARAM}" ]]
			then
				ph_run_with_rollback -c true -m "None"
			else
				if [[ "${PH_PARAM}" == "s" ]]
				then
					unset -n PARAM
					unset PH_ROUTINE_OPTS
					printf "%10s\033[33m%s\033[0m\n" "" "Warning : Skipping at user request"
					ph_set_result -r 0
					return 0
				else
					ph_run_with_rollback -c true -m "${PH_PARAM}"
				fi
			fi ;;
				*)
			: ;;
		esac
		if [[ "${PH_i}" == "STR_TTY" ]]
		then
			PH_ROUTINE_OPTS+=("-t" "'${PH_PARAM}'")
		else
			PH_ROUTINE_OPTS+=("-$(cut -c1<<<"${PH_i}" | tr '[:upper:]' '[:lower:]')" "'${PH_PARAM}'")
		fi
	fi
	unset -n PH_PARAM
done
if [[ -n "${PH_LIST}" ]]
then
	for PH_i in ${PH_LIST//,/ }
	do
		PH_CMD="ph_do_app_routine -r '${PH_ROUTINE}' -l '${PH_i}' -s '${PH_APP_SCOPE}' ${PH_ROUTINE_OPTS[*]}"
	done
fi
if [[ -n "${PH_APP}" ]]
then
	PH_LIST="${PH_APP}"
	PH_APP_STATE="$(ph_get_app_state_from_app_name "${PH_APP}")"
	case "${PH_ROUTINE}" in list)
		PH_APP_INST_STATE="$(ph_get_app_inst_state_from_app_name "${PH_APP}")"
		PH_CMD="printf \"%4s\\033\[1\;37m%s\\033\[1\;33m%s\\033\[0m\\n\" \"\" \"${PH_APP} : \" \"${PH_APP_INST_STATE}\"" ;;
			tty)
		PH_APP_STR_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
		if [[ "${PH_APP_STR_TTY}" == @(-|1) ]]
		then
			PH_CMD="printf \"%4s\\033\[1\;37m%s\\033\[1\;33m%s\\033\[0m\\n\" \"\" \"${PH_APP} : \" \"None\""
		else
			PH_CMD="printf \"%4s\\033\[1\;37m%s\\033\[1\;33m%s\\033\[0m\\n\" \"\" \"${PH_APP} : \" \"tty${PH_APP_STR_TTY}\""
		fi ;;
			info)
		PH_CMD="ph_show_app_info '${PH_APP}'" ;;
			sup)
		PH_CMD="ph_support_app -a '${PH_APP}' ${PH_APP_CMD} ${PH_APP_PKG} ${PH_APP_USER}" ;;
			unsup)
		PH_CMD="ph_unsupport_app -a '${PH_APP}'" ;;
			int)
		PH_CMD="ph_integrate_app -a '${PH_APP}'" ;;
			unint)
		PH_CMD="ph_unintegrate_app -a '${PH_APP}'" ;;
			inst)
		PH_CMD="ph_install_app -a '${PH_APP}' ${PH_APP_PKG}" ;;
			uninst)
		PH_CMD="ph_uninstall_app -a '${PH_APP}'" ;;
			update)
		PH_CMD="ph_update_app -a '${PH_APP}'" ;;
			conf)
		PH_CMD="ph_configure_app -a '${PH_APP}'" ;;
			unconf)
		PH_CMD="ph_unconfigure_app -a '${PH_APP}'" ;;
			move)
		PH_CMD="ph_move_app -a '${PH_APP}' ${PH_APP_STR_TTY}" ;;
			start)
		PH_CMD="ph_set_app_for_start '${PH_APP}'" ;;
			unstart)
		PH_CMD="ph_set_app_for_start 'none'" ;;
			mk_conf)
		PH_CMD="ph_create_app_conf_file '${PH_APP}'" ;;
			mk_defaults)
		PH_CMD="ph_create_app_defaults '${PH_APP}'" ;;
			mk_alloweds)
		PH_CMD="ph_create_app_alloweds '${PH_APP}'" ;;
			mk_menus)
		PH_CMD="ph_create_app_menus '${PH_APP}'" ;;
			mk_scripts)
		PH_CMD="ph_create_app_scripts '${PH_APP}'" ;;
			mk_cifs_mpt)
		PH_CMD="ph_create_app_cifs_mpt '${PH_APP}'" ;;
			mk_all)
		if [[ "${PH_APP_STATE}" == @(Integra|Hal)ted ]]
		then
			PH_ITEMS="conf_file,alloweds,defaults,menus,scripts,cifs_mpt"
		else
			PH_ITEMS="conf_file,alloweds,defaults,menus"
		fi ;;
			rm_conf)
		PH_CMD="ph_remove_app_conf_file '${PH_APP}'" ;;
			rm_defaults)
		PH_CMD="ph_remove_app_defaults '${PH_APP}'" ;;
			rm_alloweds)
		PH_CMD="ph_remove_app_alloweds '${PH_APP}'" ;;
			rm_menus)
		PH_CMD="ph_remove_app_menus '${PH_APP}'" ;;
			rm_scripts)
		PH_CMD="ph_remove_app_scripts '${PH_APP}'" ;;
			rm_cifs_mpt)
		PH_CMD="ph_remove_app_cifs_mpt '${PH_APP}'" ;;
			rm_all)
		if [[ "${PH_APP_STATE}" == @(Integra|Hal)ted ]]
		then
			PH_ITEMS="cifs_mpt,scripts,menus,defaults,alloweds,conf_file"
		else
			PH_ITEMS="menus,defaults,alloweds,conf_file"
		fi ;;
			*)
		: ;;
	esac
	if [[ -n "${PH_ITEMS}" ]]
	then
		for PH_i in ${PH_ITEMS//,/ }
		do
			confapps_ph.sh -r "${PH_ROUTINE:0:3}${PH_i}" -a "${PH_APP}"
		done
		unset PH_ROUTINE_DEPTH PH_ROUTINE_FLAG PH_SKIP_DEPTH_MEMBERS
		exit 0
	fi
fi
case "${PH_LIST}" in oos)
	PH_DISP_APP_STATE="Out-of-scope"
	PH_FILE="/dev/null" ;;
		def)
	PH_DISP_APP_STATE="Default"
	PH_FILE="default_apps${PH_FILE_SUFFIX}" ;;
		sup)
	PH_DISP_APP_STATE="Supported"
	PH_FILE="supported_apps" ;;
		int)
	PH_DISP_APP_STATE="Integrated" ;;
		hal)
	PH_DISP_APP_STATE="Halted" ;;
		run)
	PH_DISP_APP_STATE="Running" ;;
		str)
	PH_DISP_APP_STATE="StartApp" ;;
		all)
	PH_DISP_APP_STATE="Unused"
	PH_FILE="/dev/null" ;;
		*)
	: ;;
esac
case "${PH_ROUTINE}" in list)
	if [[ "${PH_LIST}" == "str" ]]
	then
		PH_REQ_APP_STATE="Halted"
	else
		PH_REQ_APP_STATE="${PH_DISP_APP_STATE}"
	fi ;;
		tty)
	PH_REQ_APP_STATE="Halted" ;;
		info)
	PH_REQ_APP_STATE="Supported" ;;
		sup)
	PH_REQ_APP_STATE="Unused" ;;
		unsup)
	PH_REQ_APP_STATE="Supported" ;;
		int)
	PH_REQ_APP_STATE="Supported" ;;
		unint)
	PH_REQ_APP_STATE="Integrated" ;;
		inst)
	PH_REQ_APP_INST_STATE='*U' ;;
		uninst)
	PH_REQ_APP_INST_STATE='*I' ;;
		update)
	PH_REQ_APP_STATE="Supported" ;;
		conf)
	PH_REQ_APP_STATE="Supported" ;;
		unconf)
	PH_REQ_APP_STATE="Supported" ;;
		move)
	PH_REQ_APP_STATE="Halted" ;;
		start)
	PH_REQ_APP_STATE="Supported" ;;
		unstart)
	PH_REQ_APP_STATE="Halted" ;;
		mk_conf|mk_defaults|mk_alloweds|mk_menus)
	PH_REQ_APP_STATE="Unused" ;;
		mk_scripts|mk_cifs_mpt)
	PH_REQ_APP_STATE="Supported" ;;
		rm_conf|rm_defaults|rm_alloweds|rm_menus)
	PH_REQ_APP_STATE="Supported" ;;
		rm_scripts|rm_cifs_mpt)
	PH_REQ_APP_STATE="Integrated" ;;
esac
case "${PH_REQ_APP_STATE}" in Out-of-scope)
	PH_REQ_APP_STATE_PARAM="-o" ;;
		Default)
	PH_REQ_APP_STATE_PARAM="-d" ;;
		Supported)
	PH_REQ_APP_STATE_PARAM="-s" ;;
		Integrated)
	PH_REQ_APP_STATE_PARAM="-i" ;;
		Halted)
	PH_REQ_APP_STATE_PARAM="-h" ;;
		Running)
	PH_REQ_APP_STATE_PARAM="-r" ;;
		StartApp)
	PH_REQ_APP_STATE_PARAM="-h" ;;
		Unused)
	PH_REQ_APP_STATE_PARAM="-u" ;;
esac
[[ "${PH_LIST}" == "start" ]] && \
	PH_LIST="${PH_PIEH_STARTAPP}"
if [[ -z "$PH_APP" && -z "$PH_LIST" ]]
then
	case "$PH_KEYWORD" in hal)
		for PH_i in $(ph_get_app_list_by_state -s Halted -t exact)
		do
			[[ -z "$PH_LIST" ]] && \
				PH_LIST="$PH_i" || \
				PH_LIST="${PH_LIST},${PH_i}"
		done ;;
			      run)
		for PH_i in $(ph_get_app_list_by_state -s Running -t exact)
		do
			[[ -z "$PH_LIST" ]] && \
				PH_LIST="$PH_i" || \
				PH_LIST="${PH_LIST},${PH_i}"
		done ;;
	esac
	if [[ -z "$PH_LIST" ]]
	then
		PH_LIST="$(nawk 'BEGIN { \
				ORS = "," \
			} { \
				print $1 \
			}' "${PH_CONF_DIR}/${PH_FILE}" 2>/dev/null)"
	fi
fi
if [[ -z "$PH_CMD" ]]
then
	PH_CMD="ph_do_app_routine -a '\${PH_i}' -p '${PH_ACTION}' -k '${PH_KEYWORD}' -s '${PH_APP_SCOPE}' -o '${PH_ROUTINE_OPTS}'"
fi
PH_TOT_LIST_MEMBERS="$(echo ${PH_LIST//,/ } | nawk '{ \
		printf NF \
	}')"
for PH_i in ${PH_LIST//,/ }
do
	PH_HEADER=""
	PH_ROUTINE_FLAG="1"
	PH_SKIPPING="no"
	PH_STRING="'$PH_APP'"
	if [[ "$PH_ACTION" == @(list|tty) ]]
	then
		if [[ -n "$PH_APP" && "$PH_ROUTINE_DEPTH" -eq "0" ]]
		then
			PH_HEADER="-"
		else
			if [[ -z "$PH_APP" && -n "$PH_KEYWORD" && "$PH_COUNT" -eq "0" ]]
			then
				PH_HEADER="-"
				PH_STRING="'${PH_DISP_APP_STATE}' applications"
			fi
		fi
	else
		[[ -n "$PH_APP" ]] && \
			PH_HEADER="-"
	fi
	if [[ -n "$PH_HEADER" ]]
	then
		case "${PH_ACTION:3}" in conf)
				PH_ITEMS="configuration file" ;;
				    menus)
				PH_ITEMS="menu items" ;;
				    scripts)
				PH_ITEMS="management scripts" ;;
				    dir)
				PH_ITEMS="default CIFS mountpoint" ;;
				    defaults|alloweds)
				PH_ITEMS="${PH_ACTION:3:7} option values" ;;
		esac
		case "$PH_ACTION" in list)
			PH_HEADER="${PH_HEADER} Listing ${PH_STRING}" ;;
				     tty)
			PH_HEADER="${PH_HEADER} Displaying ${PH_STRING} tty" ;;
				     info)
			PH_HEADER="${PH_HEADER} Displaying ${PH_STRING} info" ;;
				     sup)
			PH_HEADER="${PH_HEADER} Supporting ${PH_STRING}" ;;
				     unsup)
			PH_HEADER="${PH_HEADER} Unsupporting ${PH_STRING}" ;;
				     int)
			PH_HEADER="${PH_HEADER} Integrating ${PH_STRING}" ;;
				     unint)
			PH_HEADER="${PH_HEADER} Unintegrating ${PH_STRING}" ;;
				     inst)
			PH_HEADER="${PH_HEADER} Installing ${PH_STRING}" ;;
				     uninst)
			PH_HEADER="${PH_HEADER} Uninstalling ${PH_STRING}" ;;
				     update)
			PH_HEADER="${PH_HEADER} Updating ${PH_STRING}" ;;
				     conf)
			PH_HEADER="${PH_HEADER} Configuring ${PH_STRING}"
			[[ "$PH_APP" == "PieHelper" ]] && \
				PH_HEADER="${PH_HEADER} version '${PH_VERSION}'" ;;
				     move)
			PH_HEADER="${PH_HEADER} Moving ${PH_STRING}" ;;
				     start)
			PH_HEADER="${PH_HEADER} Setting StartApp ${PH_STRING}" ;;
				     mk_*)
			PH_HEADER="${PH_HEADER} Creating ${PH_ITEMS} for ${PH_STRING}" ;;
				     rm_*)
			PH_HEADER="${PH_HEADER} Removing ${PH_ITEMS} for ${PH_STRING}" ;;
		esac
		[[ "$PH_APP_SCOPE" != "all" ]] && \
			PH_HEADER="${PH_HEADER} (Filtering on '${PH_APP_SCOPE}' apps)"
		[[ "$PH_ACTION" == @(mk_|rm_)* ]] && \
			printf "\n"
	fi
	if [[ -n "$PH_HEADER" ]]
	then
		printf "\033[36m%s\033[0m\n" "$PH_HEADER"
		[[ "$PH_ACTION" != @(list|tty) ]] && \
			printf "\n"
	fi
	if [[ -n "$PH_APP" ]]
	then
		if [[ ! ( "$PH_i" == "Controllers" && ! ( "$PH_ACTION" == "start" && "$PH_i" == "prompt" ) && \
			! ( "$PH_ACTION" == "list" && "$PH_KEYWORD" == "start" && "$PH_i" == "none" )) ]]
		then
			if [[ "$PH_APP_SCOPE" == "Out-of-scope" ]]
			then
				if ph_check_app_state_validity -a "$PH_i" -q -d
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} is not an out-of-scope application -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			if [[ "$PH_APP_SCOPE" == "Default" ]]
			then
				if ! ph_check_app_state_validity -a "$PH_i" -q -d
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} not a default application -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			if ! ph_check_app_state_validity -a "$PH_i" -q ${PH_REQ_APP_STATE_PARAM}
			then
				if [[ "$PH_ACTION" != mk_* && ! ( "$PH_i" == "PieHelper" && "$PH_ACTION" == "conf" ) ]] 
				then
					printf "\n"
					printf "%4s\033[33m%s\033[0m\n" "" "${PH_i} is not '${PH_REQ_APP_STATE}' -> Skipping"
					[[ "$PH_ACTION" != @(list|tty) ]] && \
						PH_ROUTINE_FLAG="0"
					((PH_SKIP_LIST_MEMBERS++))
					continue
				fi
			fi
			PH_APP_STATE="$(ph_get_app_state_from_app_name "$PH_i")"
			case "$PH_ACTION" in conf|move|mk_*|rm_*)
						[[ "$PH_APP_STATE" == "Running" && "$PH_ACTION" != "move" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == @(move|mk_menus|rm_menus) ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
					     unsup|int)
						[[ "$PH_APP_STATE" != "$PH_REQ_APP_STATE" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == "unsup" ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
					     unint|update)
						[[ "$PH_APP_STATE" == "Running" ]] && \
							PH_SKIPPING="yes"
						[[ "$PH_i" == "PieHelper" && "$PH_ACTION" == "unint" ]] && \
							PH_SKIPPING="yes" && \
							PH_APP_STATE="PieHelper" ;;
			esac
			PH_APPU="${PH_i:0:4}"
			[[ "$PH_ACTION" == @(mk|rm)_dir && "$(eval "echo -n \"\$PH_${PH_APPU}_CIFS_MPT\"")" == "\${PH_MNT_DIR}/${PH_APP}" ]] && \
				PH_SKIPPING="yes" && \
				PH_APP_STATE="Customized mountpoint"
			if [[ "$PH_SKIPPING" == "yes" ]]
			then
				printf "\n"
				printf "%4s\033[33m%s\033[0m\n" "" "${PH_APP_STATE} -> Skipping"
				[[ "$PH_ACTION" != @(list|tty) ]] && \
					PH_ROUTINE_FLAG="0"
				((PH_SKIP_LIST_MEMBERS++))
				continue
			fi
		fi
	fi
	((PH_COUNT++))
	if [[ "$PH_SKIP_DEPTH_MEMBERS" -ge "1" && -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		printf "\n"
	fi
	[[ "$PH_CMD" == ph_do_app_routine* ]] && \
		((PH_ROUTINE_DEPTH++))
	if [[ "$PH_ACTION" == @(list|tty) && "$PH_COUNT" -eq "1" ]]
	then
		if [[ ( "$PH_CMD" == printf* && "$PH_ROUTINE_DEPTH" -eq "0" ) || -z "$PH_APP" ]]
		then
			printf "\n"
		fi
	fi
	eval "$PH_CMD"
	PH_RET_CODE="$?"
	[[ "$PH_CMD" == printf* ]] && \
		ph_set_result -r "$PH_RET_CODE"
done
if [[ "$PH_ACTION" == @(list|tty) ]]
then
	if [[ -n "$PH_APP" && -n "$PH_KEYWORD" ]]
	then
		PH_SKIP_DEPTH_MEMBERS="$((PH_SKIP_DEPTH_MEMBERS+"${PH_SKIP_LIST_MEMBERS}"))"
		[[ "$PH_TOT_LIST_MEMBERS" -eq "$PH_SKIP_LIST_MEMBERS" ]] && \
			PH_ROUTINE_FLAG="0"
	else
		[[ "$PH_TOT_LIST_MEMBERS" -eq "$PH_SKIP_DEPTH_MEMBERS" ]] && \
			PH_ROUTINE_FLAG="0"
	fi
	if [[ -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		if [[ "$PH_ROUTINE_FLAG" -eq "0" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
		ph_set_result -t -r "$?"
	fi
	if [[ -n "$PH_KEYWORD" && -n "$PH_APP" && "$PH_ROUTINE_DEPTH" -eq "0" ]]
	then
		if [[ "$PH_SKIP_LIST_MEMBERS" -eq "1" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
	fi
	if [[ -z "$PH_KEYWORD" ]]
	then
		if [[ "$PH_COUNT" -gt "1" ]]
		then
			ph_show_result -t
		fi
	fi
else
	if [[ -z "$PH_KEYWORD" ]]
	then
		PH_TOT_LIST_MEMBERS="$PH_ROUTINE_FLAG"
	fi
	if [[ -n "$PH_KEYWORD" && -z "$PH_APP" ]]
	then
		[[ "$PH_ROUTINE_DEPTH" -ne "0" ]] && \
			PH_ROUTINE_FLAG="$((PH_ROUTINE_FLAG+"${PH_TOT_LIST_MEMBERS}"))"
	fi
	if [[ -n "$PH_KEYWORD" && -n "$PH_APP" ]]
	then
		if [[ "$PH_COUNT" -eq "0" ]]
		then
			ph_set_result -r 0 -m "No applications matched" -w
		fi
		ph_show_result
		if [[ "$?" -eq "0" ]]
		then
			[[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]] && \
				ph_set_result -t -r 0
		else
			[[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]] && \
				ph_set_result -t -r 1
		fi
	fi
	if [[ "$("$PH_SUDO" cat "/proc/${PPID}/comm" 2>/dev/null)" != "confapps_ph.sh" ]]
	then
		[[ "$PH_ROUTINE_DEPTH" -eq "0" && "$PH_TOT_LIST_MEMBERS" -gt "1" ]] && \
			ph_show_result -t
	fi
fi
[[ -z "$PH_APP" ]] && \
	PH_SKIP_DEPTH_MEMBERS="0"
if [[ "$PH_ROUTINE_DEPTH" -ne "0" ]]
then
	((PH_ROUTINE_DEPTH--))
else
	unset PH_ROUTINE_DEPTH PH_ROUTINE_FLAG PH_SKIP_DEPTH_MEMBERS
fi
return "$PH_RET_CODE"
}

function ph_resolve_dynamic_value {

declare PH_OPT_VALUE

PH_OPT_VALUE="${1}"

[[ "${#}" -ne "1" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

if echo "${PH_OPT_VALUE}" | grep '$' >/dev/null 2>&1
then
	eval "echo -n \"${PH_OPT_VALUE}\""
else
	echo -n "${PH_OPT_VALUE}"
fi
return 0
}

function ph_run_app_addon {

declare PH_APP
declare PH_APP_ADDON
declare PH_APP_ADDON_SHORTNAME
declare PH_APP_ADDON_DISPNAME
declare PH_OPTION
declare PH_OLDOPTARG
declare -i PH_OLDOPTIND
declare -u PH_APPU
declare -u PH_APP_ADDON_SHORTNAMEU

PH_OLDOPTARG="${OPTARG}"
PH_OLDOPTIND="${OPTIND}"
PH_APP=""
PH_APP_ADDON=""
PH_APP_ADDON_SHORTNAME=""
PH_APP_ADDON_DISPNAME=""
PH_OPTION=""
PH_APPU=""
PH_APP_ADDON_SHORTNAMEU=""

OPTIND="1"

while getopts :a:d: PH_OPTION
do
	case "${PH_OPTION}" in a)
		[[ -n "${PH_APP}" || -z "${OPTARG}" ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP="${OPTARG}"
		PH_APPU="${PH_APP:0:4}" ;;
			     d)
		[[ -n "${PH_APP_ADDON}" || "${OPTARG}" != @(pre|post)_cmd ]] && \
			OPTIND="${PH_OLDOPTIND}" && \
			OPTARG="${PH_OLDOPTARG}" && \
			return 1
		PH_APP_ADDON="${OPTARG}" ;;
			     *)
		OPTIND="${PH_OLDOPTIND}"
		OPTARG="${PH_OLDOPTARG}"
		ph_set_result -a -m "Invalid option '${OPTARG}' passed to function '${FUNCNAME[0]}'" ;;
	esac
done
OPTIND="${PH_OLDOPTIND}"
OPTARG="${PH_OLDOPTARG}"

[[ -z "${PH_APP}" || -z "${PH_APP_ADDON}" || "${#}" -ne "4" ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "${PH_APP_ADDON}" in pre_cmd|post_cmd)
	PH_APP_ADDON_SHORTNAME="$(cut -d'_' -f1<<<"${PH_APP_ADDON}")"
	PH_APP_ADDON_SHORTNAMEU="${PH_APP_ADDON_SHORTNAME}"
	PH_APP_ADDON_DISPNAME="${PH_APP_ADDON_SHORTNAMEU}-command"
	declare -n PH_APP_ADDON_VAR
	PH_APP_ADDON_VAR="PH_${PH_APPU}_${PH_APP_ADDON_SHORTNAMEU}_CMD"
	PH_APP_ADDON_VAR="$(ph_resolve_dynamic_value "${PH_APP_ADDON_VAR}")"
	printf "%8s%s\n" "" "--> Checking for ${PH_APP_ADDON_DISPNAME} configuration"
	if [[ -n "${PH_APP_ADDON_VAR}" ]]
	then
		ph_run_with_rollback -c true -m "Found"
		printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Checking ${PH_APP_ADDON_DISPNAME} " "'$(echo "${PH_APP_ADDON_VAR}" | nawk '{ \
				printf $1 ; \
				exit 0 \
			}')'" " for " "'${PH_APP}'"
		if [[ -f "$(echo "${PH_APP_ADDON_VAR}" | nawk '{ \
				printf $1 ; \
				exit 0 \
			}')" ]]
		then
			"$(command -v file 2>/dev/null)" -b "$(echo "${PH_APP_ADDON_VAR}" | nawk '{ \
					printf $1 ; \
					exit 0 \
				}')" 2>/dev/null | nawk 'BEGIN { \
						rc = 0 \
					} \
					$0 ~ /ASCII text executable/ { \
						exit 1 \
					}
					$0 ~ /ASCII text/ { \
						exit 2 \
					}
					$0 ~ /32-bit.*(executable|shared object)/ { \
						exit 3 \
					}
					$0 ~ /64-bit.*(executable|shared object)/ { \
						exit 4 \
					}
					$0 ~ /directory/ { \
						exit 5 \
					} { \
						exit 6 \
					}'
			case "${?}" in 1|3|4)
				ph_run_with_rollback -c true -m "Found"
				eval "${PH_APP_ADDON_VAR}" 2>/dev/null ;;
				       2)
				ph_run_with_rollback -c true -m "Found"
				eval source "${PH_APP_ADDON_VAR}" 2>/dev/null ;;
				       5|6)
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Invalid ${PH_APP_ADDON_DISPNAME} '${PH_APP_ADDON_VAR}' -> Skipping"
				ph_set_result -r 0 ;;
			esac
		else
			printf "%10s\033[33m%s\033[0m\n" "" "Warning : ${PH_APP_ADDON_DISPNAME} '${PH_APP_ADDON_VAR}' not found -> Skipping"
			ph_set_result -r 0
		fi
	else
		ph_run_with_rollback -c true -m "Not Found"
	fi
	unset -n PH_APP_ADDON_VAR ;;
			  *)
	: ;;
esac
return 0
}

function ph_do_app_action {

declare PH_i
declare PH_APP
declare PH_APP_USER
declare PH_APP_CMD
declare PH_ACTION
declare PH_MOON_PATH
declare PH_APPU_CMD_OPTS
declare PH_APPU_NUM_CTRL
declare PH_APPU_USE_CTRL
declare PH_APPU_CIFS_SHARE
declare PH_APPU_PERSISTENT
declare PH_STOP_MODE
declare -i PH_APP_TTY
declare -i PH_PIEH_TTY
declare -i PH_FG_CONSOLE
declare -i PH_CTRL_COUNT
declare -l PH_APPL
declare -u PH_APPU

PH_i=""
PH_APP="${2}"
PH_APP_USER="$(ph_get_app_user_from_app_name "${PH_APP}")"
PH_APP_CMD="$(ph_get_app_cmd_from_app_name "${PH_APP}")"
PH_ACTION="${1}"
PH_MOON_PATH="$(nawk '$1 ~ /^Moonlight$/ { \
		printf $3 \
	}' "${PH_CONF_DIR}/supported_apps" 2>/dev/null)"
PH_APP_TTY="$(ph_get_app_tty_from_app_name "${PH_APP}")"
PH_PIEH_TTY="$(ph_get_app_tty_from_app_name PieHelper)"
PH_FG_CONSOLE="$("${PH_SUDO}" fgconsole 2>/dev/null)"
PH_CTRL_COUNT="0"
PH_APPL="${PH_APP:0:4}"
PH_APPU="${PH_APP:0:4}"
PH_APPU_CMD_OPTS="$(eval "echo -n \"\$PH_${PH_APPU}_CMD_OPTS\"")"
PH_APPU_NUM_CTRL="$(eval "echo -n \"\$PH_${PH_APPU}_NUM_CTRL\"")"
PH_APPU_USE_CTRL="$(eval "echo -n \"\$PH_${PH_APPU}_USE_CTRL\"")"
PH_APPU_CIFS_SHARE="$(eval "echo -n \"\$PH_${PH_APPU}_CIFS_SHARE\"")"
PH_APPU_PERSISTENT="$(eval "echo -n \"\$PH_${PH_APPU}_PERSISTENT\"")"
PH_STOP_MODE="${3}"

[[ ( "${#}" -ne "2" && "${PH_ACTION}" == "start") || ( "${PH_ACTION}" == "stop" && \
	( "${#}" -ne 3 || "${PH_STOP_MODE}" != @(normal|forced) )) || "${PH_ACTION}" != st@(art|op) ]] && \
	ph_set_result -a -m "Incorrect arguments provided to function '${FUNCNAME[0]}'"

case "${PH_ACTION}" in start)
	if [[ "${PH_FG_CONSOLE}" -eq "${PH_APP_TTY}" ]]
	then
		printf "%8s%s\n" "" "--> Checking for application-specific prerequisite configurations"
		case "${PH_APP}" in Moonlight)
			ph_run_with_rollback -c true -m "Found > Moonlight requires option 'PH_MOON_SRV' correctly set"
			printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Validating the configuration prerequisite of " "'${PH_APP}'"
			if ! "${PH_SUDO}" -u "${PH_APP_USER}" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} list ${PH_MOON_SRV} 2>/dev/null" >/dev/null 2>&1
			then
				ph_set_result -m "Could not start '${PH_APP}' since option 'PH_MOON_SRV' is not set to a valid NVIDIA SHIELD server"
				ph_run_with_rollback -c false -m "Could not ${PH_ACTION}" || \
					return 1
			else
				ph_run_with_rollback -c true
			fi ;;
				    *) 
			ph_run_with_rollback -c true -m "Not Found" ;;
		esac
		printf "%8s%s\n" "" "--> Checking for CIFS mount configuration"
		if [[ "${PH_APPU_CIFS_SHARE}" == "no" ]]
		then
			ph_run_with_rollback -c true -m "Not Found"
		else
			ph_run_with_rollback -c true -m "Found"
			ph_run_with_rollback -c "ph_mount_cifs_share '${PH_APP}'" || \
				return 1
		fi
		ph_run_app_addon -a "${PH_APP}" -d "pre_cmd"
		printf "%8s%s\n" "" "--> Checking for controller usage"
		if [[ "${PH_APPU_USE_CTRL}" == "no" ]]
		then
			ph_run_with_rollback -c true -m "No"
		else
			ph_run_with_rollback -c true -m "Yes"
			if ph_setup_controllers "${PH_APPU_NUM_CTRL}"
			then
				PH_CTRL_COUNT="$(cat "${PH_CONF_DIR}/controller_cli_ids" 2>/dev/null | wc -l)"
				printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Determining the controller IDs' provisioning method for " "'${PH_APP}'"
				if echo "${PH_APPU_CMD_OPTS}" | grep -E "PH_CTRL[1-${PH_APPU_NUM_CTRL}]$|PH_CTRL[1-${PH_APPU_NUM_CTRL}] " >/dev/null
				then
					ph_run_with_rollback -c true -m "Command arguments"
					for ((PH_i=1;PH_i<="${PH_APPU_NUM_CTRL}";PH_i++))
					do
						printf "%8s%s\n" "" "--> Determining the event-based device ID corresponding to ${PH_CONT_TYPE} controller ID ${PH_i}"
						if [[ "${PH_CONT_MAP}" == "no" ]]
						then
							eval declare -i "PH_EVENT${PH_i}=\"$(ph_get_controller_cli_id "${PH_i}")\""
						else
							eval declare -i "PH_EVENT${PH_i}=\"$(ph_get_controller_cli_id "$((PH_i+"$((PH_CTRL_COUNT-"${PH_APPU_NUM_CTRL}"))"))")\""
						fi
						declare -n PH_EVENT="PH_EVENT${PH_i}"
						ph_run_with_rollback -c -m "Event ID ${PH_EVENT}"
						printf "%8s%s\n" "" "--> Mapping event id ${PH_EVENT} to ${PH_CONT_TYPE} controller ID ${PH_i}"
						PH_APPU_CMD_OPTS="$(sed "s/PH_CTRL${PH_i}/${PH_EVENT}/g;s/\"/\\\"/g"<<<"${PH_APPU_CMD_OPTS}")"
						ph_run_with_rollback -c true
						unset "PH_EVENT${PH_i}"
						unset -n PH_EVENT
					done
				else
					ph_run_with_rollback -c true -m "Direct Access"
				fi
			else
				return 1
			fi
		fi
		if [[ "${PH_APP}" != "PieHelper" ]]
		then
			ph_run_with_rollback -c "ph_umount_cifs_share PieHelper" || \
				return 1
			ph_run_with_rollback -c "ph_stop_services 'getty@tty${PH_PIEH_TTY}'" || \
				return 1
		else
			PH_APP_CMD="ph_show_menu"
		fi
		printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Starting " "'${PH_APP}'"
		if [[ "${PH_APP_CMD}" != "/bin/bash" ]]
		then
			if [[ "${PH_APP_USER}" != "$(whoami 2>/dev/null)" ]]
			then
				"${PH_SUDO}" -u "${PH_APP_USER}" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib eval '${PH_APP_CMD}' '$(ph_resolve_dynamic_value "${PH_APPU_CMD_OPTS}")'"
			else
				if [[ "${PH_APP}" == "PieHelper" ]]
				then
					shopt -s extdebug
				fi
				eval "${PH_APP_CMD}" "$(ph_resolve_dynamic_value "${PH_APPU_CMD_OPTS}")"
			fi
		else
			true
		fi
		if [[ "${?}" -ne "0" ]]
		then
			ph_set_result -m "An error occurred trying to ${PH_ACTION} '${PH_APP}'"
			ph_run_with_rollback -c false -m "Could not ${PH_ACTION}" || \
				return 1
		else
			ph_add_value_to_param -p PH_APPS_ACTION -v "${PH_APP}'stop'forced"
		fi
		[[ "${PH_APP}" == "PieHelper" ]] && \
			return 0
		ph_run_with_rollback -c true
		if [[ "${PH_APP}" == "Bash" ]]
		then
			ph_show_result
			sleep 2
			"${PH_SUDO}" rm "${PH_TMP_DIR}/Start.report" 2>/dev/null
			clear
		fi
	else
		if systemctl is-active "getty@tty${PH_APP_TTY}" >/dev/null 2>&1
		then
			[[ "${PH_APP}" == "Bash" ]] && \
				PH_APP_CMD="bash"
			if ! pgrep -t "tty${PH_APP_TTY}" -f "${PH_APP_CMD}" >/dev/null 2>&1
			then
				ph_run_with_rollback -c "ph_stop_services 'getty@tty${PH_APP_TTY}'" || \
					return 1
			fi
			[[ "${PH_APP}" == "Bash" ]] && \
				PH_APP_CMD="/bin/bash"
		fi
		printf "%8s%s\033[1;33m%s\033[0;0m%s\033[1;33m%s\033[0;0m\n" "" "--> Switching to " "'tty${PH_APP_TTY}'" " allocated to " "'${PH_APP}'"
		if "${PH_SUDO}" chvt "${PH_APP_TTY}" 2>/dev/null
		then
			ph_run_with_rollback -c true
		else
			ph_set_result -m "An error occurred trying to switch to tty${PH_APP_TTY}"
			ph_run_with_rollback -c false -m "Could not ${PH_ACTION}"
		fi
		return "${?}"
	fi ;;
		     stop)
	while true
	do
		printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Comparing the current foreground tty and the tty allocated to " "'${PH_APP}'"
		if [[ "${PH_FG_CONSOLE}" != "${PH_APP_TTY}" ]]
		then
			ph_set_result -m "Could not ${PH_ACTION} '${PH_APP}' since foreground 'tty${PH_FG_CONSOLE}' is not 'tty${PH_APP_TTY}' allocated to '${PH_APP}'"
		else
			ph_run_with_rollback -c true -m "Both tty${PH_FG_CONSOLE}"
			printf "%8s%s\033[1;33m%s\033[0;0m\n" "" "--> Stopping " "'${PH_APP}'"
			if [[ "${PH_APPU_PERSISTENT}" == "yes" && "${PH_STOP_MODE}" == "normal" ]]
			then
				printf "%10s\033[33m%s\033[0m\n" "" "Warning : Application is set persistent -> Skipping"
				ph_set_result -r 0 -w -m "Skipping the stop of '${PH_APP}' since it is marked persistent"
				break
			else
				case "${PH_APP}" in Moonlight)
					while pgrep -t "tty${PH_APP_TTY}" -f "^${PH_APP_CMD}" >/dev/null 2>&1
					do
						"${PH_SUDO}" -u "${PH_APP_USER}" -c "LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib ${PH_MOON_PATH} quit" >/dev/null 2>&1
						sleep 2
					done ;;
						    PieHelper) 
					shopt -u extdebug
					"${PH_SUDO}" chvt 1 2>/dev/null ;;
						    *) 
					"${PH_SUDO}" chvt "${PH_PIEH_TTY}" 2>/dev/null ;;
				esac
				if ph_run_with_rollback -c "ph_stop_services 'getty@tty${PH_APP_TTY}'"
				then
					printf "%8s%s\n" "" "--> Checking for controller usage"
					if [[ "${PH_APPU_USE_CTRL}" == "yes" ]]
					then
						ph_run_with_rollback -c true -m "Yes"
						if ph_cleanup_controllers full
						then
							printf "%8s%s\n\n" "" "--> Displaying reminder about controller(s)"
							printf "%12s\033[1;37m%s\033[0;0m\n\n" "" "- Please manually turn off your controller(s)"
							ph_run_with_rollback -c true
							sleep 4
						else
							return 1
						fi
					else
						ph_run_with_rollback -c true -m "No"
					fi
					ph_run_app_addon -a "${PH_APP}" -d "post_cmd"
					printf "%8s%s\n" "" "--> Checking for CIFS mount configuration"
					if [[ "${PH_APPU_CIFS_SHARE}" == "no" ]]
					then
						ph_run_with_rollback -c true -m "Not Found"
					else
						ph_run_with_rollback -c true -m "Found"
						ph_run_with_rollback -c "ph_umount_cifs_share '${PH_APP}'" || \
							return 1
					fi
					ph_add_value_to_param -p PH_APPS_ACTION -v "${PH_APP}'start'${PH_STOP_MODE}"
					ph_run_with_rollback -c true
					break
				fi
			fi
		fi
		ph_run_with_rollback -c false -m "Could not ${PH_ACTION}" || \
			return 1
	done ;;
esac
return 0
}
